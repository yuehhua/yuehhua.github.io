
<!DOCTYPE html>
<html lang="en">
    
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Dream Maker">
    <title>Archives: 2018/7 - Dream Maker</title>
    <meta name="author" content="Yueh-Hua Tu">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Dream Maker">
<meta property="og:url" content="https://yuehhua.github.io/archives/2018/07/index.html">
<meta property="og:site_name" content="Dream Maker">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dream Maker">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-3frockyt2j28isvdztjchy5nhkz8tjki9ermufc1ckptmvjdftux94m2ahub.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-119690895-1', 'auto');
        ga('send', 'pageview');
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
</head>

    <body>
        <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Dream Maker</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Search"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yuehhua/" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.facebook.com/a504082002" target="_blank" rel="noopener" title="Facebook">
                    
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://www.linkedin.com/in/%E5%B2%B3%E8%8F%AF-%E6%9D%9C-6a3995a0/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:a504082002@gmail.com" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fab fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/09-topology/">
                            Topology space and topology
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:32:23+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>我們終於來到拓樸學的大門口了！</p>
<p>（謎：前面走那麼多圈是在幹什麼的！</p>
<p>拓樸其實是幾何學的拓展，他往更基礎的方向去，當我們在探討幾何學的時候，其實我們研究的是空間關係。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/8/85/Stereographic_projection_in_3D.png" alt=""></p>
<p>空間關係裏面，我們研究大小、位置、角度、維度，再到比較高階的概念：面積或體積。</p>
<p>這邊需要一些線性代數的基礎進來，我們知道高階的概念是建立在較基礎的概念上，像是在有面積跟體積之前，要先定義長度，而長度則是由線性代數的範數（norm）給出，而角度的概念也是要先定義範數。</p>
<p>賦範空間（normed space）則是有定義範數的座標系。</p>
<p>空間中的位置與維度則是由座標系定義，而座標系則是我們先前定義的 m-tuple 的集合（所構成的空間）。</p>
<p>那麼最基礎的東西是什麼呢？</p>
<p>座標系中的 m-tuple，每個元素是由實數定義的。前面我們花時間討論了實數與整數。</p>
<p>在實數當中，我們之能知道兩個實數之間的關係，只能是大於、小於或等於三者其中之一。</p>
<p>但是當我們想討論空間中的 <strong>連續性</strong>，或是空間中的 <strong>鄰近</strong> 關係的時候，我們不知道到底什麼是連續？什麼是鄰近？</p>
<p>或許你可以說連續就是一個挨著一個，緊接著的元素或是數字，那這樣整數是連續的嗎？</p>
<p>數字 1 下一個是 2？</p>
<p>或是 1.0 的下一個是 1.000000000000000000000000000000001？</p>
<p>不對阿！那你把 1.0000000000000000000000000000000005 放到哪裡去了？</p>
<p>我們會認為實數是連續的，但整數不是，可是我們在整數中可以找到 <strong>下一個</strong>，可是實數當中不行。</p>
<p>所以 <em>找不到下一個人的系統</em> 就是連續？當然不是阿！我可以不要定義下一個人是誰就不會有下一個人阿！</p>
<p>所以拓樸學研究的就是空間上的連續跟鄰近關係。</p>
<hr>
<p>我們會先討論 <strong>鄰近</strong>，或是 <strong>鄰居</strong> 的概念。</p>
<p>近代分析學的基礎是極限，微分跟積分都是根基於這個概念之上，而對於極限的探討跟嚴謹程度造就了拓樸學這個領域。在極限的概念之中，我們談的是逼近，在 $\epsilon - \delta$ 的證明當中，不難發覺他其實給了一個不定的範圍，可大可小，那逼近的程度就可以計算得出來了，而 <strong>鄰近</strong> 的概念正是可以在這邊發揮作用的。</p>
<p><img src="/pics/topology1.svg" alt=""></p>
<p>一條直線，我們可以把他想成一條軟繩子，繩子上的任何一點，無論繩子怎麼扭曲，點鄰近的區域是不變的。不過這時候如果我們把繩子的兩頭相接起來那就不一樣了。</p>
<p><img src="/pics/topology2.svg" alt=""></p>
<p>我們可以看上面這個圖，當繩子繞成一個圓的時候，相接的黑點的鄰近區域是黑點的左右兩塊。黑點剛好對應到線段的兩個端點，兩個端點的鄰近區域是上圖中紅色所顯示的。你可以看到繩子因為被接起來，所以改變了他的鄰近區域，而這個改變我們可以用一個函數來把他對映起來：</p>
<p>$$<br>f(x) = x \enspace mod \enspace 12<br>$$</p>
<p>你可以想像有類似時鐘的 12 個數字擺在圓的線上，而線段上也有 1~12 的數字，在時鐘上的 12 鄰近有 11 跟 1，但是在線段上的 12 的鄰近只有 11，上述的函數則是可以把線段對映到圓上。</p>
<div style="text-align:center">線 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 圓</div>

<p>$$<br>\begin{bmatrix}<br>\vdots \\<br>10 \\<br>11 \\<br>12 \\<br>13 \\<br>14 \\<br>\vdots<br>\end{bmatrix}<br>\rightarrow<br>\begin{bmatrix}<br>\vdots \\<br>10 \\<br>11 \\<br>0 \\<br>1 \\<br>2 \\<br>\vdots<br>\end{bmatrix}<br>$$</p>
<p>原本在空間上，線段是無法由一頭持續走向另一頭的，但是卻可以透過函數來把兩頭接起來，這樣鄰近的空間也改變了，這時候我們想要描述空間中的鄰近關係，我們透過集合論給出了以下的特性：</p>
<p>一個鄰近區域（neighborhood） $X$，$\forall x \in X$，我們說 $X$ 是 $x$ 的鄰近區域，他需要滿足：</p>
<ol>
<li>$x$ 在它自己的鄰近區域中</li>
<li>兩個 $x$ 的鄰近區域的交集仍然是 $x$ 的鄰近區域</li>
<li>若 $X$ 的子集包含了 $x$ 的鄰近區域，那麼他也是 $x$ 的鄰近區域</li>
<li>$x$ 的鄰近區域的內部也是 $x$ 的鄰近區域</li>
</ol>
<p><img src="/pics/topology3.svg" alt=""></p>
<p>這些特性含蠻直觀的。$x$ 要在它自己的鄰近區域中，不滿足的話會導致很多運算都沒有封閉性。鄰近區域的交集仍是 $x$ 的鄰近區域也是很直觀的特性。最後兩條其實是有點相對的概念，第 3 條描述到一個比 $x$ 的鄰近區域大的，他也要是 $x$ 的鄰近區域，而第 4 條則是比 $x$ 的鄰近區域更小的，也要是 $x$ 的鄰近區域。</p>
<p>不過這樣的定義很複雜，不好用，所以後續引出了 <strong>拓樸（topology）</strong> 的定義，來代表鄰近區域：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>A topology on a set $X$ is a collection $\mathcal{T}$ of subsets of $X$ having the following properties:</p>
<ol>
<li>$\emptyset, X \in \mathcal{T}$</li>
<li>$\bigcup_{A \in \mathcal{T}} A \in \mathcal{T}$</li>
<li>$\bigcap_{A_i \in \mathcal{T}} A_i \in \mathcal{T}$, $i$ is finite</li>
</ol>
<p>來解釋一下，一個是需要定義在一個集合 $X$ 上的，而拓樸是 $X$ 的子集合的集合 $\mathcal{T}$。這個拓樸 $\mathcal{T}$ 需要滿足一些特性。空集合跟集合 $X$ 本身也在 $\mathcal{T}$ 中，這應該蠻直覺的，也就是集合 $X$ 是在自己的鄰近區域，有時候自己的鄰近區域沒有人也是很正常的。接著是，拓樸中的元素互相取聯集，仍然在這個拓樸中，也就是，鄰近區域的聯集仍然是鄰近區域。最後，拓樸中的元素互相取交集，仍然在這個拓樸中，也就是，鄰近區域的交集仍然是鄰近區域。不過要注意的是，聯集可以取無限聯集，但交集只能有限次數，主要是取無限次的交集很有可能都變成空集合，他就沒有意義，而且我們不知道無限次的交集到底是長什麼樣子。</p>
<p>這時候我們就會稱這個集合 $X$ 為 <strong>拓樸空間（topological space）</strong>。</p>
<p>更好的說法是，拓樸空間其實是集合跟拓樸的配對 $(X, \mathcal{T})$，所以他應該包含一個集合跟一個拓樸，但沒有異議的話，常常省略 $\mathcal{T}$ 不講。</p>
<p>這時候就需要來點例題幫助理解這個抽象概念。</p>
<h4 id="ex"><a href="#ex" class="headerlink" title="ex."></a><em>ex.</em></h4><p>$X = \{A, B, C\}$ 是一個 3 個元素的集合，以下哪些是一個佈於 $X$ 上的拓樸？</p>
<ol>
<li>$\mathcal{T} = \{\emptyset, X\}$ 是一個拓樸</li>
<li>$\mathcal{T} = \{\emptyset, \{A\}, \{A, B\}, X\}$ 是一個拓樸</li>
<li>$\mathcal{T} = \{\emptyset, \{B\}, \{A, B\}, \{B, C\}, X\}$ 是一個拓樸</li>
<li>$\mathcal{T} = \{\emptyset, \{A\}, X\}$ 是一個拓樸</li>
<li>$\mathcal{T} = \{\emptyset, \{A, B\}, \{C\}, X\}$ 是一個拓樸</li>
<li>$\mathcal{T} = \{\emptyset, \{A\}, \{B\}, \{A, B\}, X\}$ 是一個拓樸</li>
<li>$\mathcal{T} = \{\emptyset, \{A\}, \{B\}, X\}$ 不是一個拓樸<ul>
<li>$\{A\}, \{B\}$ 的聯集不在 $\mathcal{T}$ 中</li>
</ul>
</li>
<li>$\mathcal{T} = \{\emptyset, \{A, B\}, \{B, C\}, X\}$ 不是一個拓樸<ul>
<li>$\{A, B\}, \{B, C\}$ 的交集不在 $\mathcal{T}$ 中</li>
</ul>
</li>
</ol>
<p>接下來就來名詞解釋拉！</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$X$ 是一個集合</p>
<ol>
<li>The collection of all subsets of $X$ (the power set of $X$, $\mathcal{P}(X)$) is called <strong>discrete topology（離散拓樸）</strong></li>
<li>$\{ \emptyset, X \}$ is called <strong>trivial topology</strong> or <strong>indiscrete topology</strong></li>
</ol>
<p>我們可以來比較看看這兩個拓樸：$\{\emptyset, X\}, \{\emptyset, \{A\}, \{A, B\}, X\}$（用上面例子的集合定義）。</p>
<p>兩者都是佈於 $X$ 的拓樸，那他們有什麼差別呢？我們可以這樣說：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$\mathcal{T}, \mathcal{T}’$ 是兩個佈於集合$X$ 的拓樸：</p>
<ol>
<li>If $\mathcal{T}’ \supseteq \mathcal{T}$, $\mathcal{T}’$ is <strong>finer（細緻）</strong> than $\mathcal{T}$.</li>
<li>If $\mathcal{T}’ \subseteq \mathcal{T}$, $\mathcal{T}’$ is <strong>coarser（粗略）</strong> than $\mathcal{T}$.</li>
</ol>
<p>引入了這樣的描述方式，我們一樣可以用集合中的 strictly（嚴格）finer or coarser 來描述他們。如果兩個拓樸可以用以上兩種關係來描述的話，我們就說他們是 <strong>comparable</strong>。</p>
<p>有的人會以 smaller, larger 或是 weaker, stronger 來描述，只是這樣沒有那麼的傳神。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/09-topology/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/08-infinite-sets/">
                            Infinite sets
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:31:24+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>我們已經遇到一些無限集（infinite set），接下來會討論他的一些特性，然後會自然地討論到選擇公理（axiom of choice）。</p>
<blockquote>
<p> <strong><em>Theorem</em></strong></p>
</blockquote>
<p>$A$ 是一個集合，以下的命題等價：</p>
<ol>
<li>$\exists \enspace injective \enspace f: \mathbb{N} \rightarrow A$</li>
<li>$B \subset A, \exists \enspace bijective \enspace f: A \rightarrow B$</li>
<li>$A$ is infinite</li>
</ol>
<p>直觀來說，第一點還蠻直覺的，因為 $\mathbb{N}$ 本身就是無限集，如果要滿足有單射函數存在的話，也就意味著 $A$ 至少跟 $\mathbb{N}$ 一樣大。第二點來說，一開始會覺得有點弔詭，怎麼有人跟自身的嚴格子集一樣大，也就是說，這樣的集合即便多一個或是少一個元素都無所謂，反正都是無限大，當然這是直觀上的推論，並非正式推導。</p>
<p>比較有趣的是要從第三點推導出第一點，證明邏輯是這樣的，因為 $A$ 本身不是有限集，那他就不會是空集合。我們的目標是要證明存在一個單射函數滿足第一點的條件，那我們可以從 $A$ 取一個元素 $a_1$ 他叫作 $f(1)$，那麼根據歸納法，我們可以跳到假設 $f(1), … , f(n-1)$ 都存在，我們來檢查一下 $A - \{f(1), … , f(n-1)\}$ 仍然不是空集合，那這樣我們就可以再拿出一個元素定義 $a_n = f(n)$，這樣我就根據歸納法造出了一個單射函數了。</p>
<p>證明圓滿結束！嗯？有問題？哪裡有問題？</p>
<p>如果我每次從 $A$ 當中取出來的元素，他有可能不是唯一的，不是唯一的有什麼樣的問題呢？不是唯一的，那就有可能會重複被選到，那這樣我們不能接受他是個好的歸納法。也就是，$f(n)$ 要相對 $f(1), … , f(n-1)$ 是唯一的。</p>
<p>要處理唯一的問題，我只要引進唯一就好了阿！像是我可以定義從 $A$ 中取元素的時候只取最小的。如果最小元素存在的話，$A$ 勢必要是有定義次序關係才行！但是純粹的集合是沒有的。</p>
<p>這時候我們引進選擇公理來幫我們解決這個問題：</p>
<blockquote>
<p> <strong><em>Axiom of choice</em></strong></p>
</blockquote>
<p>給一個 collection $\mathcal{A}$ 是非空集合的集合，$\exists C \subseteq \bigcup_{A \in \mathcal{A}} A, \forall A \in \mathcal{A}, C \cap A$ contains only one element.</p>
<p>以上公理我解釋一下，也就是存在一個集合 $C$，他從 $\mathcal{A}$ 的每一個元素 $A$ 中都取一個元素進來。</p>
<p>接下來就會有以下的引理：</p>
<blockquote>
<p> <strong><em>Lemma</em></strong></p>
</blockquote>
<p>給一個 collection $\mathcal{B}$ 是非空集合的集合，$\exists c: \mathcal{B} \rightarrow \bigcup_{B \in \mathcal{B}} B$ s.t. $\forall B \in \mathcal{B}, c(B) \in B.$</p>
<p>目前先寫到這邊，下面的解釋還有構造方法我還沒理解………..嗚嗚。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/08-infinite-sets/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/07-countable-sets/">
                            Countable sets
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:29:45+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>前面有提到正整數可以用來作為有限集的原型，我們會把所有正整數的集合稱為 <strong>可數無限集（countably infinite sets）</strong>。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>A set A is <strong><em>infinite</em></strong> if not finite.</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>A set A is <strong><em>countably infinite</em></strong> if<br>$$<br>\exists f: A \rightarrow \mathbb{N}, f \enspace is \enspace bijective.<br>$$</p>
<h4 id="ex"><a href="#ex" class="headerlink" title="ex."></a><em>ex.</em></h4><p>像是整數本身就是 countably infinite，$f: \mathbb{Z} \rightarrow \mathbb{N}$</p>
<p>$$<br>f(n) = \begin{cases}<br>2n &amp; n\gt 0 \<br>-2n+1 &amp; n \le 0<br>\end{cases}<br>$$</p>
<h4 id="ex-1"><a href="#ex-1" class="headerlink" title="ex."></a><em>ex.</em></h4><p>$\mathbb{N} \times \mathbb{N}$ 也是 countably infinite，那要如何證明呢？</p>
<p>我們需要證明 $f: \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{N}$，由於 $\mathbb{N} \times \mathbb{N}$ 是在座標系的第1象限上的格子點，我們先把他向下圖一樣定一個順序，下圖的順序也包含 0，但是在我們的例子中不包含 0，但概念是一樣的。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Pairing_natural.svg" alt=""></p>
<p>我們希望像這樣把 $\mathbb{N}$ 一個一個擺到 $\mathbb{N} \times \mathbb{N}$，這樣我們就可以確認兩者的對應關係了，那要怎麼做呢？</p>
<p>我們先定個函數 $g(x, y) = (x + y - 1 , y)$，這會把每串黑色箭頭都擺直。</p>
<p>接著可以用另一個函數 $h(x , y) = \frac{1}{2}(x - 1)x + y$ 幫我們對映到數字。</p>
<p>對映關係會看起來像這樣：</p>
<p>$(1, 1) \rightarrow (1, 1) \rightarrow 1$</p>
<p>$(2, 1) \rightarrow (2, 1) \rightarrow 2$</p>
<p>$(1, 2) \rightarrow (2, 2) \rightarrow 3$</p>
<p>$(3, 1) \rightarrow (3, 1) \rightarrow 4$</p>
<p>$(2, 2) \rightarrow (3, 2) \rightarrow 5$</p>
<p>如此對映起來之後，再證明這兩個函數的組合是雙射的，就可以證明 $\mathbb{N} \times \mathbb{N}$ 是 countably infinite。</p>
<p>所以我們就可以給可數下個定義：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>A set A is <strong><em>countable</em></strong> if it is finite or countably infinite.</p>
<p>A set A is <strong><em>uncountable</em></strong> if it is not countable.</p>
<p>那如果我們每次都要證明一個集合是不是可數的就會比較麻煩，以下有些等價的敘述：</p>
<blockquote>
<p> <strong><em>Theroem</em></strong></p>
</blockquote>
<p>A is a nonempty set.</p>
<ol>
<li>A is countable</li>
<li>$\exists f: \mathbb{N} \rightarrow A$, f is surjective</li>
<li>$\exists g: A \rightarrow \mathbb{N}$, g is injective</li>
</ol>
<p>我們有其他定理：</p>
<blockquote>
<p> <strong><em>Theroem</em></strong></p>
</blockquote>
<p>$$<br>C \subseteq \mathbb{N}, C \enspace is \enspace infinite, then \enspace C \enspace is \enspace countably \enspace infinite.<br>$$</p>
<p>跟其他結論：</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>A subset of a countable set is countable.</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>$\mathbb{N} \times \mathbb{N}$ is countably infinite.</p>
<blockquote>
<p> <strong><em>Theroem</em></strong></p>
</blockquote>
<p>A countable union of countable sets is countable.</p>
<p>看到這邊大家不知道有沒有跟我一樣的疑問，為什麼會有 <em>countable union</em> 這樣的敘述呢？</p>
<p>如果有個集合 $A_n$ 是可數的，$f_n$ is surjective，$f_n: \mathbb{N} \rightarrow A_n$，我們可以選另一個函數 $g$ is surjective，$g: \mathbb{N} \rightarrow J$，使得</p>
<p>$$<br>h: \mathbb{N} \times \mathbb{N} \rightarrow \bigcup_{n \in J} A_n<br>$$</p>
<p>所以我們把 <em>countable union</em> 看成在 $n \in J$ 的 $J$，$h$ 可以看成 $f_n$ 跟 $g$ 的合成函數 $h(k, m) = f_{g(k)}(m)$，如此一來，我們已經知道 surjective 函數的合成還是 surjective，而 $\mathbb{N} \times \mathbb{N}$ 也是 countable，這樣我們就可以證明 $\bigcup_{n \in J} A_n$ 是 countable。</p>
<blockquote>
<p> <strong><em>Theroem</em></strong></p>
</blockquote>
<p>A finite product of countable sets is countable.</p>
<p>也就是說，$A_1 \times A_2 \times … \times A_n$ 是 countable。</p>
<blockquote>
<p> <strong><em>Theroem</em></strong></p>
</blockquote>
<p>$$<br>X = \{ 0, 1 \}, then \enspace X^\omega \enspace is \enspace uncountable.<br>$$</p>
<p>這邊描述了一個特例，以下是比較廣義的敘述：</p>
<blockquote>
<p> <strong><em>Theroem</em></strong></p>
</blockquote>
<p>$A$ is a set,</p>
<p>$$<br>\nexists \enspace injective \enspace f: \mathcal{P}(A) \rightarrow A<br>$$</p>
<p>$$<br>\nexists \enspace surjective \enspace g: A \rightarrow \mathcal{P}(A)<br>$$</p>
<p>這代表著一個集合的冪集是 <em>uncountable set</em>，無論集合裏面長什麼樣子。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/07-countable-sets/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/06-finite-sets/">
                            Finite sets
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:27:18+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>接下來我們會來討論幾個常見的概念，像是有限集及無限集、可數集及不可數集。</p>
<p>有限集（finite set）：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>A set A is <strong><em>finite</em></strong> if</p>
<p>$$<br>\exists f: A \rightarrow \{ 1, …, n \}, f \enspace is \enspace bijective.<br>$$</p>
<p>這時我們會說 <em>set</em> $A$ 的 cardinality 是 n。</p>
<p>在這其中，這個定義的結果是不是唯一的？也就是，有沒有一個可能存在一個集合，兩個人數當中的元素個數結果不一樣（一個數到 $m$，一個數到 $n$），但兩個人都是對的？在真實世界，你可能會覺得這根本不可能，但是為了這點，數學家做了一些基礎工作。</p>
<blockquote>
<p> <strong><em>Lemma</em></strong></p>
</blockquote>
<p>$$<br>A \enspace is \enspace a \enspace set, n \in \mathbb{N}, a_0 \in A, \exists f: A \rightarrow \{ 1, … , n+1\}, f \enspace is \enspace bijective<br>$$</p>
<p>$$<br>\Leftrightarrow \exists g: A - \{ a_0 \} \rightarrow \{ 1, … , n\}, g \enspace is \enspace bijective<br>$$</p>
<p>也就是呢，當 $A$ 可以對映到 $n+1$ 個元素的集合的時候，把 $A$ 當中的一個元素拿掉，就必須對映到 $n$ 個元素的集合。</p>
<p>那接下來我們就可以有這個定理：</p>
<blockquote>
<p> <strong><em>Theorem</em></strong></p>
</blockquote>
<p>$$<br>A \enspace is \enspace a \enspace set, f: A \rightarrow \{ 1, … , n\}, n \in \mathbb{N}, f \enspace is \enspace bijective, B \subset A<br>$$</p>
<p>$$<br>then \enspace \nexists g: B \rightarrow \{ 1, … , n\}, g \enspace is \enspace bijective<br>$$</p>
<p>$$<br>\exists h: B \rightarrow \{ 1, … , m\}, h \enspace is \enspace bijective, m &lt; n<br>$$</p>
<p>所以是說，$B$ 是 $A$ 的嚴格子集，那麼 $B$ 的 cardinality 就必須跟 $A$ 的不同，並且要比較小。</p>
<p>以此，我們可以導出以下結論：</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>$$<br>If \enspace A \enspace is \enspace finite, B \subset A, \nexists f: A \rightarrow B, f \enspace is \enspace bijective<br>$$</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>$$<br>\mathbb{N} \enspace is \enspace not \enspace finite<br>$$</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>$$<br>The \enspace cardinality \enspace of \enspace a \enspace finite \enspace set \enspace A \enspace is \enspace uniquely \enspace determined \enspace by \enspace A<br>$$</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>$$<br>A \enspace is \enspace finite, B \subset A, B \enspace is \enspace finite<br>$$</p>
<p>有限集，以下等價：</p>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<ol>
<li>$A$ is finite</li>
<li>Exists a surjective function from a section of $\mathbb{N}$ to $A$</li>
<li>Exists a injective function from $A$ to a section of $\mathbb{N}$</li>
</ol>
<blockquote>
<p> <strong><em>Corollary</em></strong></p>
</blockquote>
<p>$$<br>Finite \enspace unions \enspace and \enspace finite \enspace cartesian \enspace products \enspace of \enspace finite \enspace sets \enspace are \enspace finite<br>$$</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/06-finite-sets/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/05-cartesian-products/">
                            Cartesian products
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:26:26+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>前面我們定義了集合的笛卡爾積，這邊我們來定義一個更廣義的，$\mathcal{A}$ 是一個非空集合（collection of sets）：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \enspace indexing \enspace function \enspace is \enspace a \enspace surjective \enspace function \enspace f: J \rightarrow \mathcal{A},<br>$$</p>
<p>$$<br>J \enspace is \enspace called \enspace index \enspace set.<br>$$</p>
<p>$$<br>The \enspace collection \enspace with \enspace the \enspace indexing \enspace function \enspace f \enspace is \enspace called \enspace indexed \enspace family \enspace of \enspace sets.<br>$$</p>
<p>所以如果有 $\alpha \in J$ ，我們會把 $f(\alpha)$ 寫成 $A_\alpha$。那麼 indexed family 本身可以寫成 $\{A_\alpha\}_{\alpha \in J}$。</p>
<p>這個概念有點類似在電腦科學中的 hash function/dictionary 或是指標的意味，有了一個函數可以對某個集合做 indexing。然而他必須是滿射的（surjective），而不是單射的（injective）。</p>
<p>應用這樣的概念來描述以往的概念就會有點不太一樣：</p>
<p>$f: J \rightarrow \mathcal{A} \enspace is \enspace an \enspace indexing \enspace function \enspace for \enspace \mathcal{A}$</p>
<p>$\bigcup_{\alpha \in J} A_\alpha = \{ x \mid at \enspace least \enspace one \enspace \alpha \in J, x \in A_\alpha \}$</p>
<p>$\bigcap_{\alpha \in J} A_\alpha = \{ x \mid for \enspace every \enspace \alpha \in J, x \in A_\alpha \}$</p>
<p>我們進一步定義<strong>m-元組（m-tuple）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>m \in \mathbb{N}, a \enspace set \enspace X, m-tuple \enspace of \enspace elements \enspace of \enspace X \enspace is<br>$$</p>
<p>$$<br>x: \{1, …, m\} \rightarrow X<br>$$</p>
<p>這邊 $x$ 是個 m-tuple，我們通常描述 $x$ 的第 i 個值會寫成 $x_i$ ，也就是第 i 分量，也就是<strong>座標（coordinate）</strong>。那表示 $x$ 本身則會寫成：</p>
<p>$$<br>(x_1, …, x_m)<br>$$</p>
<p>接下來，我們讓 $\{ A_1, …, A_m \}$ 是一個 <em>family of indexed sets</em>。 $X = A_1 \cup A_2 \cup … \cup A_m$。我們定義這個 <em>indexed family</em> 的 cartesian product 為：</p>
<p>$$<br>\prod_{i = 1}^{m} A_i \enspace or \enspace A_1 \times A_2 \times … \times A_m<br>$$</p>
<p>也就是所有 m-tuple $(x_1, …, x_m)$ 的集合。</p>
<p>我們有了 m-tuple 就可以來定義一個常用的概念，$\omega-tuple$。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \enspace set \enspace X, \omega-tuple \enspace of \enspace elements \enspace of \enspace X \enspace is \enspace a \enspace function:<br>$$</p>
<p>$$<br>x: \mathbb{N} \rightarrow X<br>$$</p>
<p>這也是微積分當中的 <strong>數列（sequence）</strong>，或是 <strong>無限數列（infinite sequence）</strong>。我們也可以把 $\omega$-tuple $x$ 看成座標，則會表示成：</p>
<p>$$<br>(x_1, x_2, …)<br>$$</p>
<p>而 <em>cartesian product</em> 則是：</p>
<p>$$<br>\prod_{i \in \mathbb{N}} A_i \enspace or \enspace A_1 \times A_2 \times …<br>$$</p>
<p>這邊大家可能會疑惑，不同的 $A_i$ 之間有什麼不一樣嗎？其實他們都可能是一樣的，跟 $X$ 一樣，只是去表示位在不同的分量上。如果是 $X$ 的元素的 $m$-tuple 的話，就可以簡寫成 $X^m$。如果是 $X$ 的元素的 $\omega$-tuple 的話，就可以簡寫成 $X^\omega$。</p>
<h4 id="ex"><a href="#ex" class="headerlink" title="ex."></a><em>ex.</em></h4><p>如果 $\mathbb{R}$ 代表實數，那麼 $\mathbb{R}^m$ 就代表所有實數的 $m$-tuple 的集合，也就是歐幾里得空間（Euclidean m-space）。那 $\mathbb{R}^\omega$ 就是無限維度歐氏空間（infinite-dimensional Euclidean space）。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/05-cartesian-products/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/04-integer-real-numbers/">
                            The Integers and the Real Numbers
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:25:40+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>以上我們談了一些 <em>邏輯的基礎</em>，接下來我們會談一些 <em>數學的基礎</em>，也就是整數與實數系統。其實我們已經用了很多，非正式地，接下來我們會正式地討論他們。</p>
<p>要 <strong><em>建構</em></strong> 實數系統的一個方法就是利用公理跟集合論來建構。</p>
<p>首先我們需要從集合論出發，定義在 <em>set</em> $A$ 上的 <strong>二元運算子（binary operator）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>f: A \times A \rightarrow A<br>$$</p>
<p>我們在描述一個二元運算子的時候並不會如同以往的函數一樣， $f(a, a’)$，而是會把運算子寫在中間， $afa’$。一般來說，我們會用符號來表示，而不是字母，像是加號 $+$、乘號 $\cdot$。</p>
<h4 id="假設"><a href="#假設" class="headerlink" title="假設"></a>假設</h4><p>我們假設存在一個 <em>set</em> $\mathbb{R}$，代表實數，有兩個運算子分別是加法運算子 $+$、乘法運算子 $\cdot$，以及一個次序關係 $\lt$ 定義於 $\mathbb{R}$ 上，會有以下特性：</p>
<p><em>代數特性（Algebraic Properties）</em></p>
<ol>
<li>$(x + y) + z = x + (y + z), \forall x, y, z \in \mathbb{R}$</li>
</ol>
<p>$(x \cdot y) \cdot z = x \cdot (y \cdot z), \forall x, y, z \in \mathbb{R}$</p>
<ol start="2">
<li>$x + y = y + x, \forall x, y, z \in \mathbb{R}$</li>
</ol>
<p>$x \cdot y = y \cdot x, \forall x, y, z \in \mathbb{R}$</p>
<ol start="3">
<li>$\exists! 0 \in \mathbb{R}, \forall x \in \mathbb{R}, s.t. \enspace x + 0 = x$</li>
</ol>
<p>$\exists! 1 \in \mathbb{R}, \forall x \in \mathbb{R}, s.t. \enspace x \cdot 1 = x$</p>
<ol start="4">
<li>$for \enspace each \enspace x, \exists! y, s.t. \enspace x + y = 0$</li>
</ol>
<p>$for \enspace each \enspace x, \exists! y, s.t. \enspace x \cdot y = 1$</p>
<ol start="5">
<li>$x \cdot (y + z) = (x \cdot y) + (x \cdot z), \forall x, y, z \in \mathbb{R}$</li>
</ol>
<p><em>混合代數與次序特性（A Mixed Algebraic and Order Property）</em></p>
<ol start="6">
<li>$If \enspace x \gt y, then \enspace x + z \gt y + z$</li>
</ol>
<p>$If \enspace x \gt y, z \gt 0, then \enspace x \cdot z \gt y \cdot z$</p>
<p><em>次序特性（Order Properties）</em></p>
<ol start="7">
<li>次序關係 $\lt$ 有最小上界性</li>
<li>$If \enspace x \lt y, then \enspace \exists z \enspace s.t. \enspace x \lt z, z \lt y$</li>
</ol>
<p>由 1~5 點我們可以導出一些代數性質，像是負數、減法運算、倒數跟商的概念。我們可以定義正數（$x \gt 0$）跟負數（$x \lt 0$）。在代數領域，擁有 1~5 點特性的代數結構，我們會稱為域（field）。如果有包含第六點就稱為有序域（ordered field）。在拓樸領域我們通常會討論的是第7、8點，他只牽涉到次序關係，同時擁有這兩點的集合稱為線性連續統（linear continuum）。</p>
<p>說到這邊我們還沒提到整數呢！我們就用前6點來定義整數（integer）。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$A \subseteq \mathbb{R} \enspace is \enspace inductive:$</p>
<ol>
<li>$1 \in A$</li>
<li>$\forall x \in A \enspace s.t. \enspace x + 1 \in A$</li>
</ol>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$\mathcal{A} \enspace is \enspace a \enspace collection \enspace of \enspace all \enspace inductive \enspace subsets \enspace of \enspace \mathbb{R}$<br>$positive \enspace integers \enspace is \enspace a \enspace set \enspace \mathbb{N} = \bigcap_{A \in \mathcal{A}} A$</p>
<p>這樣的定義是很巧妙的，他其實只有明確的定義了1是在這個集合裡，後面都以 $x+ 1$ 的形式去推演，這稱為可歸納。而正整數是眾多可歸納集合的交集，可見正整數是最小的子集。</p>
<p>正整數有些特性：</p>
<ol>
<li>正整數是可歸納的（inductive）</li>
<li>（Principle of inductive）如果 <em>set</em> $A$ 是可歸納的，而且含正整數的集合，那麼 $A = \mathbb{N}$</li>
</ol>
<p>與實數不同的是，他不會有第八點特性，也就是，$for \enspace each \enspace n \in \mathbb{N}, \nexists a \in \mathbb{N} \enspace s.t. \enspace n \lt a \lt n + 1$。</p>
<hr>
<p>如果有個正整數 $n$，我們用 $S_{n}$ 來代表所有小於 $n$ 的正整數的集合，我們稱他為 <em>section</em>：</p>
<p>$$<br>S_{n + 1} = \{1, \dots , n\}<br>$$</p>
<p>接下來我們會描述 <del>證明</del> 兩個可能不是很熟悉但很有用的特性，你可以看成是另一個版本的數學歸納法：</p>
<blockquote>
<p> <strong><em>Theorem: Well-ordering property</em></strong></p>
</blockquote>
<p>$$<br>S \subseteq \mathbb{N}, S \neq \emptyset, S \enspace has \enspace smallest \enspace element.<br>$$</p>
<p>他描述了 $\mathbb{N}$ 的非空子集，一定有最小元素。</p>
<blockquote>
<p> <strong><em>Theorem: Strong induction principle</em></strong></p>
</blockquote>
<p>$$<br>A \enspace is \enspace a \enspace set \enspace of \enspace positive \enspace integers,<br>$$</p>
<p>$$<br>for \enspace each \enspace n, S_n \subseteq A \enspace s.t. \enspace n \in A, then \enspace A = \mathbb{N}<br>$$</p>
<p>這邊描述了，對每個 $n$ 來說，由 $S_n \subseteq A$ 可以推出 $n \in A$ 的話，那麼 $A$ 就是 $\mathbb{N}$。</p>
<p>以上我們用了有序域中的第 1~6 點公理，那第 7 點呢？</p>
<p>你用會用到第 7 點（最小上界公理）來證明，正整數集合 $\mathbb{N}$ 在實數的集合 $\mathbb{R}$ 中是沒有上界的。</p>
<blockquote>
<p><strong><em>Theorom: Archimedean ordering property</em></strong></p>
</blockquote>
<p>$$<br>the \enspace  set \enspace  \mathbb{N} \enspace  has \enspace  no \enspace  upper \enspace  bound \enspace  in \enspace  \mathbb{R}.<br>$$</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/04-integer-real-numbers/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/03-relations/">
                            Relations
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:24:38+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>我們有比函數還要更有彈性、更一般化的概念，稱為 <strong>關係（relations）</strong> 。</p>
<p>我們會定義數學上的關係，並且談到在數學上大量使用的兩個關係：等價關係及次序關係。次序關係將會貫穿整個拓樸學領域。</p>
<p><strong>關係（relations）</strong> 的定義如下：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \enspace relation \enspace on \enspace set \enspace A \enspace is<br>$$</p>
<p>$$<br>a \enspace subset \enspace C \subseteq A \times A<br>$$</p>
<p>這時候我們會把 <em>relation</em> $C$ 表示成 $xCy$ ，來代表 $(x, y) \in C$。</p>
<p>這時我們會理解成，$x$ 跟 $y$ 有 $C$ 的關係。</p>
<p>一個函數 $f: A \rightarrow A$ 是 $A \times A$ 的子集，所以函數也是一種關係。</p>
<p>任何是 $A \times A$ 的子集，都可以被視為一種關係。</p>
<h4 id="ex"><a href="#ex" class="headerlink" title="ex."></a><em>ex.</em></h4><p>$P$ 代表世界上全人類的集合，我們定義 $D \subseteq P \times P$ 為一種關係：</p>
<p>$$<br>D = \{ (x, y) \mid x \enspace is \enspace a \enspace descendant \enspace of \enspace y \}<br>$$</p>
<p>$D$ 代表的是子孫關係，$xDy$ 代表 $x$ 是 $y$ 的子孫。</p>
<p>我們也可以定義血緣關係 $B$：</p>
<p>$$<br>B= \{ (x, y) \mid x \enspace has \enspace an \enspace ancestor \enspace who \enspace is \enspace also \enspace an \enspace ancestor \enspace of \enspace y \}<br>$$</p>
<p>也就是，$x$ 跟 $y$ 有共同的祖先的話，那代表 $x$ 跟 $y$ 有血緣關係。如此一來，血緣關係就會是對稱的，子孫關係則不是。</p>
<h2 id="Equivalence-relations"><a href="#Equivalence-relations" class="headerlink" title="Equivalence relations"></a>Equivalence relations</h2><p>在 <em>set</em> $A$ 上的等價關係，是在 <em>set</em> $A$ 上的一種關係 $C$，並且滿足以下條件：</p>
<ol>
<li>Reflexivity（自身性）： $\forall x \in A, xCx$</li>
<li>Symmetry（對稱性）： If $xCy$, then $yCx$</li>
<li>Transitivity（遞移性）： If $xCy$ and $yCz$, then $xCz$</li>
</ol>
<p>關係並沒有強制規定說要用大寫字母表示，所以我們後面改成用大家比較常用的 $\sim$ （tilde）。</p>
<ol>
<li>$\forall x \in A, x \sim x$</li>
<li>If $x \sim y$, then $y \sim x$</li>
<li>If $x \sim y$ and $y \sim z$, then $x \sim z$</li>
</ol>
<h4 id="ex-1"><a href="#ex-1" class="headerlink" title="ex."></a><em>ex.</em></h4><p>我們可以檢驗看看 $\leq$ 在正整數（$\mathbb{N}$）上是不是一種等價關係？</p>
<ol>
<li>Reflexivity（自身性）： $\forall x \in \mathbb{N}, x \leq x$ <strong>成立</strong><ul>
<li>$1 \leq 1, 2 \leq 2, 3 \leq 3, …$</li>
</ul>
</li>
<li>Symmetry（對稱性）： If $x \leq y$, then $y \leq x$ <strong>不成立</strong><ul>
<li>$1 \leq 2, but \enspace not \enspace 2 \leq 1$</li>
</ul>
</li>
<li>Transitivity（遞移性）： If $x \leq y$ and $y \leq z$, then $x \leq z$ <strong>成立</strong><ul>
<li>$1 \leq 2, 2 \leq 4, then \enspace 1 \leq 4$</li>
</ul>
</li>
</ol>
<p>故 $\leq$ 不是等價關係。</p>
<h4 id="ex-2"><a href="#ex-2" class="headerlink" title="ex."></a><em>ex.</em></h4><p>假設一種等價關係是 $x \sim y$ ，定義為 $x \enspace (mod \enspace 3) = y \enspace (mod \enspace 3)$ ，那麼在 $\mathbb{N}$ 上，我們有 $5 \enspace (mod \enspace 3) = 2 = 8 \enspace (mod \enspace 3)$ 。那這有滿足等價關係嗎？</p>
<ol>
<li>Reflexivity（自身性）： $\forall x \in \mathbb{N}, x \sim x$ <strong>成立</strong><ul>
<li>$1 \enspace (mod \enspace 3) = 1 \enspace (mod \enspace 3), …$</li>
</ul>
</li>
<li>Symmetry（對稱性）： If $x \sim y$, then $y \sim x$ <strong>成立</strong><ul>
<li>$1 \enspace (mod \enspace 3) = 4 \enspace (mod \enspace 3)$</li>
<li>$4 \enspace (mod \enspace 3) = 1 \enspace (mod \enspace 3)$</li>
</ul>
</li>
<li>Transitivity（遞移性）： If $x \sim y$ and $y \sim z$, then $x \sim z$ <strong>成立</strong><ul>
<li>$1 \enspace (mod \enspace 3) = 4 \enspace (mod \enspace 3), 4 \enspace (mod \enspace 3) = 7 \enspace (mod \enspace 3),$</li>
<li>$then \enspace 1 \enspace (mod \enspace 3) = 7 \enspace (mod \enspace 3)$</li>
</ul>
</li>
</ol>
<p>故 $\leq$ 是等價關係。（以上非嚴謹證明）</p>
<p>所以可以把 $5 \sim 8$ 這兩者視為等價。</p>
<p>如果存在一種等價關係，那麼 <em>set</em> $A$ 裡的元素可以歸類成不同的 <strong>等價類（equivalent class）</strong>，假設 $x \in A, E \subseteq A$ ，我們有：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>E = \{ y \mid y \sim x \}<br>$$</p>
<h4 id="ex-3"><a href="#ex-3" class="headerlink" title="ex."></a><em>ex.</em></h4><p>延續上面一個例子，$x \sim y$ 是等價關係，那麼我們就可以把 $\mathbb{N}$ 拆成不同的等價類：</p>
<p>$$<br>1 \sim 4, 4 \sim 7, 7 \sim 10, …<br>$$</p>
<p>$$<br>E_1 = \{1, 4, 7, 10, …\}<br>$$</p>
<p>$$<br>2 \sim 5, 5 \sim 8, 8 \sim 11, …<br>$$</p>
<p>$$<br>E_2 = \{2, 5, 8, 11, …\}<br>$$</p>
<p>$$<br>3 \sim 6, 6 \sim 9, 9 \sim 12, …<br>$$</p>
<p>$$<br>E_3 = \{3, 6, 9, 12, …\}<br>$$</p>
<p>等價類有以下的特性：</p>
<blockquote>
<p> <strong><em>Lemma</em></strong></p>
</blockquote>
<p>$$<br>Two \enspace equivalent \enspace classes \enspace E \enspace and \enspace E’ \enspace are \enspace either \enspace disjoint \enspace or \enspace equal.<br>$$</p>
<p>白話文就是兩個等價類不是一樣就是互斥的。</p>
<p>有這樣的等價類，我們可以用 $\mathscr{E}$ 來表示所有等價類的集合（collection）。藉由以上的 Lemma，我們知道每個等價類都是互斥的。這樣我們可以把他看成是對 <em>set</em> $A$ 的<strong>分割（partition）</strong>。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \enspace partition \enspace of \enspace a \enspace set \enspace A \enspace is \enspace a \enspace collection \enspace of \enspace disjoint \enspace nonempty \enspace subsets \enspace of \enspace A<br>$$</p>
<p>$$<br>whose \enspace union \enspace is \enspace all \enspace of \enspace A.<br>$$</p>
<p>研究 <em>set</em> $A$ 上的等價關係等同於是研究 <em>set</em> $A$ 的分割。</p>
<h2 id="Order-relations"><a href="#Order-relations" class="headerlink" title="Order relations"></a>Order relations</h2><p>在 <em>set</em> $A$ 上的 <strong>次序關係（order relations, simple order or linear order）</strong>，是在 <em>set</em> $A$ 上的一種關係 $\lt$，並且滿足以下條件：</p>
<ol>
<li>Comparability（可比性）： $\forall x, y \in A, x \neq y, either \enspace x \lt y \enspace or \enspace y \lt x$</li>
<li>Nonreflexivity（非自身性）： $\nexists x \in A, x \lt x$</li>
<li>Transitivity（遞移性）： If $x \lt y$ and $y \lt z$, then $x \lt z$</li>
</ol>
<hr>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>\lt \enspace is \enspace an \enspace order \enspace relation \enspace on \enspace set \enspace X, a \lt b<br>$$</p>
<p>$$<br>(a, b) = \{ x \mid a \lt x \lt b \} \enspace is \enspace an \enspace open \enspace interval \enspace on \enspace X<br>$$</p>
<p>我們可以像這樣去定義 <strong>開區間（open interval）</strong>。如果 $(a, b) = \emptyset$，那稱 $a$ 是 $b$ 的 <strong>緊鄰前元（immediate predecessor）</strong>，而 $b$ 是 $a$ 的 <strong>緊鄰後元（immediate successor）</strong>。</p>
<hr>
<p>假定有 $A$ 跟 $B$ 兩個集合，有兩個相對應的次序關係 $\lt_A$ 跟 $\lt_B$。我們說這兩個集合有相同的 <strong>次序類型（order type）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>\exists f: A \rightarrow B, f \enspace is \enspace bijective<br>$$</p>
<p>$$<br>s.t. \enspace a_1 \lt_A a_2, then \enspace f(a_1) \lt_B f(a_2)<br>$$</p>
<p>這樣的雙射函數有<strong>保留</strong>次序關係。</p>
<h4 id="ex-4"><a href="#ex-4" class="headerlink" title="ex."></a><em>ex.</em></h4><p>在實數區間 $(1, -1)$ 有跟 $\mathbb{R}$ 相同的次序類型。</p>
<p>考慮函數 $f: (1, -1) \rightarrow \mathbb{R}$：</p>
<p>$$<br>f(x) = \frac{x}{1 - x^2}<br>$$</p>
<p>他是一個嚴格遞增函數（保留次序關係）且為雙射。</p>
<hr>
<p>接下來我們談談 <strong>字典序關係（dictionary order relation）</strong>，他是定義在 $A \times B$ 上的次序關係，假定 $A$ 跟 $B$ 集合上有次序關係 $\lt_A$ 跟 $\lt_B$。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>\lt \enspace on \enspace A \times B \enspace is \enspace a_1 \times b_1 \lt a_2 \times b_2<br>$$</p>
<p>$$<br>if \enspace a_1 \lt_A a_2, or \enspace a_1 = a_2 \enspace and \enspace b_1 \lt_B b_2<br>$$</p>
<h4 id="ex-5"><a href="#ex-5" class="headerlink" title="ex."></a><em>ex.</em></h4><p>所謂的字典序就是先比較第一個字元，如果一樣再比較第二的字元的次序，如此繼續下去。</p>
<p>$$<br>aaa &lt; aab &lt; abb<br>$$</p>
<p>如此一來，就可以為 $A \times B \times \dots$ 這樣子的集合定義次序了。</p>
<hr>
<p>在實數中，你或許以前看過最小上界的特性。你可以為任意的有序集合定義這樣的特性。</p>
<p>假設 <em>set</em> $A$ 有次序關係 $\lt$，$A_0 \subseteq A$，</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>b \in A_0, \forall x \in A_0, x \le b<br>$$</p>
<p>$$<br>b \enspace is \enspace the \enspace largest \enspace element \enspace of \enspace A_0<br>$$</p>
<p>如果相反的話，</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>a \in A_0, \forall x \in A_0, x \ge a<br>$$</p>
<p>$$<br>a \enspace is \enspace the \enspace smallest \enspace element \enspace of \enspace A_0<br>$$</p>
<p>我們很簡單可以知道，一個集合會有最多一個最大的元素，以及最多一個最小的元素。</p>
<p>那如果我們要說，$A_0$ 有<strong>上界（bounded above）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>b \in A, \forall x \in A_0, x \le b<br>$$</p>
<p>$$<br>b \enspace is \enspace an \enspace upper \enspace bound \enspace for \enspace A_0<br>$$</p>
<p>而上界的元素中，最小的稱為<strong>最小上界（least upper bound）</strong>，或是 <strong>supremum</strong>，記為 $sup \enspace A_0$：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>X = \{ x \mid \forall x \enspace is \enspace upper \enspace bound \enspace for \enspace A_0 \}<br>$$</p>
<p>$$<br>The \enspace smallest \enspace element \enspace of \enspace X \enspace is \enspace least \enspace upper \enspace bound<br>$$</p>
<p>他有可能屬於 $A_0$，如果 $sup \enspace A_0 \in A_0$，他同時也是 $A_0$ 最大的元素。</p>
<p>相反，$A_0$ 有<strong>下界（bounded below）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>a \in A, \forall x \in A_0, x \ge a<br>$$</p>
<p>$$<br>a \enspace is \enspace an \enspace lower \enspace bound \enspace for \enspace A_0<br>$$</p>
<p>而下界的元素中，最大的稱為<strong>最大下界（greatest lower bound）</strong>，或是 <strong>infimum</strong>，記為 $inf \enspace A_0$：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>Y = \{ y \mid \forall y \enspace is \enspace lower \enspace bound \enspace for \enspace A_0 \}<br>$$</p>
<p>$$<br>The \enspace greatest \enspace element \enspace of \enspace Y \enspace is \enspace greatest \enspace lower \enspace bound<br>$$</p>
<p>他有可能屬於 $A_0$，如果 $inf \enspace A_0 \in A_0$，他同時也是 $A_0$ 最小的元素。</p>
<p>這些跟所謂的 <strong>最大值（maximum）</strong> 或是 <strong>最小值（minimum）</strong> 不太一樣：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>b \in A_0, \forall x \in A_0, x \le b<br>$$</p>
<p>$$<br>b \enspace is \enspace the \enspace maximum \enspace of \enspace A_0<br>$$</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>a \in A_0, \forall x \in A_0, x \ge a<br>$$</p>
<p>$$<br>a \enspace is \enspace the \enspace minimum \enspace of \enspace A_0<br>$$</p>
<p>主要差別會是值是否在 $A_0$ 裏面。</p>
<p>這時候就可以來定義 <strong>最小上界性（least upper bound property）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>\forall A_0 \subseteq A, A_0 \enspace has \enspace a \enspace least \enspace upper \enspace bound<br>$$</p>
<p>$$<br>A \enspace has \enspace least \enspace upper \enspace bound \enspace property.<br>$$</p>
<p>相反則是，<strong>最大下界性（greatest lower bound property）</strong>。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/03-relations/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/02-functions/">
                            Functions
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:21:18+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Function 會是在數學上常常看到的概念，但他到底是什麼？Function 常常被視為兩個集合之間<strong>對映的規則</strong>。我們先來定義<strong>對映的規則（rule of assignment）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>two \enspace sets \enspace C, D, r \subseteq C \times D, \forall c \in C , d \in D,<br>$$</p>
<p>$$<br>\exists \enspace at \enspace most \enspace one \enspace (c, d) \in r<br>$$</p>
<p>所以如果當兩個對映關係（如下）有相同的第一分量 $c$，那他們其實是同一個對映關係，並且第二分量也會相同。</p>
<p>$$<br>[ (c, d) \in r, (c, d’) \in r ] \rightarrow [ d = d’ ]<br>$$</p>
<p>給定一個對映規則 $r$，<strong>定義域（domain）</strong> 也就是 $C$ 的子集合，他包含了所有 $r$ 中的第一分量。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>domain \enspace r = \{c \mid \exists d \in D \enspace s.t. \enspace (c, d) \in r \}<br>$$</p>
<p>相對，<strong>值域（image）</strong>是 $D$ 的子集合，他包含了所有 $r$ 中的第二分量。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>image \enspace r = \{d \mid \exists c \in C \enspace s.t. \enspace (c, d) \in r \}<br>$$</p>
<p>現在我們把所有需要的東西都定義好了，那<strong>函數（function）</strong> 的定義就會是一個對映規則，以及一個 <em>set</em> $B$ 包含了 $image \enspace r$，稱為函數的 <strong>對應域（codomain）</strong> ，而函數的 <em>domain</em> $A$ 也就是 $domain \enspace r$，函數的值域就是 $image \enspace r$ ，我們會以下列表示法表示：</p>
<p>$$<br>f: A \rightarrow B<br>$$</p>
<p>這表示他是一個從 $A$ map 到 $B$ 的函數。有時候我們會想像成在空間上的轉換，將 $A$ 上的點對映到 $B$ 上的點。我們會以 $f(a)$ 來代表 $f$ 在 $a$ 點的<strong>值（value）</strong>。</p>
<p>我們可以在函數上定義<strong>限制（restriction）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A_0 \enspace is \enspace the \enspace restriction \enspace of \enspace f<br>$$</p>
<p>$$<br>f: A \rightarrow B, A_0 \subseteq A \enspace s.t. \enspace f = \{ (a, f(a)) \mid a \in A_0 \}<br>$$</p>
<p>我們可以藉由限制（restriction）來限制我們的函數形式。我們還有另外一個方法，<strong>合成函數（function composition）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>g \circ f \enspace is \enspace the \enspace composite \enspace of \enspace function \enspace f \enspace and \enspace g<br>$$</p>
<p>$$<br>f: A \rightarrow B, g: B \rightarrow C, g \circ f: A \rightarrow C, (g \circ f)(a) = g(f(a))<br>$$</p>
<p>$$<br>g \circ f = \{(a, c) \mid b \in B, f(a) = b, g(b) = c \}<br>$$</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/38/Example_for_a_composition_of_two_functions.svg" alt="Function composition"></p>
<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>接著我們來討論一些不同的函數。</p>
<p>如果一個函數 $f: A \rightarrow B$ 是<strong>單射的（injective）</strong>，或是<strong>一對一（one-to-one）</strong>，那也就是說在 $A$ 中，不同的點會對映到不同的 <strong>像（image）</strong> 的。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Injection.svg/240px-Injection.svg.png" alt="Injection"></p>
<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>如果一個函數 $f: A \rightarrow B$ 是<strong>滿射的（surjective）</strong>，或是<strong>映成（onto）</strong>，那也就是說每個在 $B$ 中的元素都有被對映到。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Surjection.svg/240px-Surjection.svg.png" alt="Surjection"></p>
<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>如果一個函數 $f: A \rightarrow B$ 是<strong>雙射的（bijective）</strong>，那也就是說這個函數同時滿足 <strong>單射的（injective）</strong> 以及 <strong>滿射的（surjective）</strong>。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Bijection.svg/240px-Bijection.svg.png" alt="Bijection"></p>
<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>兩個 injective function 的 composite 是個 injective function。兩個 surjective function 的 composite 是個 surjective function。兩個 bijective function 的 composite 是個 bijective function。</p>
<p>那如果 <em>function</em> $f$ 是 bijective，那麼他的 <strong>反函數（inverse）</strong> 存在，也就是：<br>$$<br>f: A \rightarrow B, f \enspace is \enspace bijective, \exists<br> f^{-1}<br>$$</p>
<p>$$<br>s.t. \enspace f^{-1}(b) = a, a \in A, b \in B<br>$$</p>
<p>反函數有一個特性就是， $f$ 的反函數為 $f^{-1}$，而 $f^{-1}$ 本身也是雙射的，所以他的反函數也存在，他的反函數則是 $f$。</p>
<p>那如果要證明一個函數是 bijective 的話，那以下Lemma 會有幫助：</p>
<blockquote>
<p> <strong><em>Lemma</em></strong></p>
</blockquote>
<p>$$<br>f: A \rightarrow B, \exists g: B \rightarrow A, \exists h: B \rightarrow A<br>$$</p>
<p>$$<br>s.t. \enspace \forall a \in A, g(f(a)) = a, \forall b \in B, f(h(b)) = b,<br>$$</p>
<p>$$<br>then \enspace g = h = f^{-1} \enspace is \enspace bijective.<br>$$</p>
<p><img src="/pics/bijective_function.svg" alt=""></p>
<p>接下來，我們來討論一下 <strong>像（image）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>f: A \rightarrow B, A_0 \subseteq A, the \enspace image \enspace of \enspace A_0 \enspace of \enspace f \enspace is<br>$$</p>
<p>$$<br>f(A_0) = \{ b \mid b = f(a) \enspace for \enspace at \enspace least \enspace one \enspace a \in A_0 \}<br>$$</p>
<p><img src="/pics/image.svg" alt=""></p>
<p>另一方面，我們可以討論像的 <strong>原像（preimage）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>f: A \rightarrow B, B_0 \subseteq B, f^{-1}(B_0) = \{ a \mid f(a) \in B_0\}<br>$$</p>
<p>$$<br>f^{-1}(B_0) \enspace is \enspace the \enspace preimage \enspace of \enspace B_0 \enspace under \enspace f.<br>$$</p>
<p><img src="/pics/preimage.svg" alt=""></p>
<p>如果 $f: A \rightarrow B$ 是 bijective， $B_0 \subseteq B$，我們對 $f^{-1}(B_0)$ 有兩種解釋，他可以是 preimage of $B_0$ under $f$ ，或者是 image of $B_0$ under $f^{-1}: B \rightarrow A$。</p>
<p>在使用 $f$ 及 $f^{-1}$ 上需要小心。如果是 $f^{-1}$ 應用在 $B$ 的子集合上，他有很好的行為，他保留了包含、聯集、交集、差集的特性。我們應該要常用他。如果是 $f$ 應用在 $A$ 的子集合上，他只保留了包含及聯集的特性。</p>
<p>另一個需要小心的，以下兩個並不是總是為真：</p>
<p>$$<br>f^{-1}(f(A_0)) = A_0<br>$$</p>
<p>$$<br>f(f^{-1}(B_0)) = B_0<br>$$</p>
<p>結論是這樣的，如果 $f: A \rightarrow B, A_0 \subseteq A, B_0 \subseteq B$，則以下成立：</p>
<p>$$<br>A_0 \subseteq f^{-1}(f(A_0))<br>$$</p>
<p>$$<br>f(f^{-1}(B_0)) \subseteq B_0<br>$$</p>
<p>第一條式子的等號成立的條件為 $f$ 是 injective，第二條式子的等號成立的條件為 $f$ 是 surjective。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/02-functions/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/22/01-set-theory/">
                            Set theory (集合論)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-22T00:19:48+08:00">
	
		    Jul 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Topology/">Topology</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>先以集合論開始切入，集合論是以後各門數學相關學科的根基，也就是很多數學的分支都會定義在集合論上。</p>
<p>在數學上，集合就是一群不重複的物件（object）或是元素（element）。像我們可以定義<strong>一個set A當中的elements有a、b、c</strong>，寫成：</p>
<p>$$<br>A = \{ a, b, c \}<br>$$</p>
<p>但有時候我們想表達一個set，可是卻無法將裡面的elements一一列出，像是我們定義一個只有偶數的set B，我們會寫成以下的方式：</p>
<p>$$<br>B = \{x \mid x \enspace is \enspace even \enspace integer.\}<br>$$</p>
<p>裡頭的$x$代表著一個變數，後面會描述這變數的特質，所以在這邊的描述是$x$是一個偶數，那如果我們收集這樣的變數成為一個集合，我們就有了所有偶數的集合了。</p>
<p>我們在描述<em>element</em>及<em>set</em>的關係的時候會使用<strong>屬於</strong>，<strong>一個element a屬於set A</strong>，則會表示成：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>a \in A<br>$$</p>
<p>相對，<strong>不屬於</strong>則會寫成以下的形式：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>d \notin A<br>$$</p>
<p><strong>等於</strong>的符號是會視為<em>邏輯上的相等（logical identity）</em>，如果我們說$a = b$，那麼$a$跟$b$就是兩個完全一樣的東西。如果是不一樣的東西，則寫成$a \neq b$。</p>
<p>同樣的，集合也可以同等起來，如果我們說$A = B$，就表示$A$跟$B$這兩個集合內的東西完全相同。如果有一個element不同，則$A \neq B$。</p>
<p>如果$A$有的elements，在$B$中也有，那我們會說<strong>A是B的子集合（subset）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \subseteq B<br>$$</p>
<p>從定義當中我們無法區分出$A$跟$B$是否相同。那前面講到的$A = B$也就等同於是$A \subseteq B$及$B \subseteq A$兩者都要成立。</p>
<p>那如果$A \subseteq B$且$A \neq B$，那我們稱<strong>A為B的嚴格子集（proper subset）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \subset B<br>$$</p>
<p>$\subseteq$及$\subset$關係則分別稱為<strong>包含（inclusion）</strong> 及 <strong>嚴格包含（proper inclusion）</strong>。</p>
<p>如果我們有兩個集合$A$跟$B$，如果有一個集合包含了所有$A$和$B$的元素，那我們稱它為$A$和$B$的<strong>聯集（union）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \cup B = \{x \mid x \in A \enspace or \enspace x \in B\}<br>$$</p>
<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/3/30/Venn0111.svg" alt="Union"></div>

<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>如果我們有兩個集合$A$跟$B$，如果有一個集合只包含$A$和$B$的共同元素，那我們稱它為$A$和$B$的<strong>交集（intersection）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \cap B = \{x \mid x \in A \enspace and \enspace x \in B\}<br>$$</p>
<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/9/99/Venn0001.svg" alt="Intersection"></div>

<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>如果一個集合裏面沒有任何元素，那我們定義這樣的集合為<strong>空集合（empty set）</strong>，$\emptyset$。</p>
<p>若是兩個集合沒有共同的元素，我們會說這兩個集合是<strong>互斥的（disjoint）</strong>：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \cap B = \emptyset<br>$$</p>
<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/d/df/Disjunkte_Mengen.svg" alt="Disjoint sets"></div>

<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<p>由於空集合這個概念非常簡單，就是集合內沒有任何元素，我們可以把他跟之前介紹過的概念結合起來。像是，如果我們讓 $x$ 是某個元素，</p>
<p>$$<br>x \in \emptyset<br>$$</p>
<p>是不會成立的。對於任何一個set $A$，我們有</p>
<p>$$<br>A \cap \emptyset = \emptyset<br>$$</p>
<p>和</p>
<p>$$<br>A \cup \emptyset = A<br>$$<br>。</p>
<p>包含的關係就有點微妙，像是 $\emptyset \subseteq A$ ，我們會考慮很多的實例，要讓每一個實例都成立，這個式子才算是成立。不過討論這件事本身就蠻無趣的，他基本上是成立的。</p>
<p>在這邊我們可以再定義新的運算，那就是<strong>差集（difference）</strong>，他的定義如下：</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A - B = \{x \mid x \in A \enspace and \enspace x \notin B\}<br>$$</p>
<div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/5/5a/Venn0010.svg" alt="Difference set"></div>

<blockquote>
<p> <small>from Wikipedia</small></p>
</blockquote>
<hr>
<h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>在集合論中，有些跟我們一般的算術運算很像的性質，像是以下的<strong>分配律（distributive law）</strong>：</p>
<p>$$<br>A \cap (B \cup C) = (A \cap B) \cup (A \cap C)<br>$$</p>
<p>$$<br>A \cup (B \cap C) = (A \cup B) \cap (A \cup C)<br>$$</p>
<p>以及<strong>狄莫根定律（DeMorgan ‘s laws）</strong>：</p>
<p>$$<br>A - (B \cap C) = (A - B) \cup (A - C)<br>$$</p>
<p>$$<br>A - (B \cup C) = (A - B) \cap (A - C)<br>$$</p>
<hr>
<p>我們在緊接著介紹一個有趣的概念，<strong>冪集（power set）</strong>，<strong>$A$的冪集（$\mathcal{P}(A)$）是指所有$A$的子集的所有排列組合所成的集合</strong>，像是假設$A = \{1, 2, 3\}$，那麼$\mathcal{P}(A) = \{ \emptyset, \{1\}, \{2\}, \{3\}, \{1, 2\}, \{1, 3\}, \{2, 3\}, \{1, 2, 3\} \}$。</p>
<p>往後，當我們在描述一個 <em>set</em>，他的 <em>element</em> 也是 <em>set</em> 的時候，我們會稱他為 <em>collection of sets</em>，並且會以書寫體$\mathcal{A}$、$\mathcal{B}$表示，以示區別。</p>
<p>我們已經定義了任兩個集合的交集跟聯集。那如果我們想要聯集或是交集任意多數量的集合，$\mathcal{A}$為一 <em>collection of sets</em>，我們可以用以下表示法：</p>
<p>$$<br>\bigcup_{A \in \mathcal{A}} A = \{ x \mid x \in A, for \enspace at \enspace least \enspace one \enspace A \in \mathcal{A} \}<br>$$</p>
<p>直白的說，就是這個聯集會將在$\mathcal{A}$中，至少出現過一次的$A$，將$A$中的元素$x$都蒐集起來。</p>
<p>$$<br>\bigcap_{A \in \mathcal{A}} A = \{ x \mid x \in A, for \enspace every \enspace A \in \mathcal{A} \}<br>$$</p>
<p>這個交集則是會將在$\mathcal{A}$中，每個$A$，將$A$中都出現的元素$x$蒐集起來。</p>
<p>這些定義都沒什麼大問題。不過當$\mathcal{A}$是個空的 <em>collection</em> 的時候就會顯的比較特別，根據字面定義，這個情況下沒有任何人可以符合這樣的定義，所以我們可以說：</p>
<p>$$<br>\bigcup_{A \in \mathcal{A}} A = \emptyset<br>$$</p>
<p>接下來我們來定義一個重要的東西，<strong>笛卡爾積（Cartesian product）</strong>，數學上常常會用這樣的概念來為其他概念下定義，例如空間上的座標位置。</p>
<blockquote>
<p> <strong><em>Def.</em></strong></p>
</blockquote>
<p>$$<br>A \times B = \{(a, b) \mid a \in A \enspace and \enspace b \in B\}<br>$$</p>
<p>像是當 $A = \{ a, b, c\}$， $B = \{1, 2\}$，那麼 $A \times B = \{(a, 1), (a, 2), (b, 1), (b, 2), (c, 1), (c, 2)\}$ 。</p>
<p>這在概念上非常直覺，可以把他想成是在 <em>set</em> $A$ 中的元素跟在 <em>set</em> $B$ 中的元素，拿出來一一做排列組合，所有的排列組合所成的集合就是 $A \times B$。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/22/01-set-theory/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2018/07/21/04-reference/">
                            Reference commands
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-07-21T22:59:51+08:00">
	
		    Jul 21, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Docker/">Docker</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <pre><code>attach    Attach to a running container
build     Build an image from a Dockerfile
commit    Create a new image from a container&apos;s changes
cp        Copy files/folders from the containers filesystem to the host path
diff      Inspect changes on a container&apos;s filesystem
events    Get real time events from the server
export    Stream the contents of a container as a tar archive
history   Show the history of an image
images    List images
import    Create a new filesystem image from the contents of a tarball
info      Display system-wide information
inspect   Return low-level information on a container
kill      Kill a running container
load      Load an image from a tar archive
login     Register or Login to the docker registry server
logs      Fetch the logs of a container
port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT
pause     Pause all processes within a container
ps        List containers
pull      Pull an image or a repository from the docker registry server
push      Push an image or a repository to the docker registry server
restart   Restart a running container
rm        Remove one or more containers
rmi       Remove one or more images
run       Run a command in a new container
save      Save an image to a tar archive
search    Search for an image in the docker index
start     Start a stopped container
stop      Stop a running container
tag       Tag an image into a repository
top       Lookup the running processes of a container
unpause   Unpause a paused container
version   Show the docker version information
wait      Block until a container stops, then print its exit code
</code></pre><h2 id="Docker-Commands-Diagram"><a href="#Docker-Commands-Diagram" class="headerlink" title="Docker Commands Diagram"></a><strong>Docker Commands Diagram</strong></h2><p><img src="https://raw.githubusercontent.com/philipz/docker_practice/master/_images/cmd_logic.png" alt="Docker Commands Diagram"></p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/07/21/04-reference/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/2018/07/page/2/">
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Yueh-Hua Tu. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <h4 id="about-card-name">Yueh-Hua Tu</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Research assistant, Taiwan CDC</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Taiwan
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-xzfezjobyekpxrjktw5tz6muvzqfsbmo5n6atk3p5om9ulfptldi3p7cyqd8.min.js"></script>
<!--SCRIPTS END-->



    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
