<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Maker</title>
  
  <subtitle>Love Math, Science, Biology, Computer science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuehhua.github.io/"/>
  <updated>2021-01-14T03:50:26.514Z</updated>
  <id>https://yuehhua.github.io/</id>
  
  <author>
    <name>Yueh-Hua Tu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Julia冷知識-你知道模組中的程式碼是何時被執行的嗎</title>
    <link href="https://yuehhua.github.io/2021/01/14/julia-module-code-loading/"/>
    <id>https://yuehhua.github.io/2021/01/14/julia-module-code-loading/</id>
    <published>2021-01-14T03:50:26.000Z</published>
    <updated>2021-01-14T03:50:26.514Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Some code here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> __init__()</span><br><span class="line">    <span class="comment"># Some code here too</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>是否曾經疑惑過寫在 module 中的程式碼會在何時被載入呢？</p><a id="more"></a><p>事實上，解答如下囉！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Foo</span><br><span class="line"></span><br><span class="line">println(<span class="string">"code here will be printed when you build this module"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> __init__()</span><br><span class="line">    println(<span class="string">"code here will be printed when you using this module"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; Foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Some code here&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; __init__()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# Some code here too&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;是否曾經疑惑過寫在 module 中的程式碼會在何時被載入呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>依函式分派（dispatch on function）</title>
    <link href="https://yuehhua.github.io/2021/01/09/dispatch-on-function/"/>
    <id>https://yuehhua.github.io/2021/01/09/dispatch-on-function/</id>
    <published>2021-01-09T03:51:45.000Z</published>
    <updated>2021-01-09T03:52:59.820Z</updated>
    
    <content type="html"><![CDATA[<p>依函式分派（dispatch on function）算是在 Julia 語言中相當常見的一個技巧，它依賴 Julia 的多重分派機制（multiple dispatch），可以依據不同的函式有不一樣的行為。</p><h2 id="舉例">舉例</h2><p>在資料分析或是資料庫分析中，常常會需要對資料欄位進行聚合運算，像是加總的 <code>sum</code>、平均的 <code>avg</code> 或是計數的 <code>count</code>。他們都是用同一個欄位的資料，聚合成一個值輸出。當我們需要將資料相加時，我們會寫出以下的程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">sum(a)</span><br></pre></td></tr></table></figure><p>這看起來很直觀，但往往在資料庫的設計當中，只會設計一些常用到的聚合函式（aggregate function）。</p><p>那麼有沒有一個方式可以得到一個比較廣義的聚合函式呢？</p><a id="more"></a><p>假設我們想要定一個函式叫作 <code>aggregate</code>，其實 <code>sum</code> 就是利用加法（<code>+</code>）來做聚合，所以我們可以寫成這樣：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> aggregate(op, data)</span><br><span class="line">    y = data[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>:length(data)</span><br><span class="line">        y = op(y, data[i])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，下面兩者的結果會一樣。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aggregate(+, a) == sum(a)</span><br></pre></td></tr></table></figure><p>那如果我們需要一個將所有資料相乘（<code>*</code>）的聚合方式，那我們只需要改寫成以下的方式。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aggregate(*, a) == prod(a)</span><br></pre></td></tr></table></figure><p>這樣感覺超棒的！</p><p>不過這是一般函數式程式設計的寫法，這跟 <code>reduce(*, data)</code> 沒什麼兩樣。</p><h2 id="用分派來處理特例">用分派來處理特例</h2><p>接著，再來實作一個簡單的 <code>aggregate(count, data)</code>，如果你直接呼叫 <code>aggregate(count, a)</code> 是會出錯的。</p><p>然而 <code>count</code> 的計算其實是需要重新實作的，所以就不能再走上面的方式了。</p><p>要依據參數的不同，執行不同的方法就是多型（polymorphism）的真諦。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> aggregate(op::typeof(count), data)</span><br><span class="line">    y = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">2</span>:length(data)</span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>或是直接取資料的長度也可以。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aggregate(op::typeof(count), data) = length(data)</span><br></pre></td></tr></table></figure><h2 id="統計常用函式">統計常用函式</h2><p>這時候如果我們要實作的是一些統計上常用的函式，像是平均、中位數或眾數，就遇到困難了。這邊示範平均的聚合函式，如果像以下的方式寫會發生錯誤：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aggregate(mean, a) != mean(a)</span><br></pre></td></tr></table></figure><p>因為在這樣的計算之下，它會變成第一項先跟第二項取平均，再跟第三項取平均，再跟第四項取平均，以此類推。</p><p>這時候就要將 <code>mean</code> 的實作分開定義。</p><p>由於 <code>mean</code> 的行為可以想成是先將資料加總，然後除以資料的數量，所以我們可以計算 <code>aggregate(+, data)</code> 及 <code>aggregate(count, data)</code>，並且將他們兩者相除。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> aggregate(op::typeof(mean), data)</span><br><span class="line">    aggregate(+, data) / aggregate(count, data)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以依據不同的函式名稱來做分派了！</p><h2 id="原理">原理</h2><p>由於在 Julia 中萬物都是物件，即使是函式也如同物件一樣是有型別的，可以取 <code>typeof</code>，而函式 <code>foo</code> 的型別就是 <code>typeof(foo)</code>。</p><p>因此，可以將函式 <code>foo</code> 視為實體，函式型別 <code>typeof(foo)</code> 視為型別。</p><p>利用一般的多重分派就可以達成 <code>aggregate(op::typeof(mean), data)</code> 囉！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依函式分派（dispatch on function）算是在 Julia 語言中相當常見的一個技巧，它依賴 Julia 的多重分派機制（multiple dispatch），可以依據不同的函式有不一樣的行為。&lt;/p&gt;
&lt;h2 id=&quot;舉例&quot;&gt;舉例&lt;/h2&gt;
&lt;p&gt;在資料分析或是資料庫分析中，常常會需要對資料欄位進行聚合運算，像是加總的 &lt;code&gt;sum&lt;/code&gt;、平均的 &lt;code&gt;avg&lt;/code&gt; 或是計數的 &lt;code&gt;count&lt;/code&gt;。他們都是用同一個欄位的資料，聚合成一個值輸出。當我們需要將資料相加時，我們會寫出以下的程式碼：&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sum(a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;這看起來很直觀，但往往在資料庫的設計當中，只會設計一些常用到的聚合函式（aggregate function）。&lt;/p&gt;
&lt;p&gt;那麼有沒有一個方式可以得到一個比較廣義的聚合函式呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>依型別分派（dispatch on types）</title>
    <link href="https://yuehhua.github.io/2021/01/07/dispatch-on-types/"/>
    <id>https://yuehhua.github.io/2021/01/07/dispatch-on-types/</id>
    <published>2021-01-07T15:43:49.000Z</published>
    <updated>2021-01-10T17:35:32.416Z</updated>
    
    <content type="html"><![CDATA[<p>依型別分派（dispatch on types）算是在 Julia 語言中相當常見的一個技巧，它依賴 Julia 的多重分派機制（multiple dispatch），可以依據不同的型別有不一樣的行為。</p><p>依據不同的型別有不同的行為，而不是實體。直觀上看起來會有點像傳統物件導向當中的 class method，不過在 Julia 當中還有更多用途。</p><a id="more"></a><h2 id="Convert">Convert</h2><p>在 Julia 的 Base 中有許多應用到這樣技巧的例子，這邊就舉 <code>convert</code> 為例。</p><p><code>convert</code> 是一個轉換函式，它可以將特定物件轉換成特定的型別，所以物件跟型別就分別是它的參數。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(<span class="built_in">Char</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這樣可以將 <code>10</code> 轉換成一個字元的型別，就會變成 <code>'\n'</code>。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert(<span class="built_in">Array</span>&#123;<span class="built_in">Float64</span>&#125;, <span class="built_in">Any</span>[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>或是一個將裝有 <code>Any</code> 型別元素的矩陣，轉成 <code>Float64</code> 型別元素的矩陣。</p><p>以上的實作大概會類似：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> convert(T::<span class="built_in">Type</span>&#123;<span class="built_in">Char</span>&#125;, val)</span><br><span class="line">    T(val)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>基本上會試圖呼叫該型別的建構子，而第一個參數上也會加上 <code>Type{...}</code> 的型別。</p><h2 id="Read">Read</h2><p>或是我們也可以在讀取二進制資料當中發現這樣的模式。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io = <span class="built_in">IOBuffer</span>(<span class="string">"JuliaLang is the best."</span>)</span><br><span class="line">read(io, <span class="built_in">Char</span>)</span><br></pre></td></tr></table></figure><p>在讀取 <code>IOBuffer</code> 的二進制資料當中，可以將資料解析成 <code>Char</code> 的型別。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(io, <span class="built_in">String</span>)</span><br></pre></td></tr></table></figure><p>或是解析成 <code>String</code> 的型別。</p><p>在這邊我們看到的都是將型別作為參數給進函式中，函式可以藉由得到的型別做不同的事情。</p><p>其中一個目的是依據型別做分派（dispatch），也就是不同的型別會對應到不同的方法實作上。</p><p><code>read(io, Char)</code> 跟 <code>read(io, String)</code> 的實作方式是截然不同的，畢竟要解析成不同的型別，方法會是不同的。</p><p>也有可能會像是 <code>convert</code> 一樣，再度利用給進來的參數。由於 Julia 的型別本身也是一個物件，呼叫型別本身也等同於呼叫型別的建構子，所以我們可以看到在 <code>convert(T::Type{Char}, val)</code> 中，呼叫 <code>T</code> 作為建構子的方式來轉換物件的型別。</p><h2 id="用在哪裡？">用在哪裡？</h2><p>這樣的技術可以被用在哪些場景呢？</p><p>通常需要傳型別到其它函式，可以用來呼叫其建構子，而函式則提供一個統一的介面，可以適用於創造物件的場景。</p><p>以下就來示範有不同種飲料被製作出來的過程吧！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> Beverage <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> MilkTea &lt;: Beverage <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> GreenTea &lt;: Beverage <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> BlackTea &lt;: Beverage <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract type</span> Topping <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TapiocaBall &lt;: Topping <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Pudding &lt;: Topping <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BubbleMilkTea &lt;: Beverage <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> PuddingMilkTea &lt;: Beverage <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> BubbleGreenTea &lt;: Beverage <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> BubbleBlackTea &lt;: Beverage <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊定義了奶茶、綠茶及紅茶幾種飲料，然後還可以對飲料加料，加料之後的飲料就會變成其他種的飲料。</p><p>接下來就可以來決定加什麼料會變成什麼樣的飲料。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mix(::<span class="built_in">Type</span>&#123;MilkTea&#125;, ::<span class="built_in">Type</span>&#123;TapiocaBall&#125;) = BubbleMilkTea()</span><br></pre></td></tr></table></figure><p>像是把奶茶跟波霸加在一起，就變成了波霸奶茶。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mix(::<span class="built_in">Type</span>&#123;MilkTea&#125;, ::<span class="built_in">Type</span>&#123;Pudding&#125;) = PuddingMilkTea()</span><br></pre></td></tr></table></figure><p>如果把奶茶跟布丁加在一起就變成布丁奶茶囉~~</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mix(::<span class="built_in">Type</span>&#123;GreenTea&#125;, ::<span class="built_in">Type</span>&#123;TapiocaBall&#125;) = BubbleGreenTea()</span><br><span class="line">mix(::<span class="built_in">Type</span>&#123;BlackTea&#125;, ::<span class="built_in">Type</span>&#123;TapiocaBall&#125;) = BubbleBlackTea()</span><br></pre></td></tr></table></figure><p>我們還有賣波霸綠茶跟波霸紅茶喔！</p><p>但是有些組合沒有在菜單上，因為老闆覺得沒有在菜單上的組合喝起來很噁心，所以不打算提供，像是布丁加綠茶這種組合。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; mix(GreenTea, Pudding)</span><br><span class="line">ERROR: <span class="built_in">MethodError</span>: no method matching mix(::<span class="built_in">Type</span>&#123;GreenTea&#125;, ::<span class="built_in">Type</span>&#123;Pudding&#125;)</span><br><span class="line">Closest candidates are:</span><br><span class="line">  mix(::<span class="built_in">Type</span>&#123;MilkTea&#125;, ::<span class="built_in">Type</span>&#123;Pudding&#125;) at REPL[<span class="number">13</span>]:<span class="number">1</span></span><br><span class="line">  mix(::<span class="built_in">Type</span>&#123;GreenTea&#125;, ::<span class="built_in">Type</span>&#123;TapiocaBall&#125;) at REPL[<span class="number">14</span>]:<span class="number">1</span></span><br></pre></td></tr></table></figure><p>在這邊 <code>mix</code> 就提供了一個統一的介面來混合飲料跟加料的部份。</p><p>提供這樣單一的物件創造介面就類似於物件導向中的 factory method pattern。</p><h2 id="總結">總結</h2><p>我們可以發現到使用多重分派所帶來的一些好處。如果是在單一分派（single dispatch），也就是一般物件導向的語言中，他只能依據第一個參數做分派。然而，多重分派就可以考慮參數型別的排列組合去做分派，當然參數是型別也是可行的。</p><p>類似這樣的機制，也可以對應到在物件導向中的 strategy pattern，strategy pattern 是根據不同的演算法種類來做分派的，我們可以寫成像這樣：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(BubbleSort, xs)</span><br><span class="line">sort(Heapsort, xs)</span><br></pre></td></tr></table></figure><p>如此一來，就是一個完整的 strategy pattern 了。</p><p>最後，這邊介紹了如何利用多重分派的機制，來依據不同的型別做分派，並且做到不同的應用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依型別分派（dispatch on types）算是在 Julia 語言中相當常見的一個技巧，它依賴 Julia 的多重分派機制（multiple dispatch），可以依據不同的型別有不一樣的行為。&lt;/p&gt;
&lt;p&gt;依據不同的型別有不同的行為，而不是實體。直觀上看起來會有點像傳統物件導向當中的 class method，不過在 Julia 當中還有更多用途。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 取得目前的 random seed</title>
    <link href="https://yuehhua.github.io/2020/11/09/get-random-seed-in-julia/"/>
    <id>https://yuehhua.github.io/2020/11/09/get-random-seed-in-julia/</id>
    <published>2020-11-09T15:52:17.000Z</published>
    <updated>2020-11-09T15:54:19.011Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Random</span><br><span class="line">Random.default_rng()</span><br></pre></td></tr></table></figure><p>Ref. <a href="https://discourse.julialang.org/t/how-to-get-the-current-random-seed/31640/3" target="_blank" rel="noopener">How to get the current “random” seed?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>如何在 VS code 上設定 Julia</title>
    <link href="https://yuehhua.github.io/2020/10/31/vscode-with-julia/"/>
    <id>https://yuehhua.github.io/2020/10/31/vscode-with-julia/</id>
    <published>2020-10-31T14:52:57.000Z</published>
    <updated>2020-10-31T14:52:57.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安裝-Julia">安裝 Julia</h2><p>首先先確保電腦上已經有安裝 Julia 語言，沒有安裝的話可以到<a href="https://julialang.org/downloads/" target="_blank" rel="noopener">官網</a>下載安裝。</p><h2 id="設定環境變數">設定環境變數</h2><p>在 Windows 環境下要將 Julia 的執行檔位置設定到環境變數 PATH 下，可以參考<a href="https://julialang.org/downloads/platform/#adding_julia_to_path_on_windows_10" target="_blank" rel="noopener">這邊</a>。一般執行檔的路徑會在 <code>C:\Users\你的使用者帳號\AppData\Local\Programs\Julia 1.5.2\bin</code> 下。</p><p>我自己是 Linux 系統，所以我會建立一個捷徑到 <code>/usr/bin</code> 下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/julia-1.5.2/bin/julia /usr/bin/</span><br></pre></td></tr></table></figure><h2 id="在-VS-code-上安裝-extensions">在 VS code 上安裝 extensions</h2><p>正式進到安裝 VS code extensions 的環節了。主要要安裝的是這個 Julia language support。</p><p><img src="/images/julia-ext.png" alt=""></p><p>然後這個 Markdown Julia 可以幫你在 Julia 程式碼含有 markdown 的地方標色。</p><p><img src="/images/julia-markdown.png" alt=""></p><p>Julia Formatter 可以幫你的程式碼變整齊漂亮。</p><p><img src="/images/julia-formatter.png" alt=""></p><p>裝完之後應該是可以用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安裝-Julia&quot;&gt;安裝 Julia&lt;/h2&gt;
&lt;p&gt;首先先確保電腦上已經有安裝 Julia 語言，沒有安裝的話可以到&lt;a href=&quot;https://julialang.org/downloads/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 使用多執行緒跑平行運算 - threads 及 lock 的使用</title>
    <link href="https://yuehhua.github.io/2020/10/19/use-threads-lock-in-julia/"/>
    <id>https://yuehhua.github.io/2020/10/19/use-threads-lock-in-julia/</id>
    <published>2020-10-19T02:27:25.000Z</published>
    <updated>2020-10-19T02:34:12.711Z</updated>
    
    <content type="html"><![CDATA[<p>基本上在 Julia 上跑多執行緒不太困難，在環境中先設定好執行緒的數量，或是在執行 Julia 時增加執行緒數目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">julia --threads 4</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果既有的程式碼是 for 迴圈，基本上不難改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Threads.@threads for i &#x3D; 1:1000_000</span><br><span class="line">    do something()</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>但是終究會遇到要存取同一個物件的時候，這個時候就會有 race condition。</p><p>要避免 race condition 的方式就是使用 lock。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">results = []</span><br><span class="line">splock = Threads.SpinLock()</span><br><span class="line"></span><br><span class="line">Threads.<span class="meta">@threads</span> <span class="keyword">for</span> i = <span class="number">1</span>:<span class="number">1000_000</span></span><br><span class="line">    y = do_something()</span><br><span class="line"></span><br><span class="line">    lock(splock)</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">        push!(results, y)</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">        unlock(splock)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在迴圈中計算 <code>do_something</code>，我們想要把計算結果儲存下來，我們將他儲存在 <code>results</code> 中。<br>這時候我們必須用一個 lock 來把要存取的資源鎖住，一開始會產生一個 <code>SpinLock</code>，當程式執行到 <code>lock(splock)</code> 的時候，如果這個 lock 可以被取用，那這個執行緒就會拿這個 lock 並且進到後續的程式區塊中。如果前面有人拿了 lock，那目前這個想拿 lock 的執行緒就得等到 lock 被釋放才可以。<br>當程式執行完，<code>unlock(splock)</code> 會將 lock 給釋放掉，這個時候其他的執行緒就可以拿這個 lock 進到程式區塊中。<br>如此可以保證每次操作 <code>results</code> 物件的只能有一個執行緒，可以避免 race condition。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本上在 Julia 上跑多執行緒不太困難，在環境中先設定好執行緒的數量，或是在執行 Julia 時增加執行緒數目。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;julia --threads 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 對設定物件欄位增加檢查 - setproperty 與 setfield</title>
    <link href="https://yuehhua.github.io/2020/10/12/julia-setproperty-setfield/"/>
    <id>https://yuehhua.github.io/2020/10/12/julia-setproperty-setfield/</id>
    <published>2020-10-12T03:50:07.000Z</published>
    <updated>2020-10-12T03:52:42.354Z</updated>
    
    <content type="html"><![CDATA[<p>在 Julia 中存取物件的欄位的時候，設計者會想要對於存取的過程中加上一些檢查，這個想法是來自於傳統物件導向 getter/setter 的概念。</p><p>例如，在自己設計的物件當中有兩個矩陣，這兩個矩陣可以讓使用者隨意更新，但是需要保證這兩個矩陣的維度是一致的。這個時候就需要在使用者更新矩陣的時候加入檢查，以確保兩個矩陣之間的維度是一致的，如果檢查不通過，可能會跳例外或者是不讓矩陣被更新。</p><a id="more"></a><p>那如果要在 Julia 中，存取物件時加入檢查的程式碼，要怎麼辦呢？</p><p>Julia 提供了兩個 setter 來提供設定物件的欄位：<code>setproperty!</code> 跟 <code>setfield!</code></p><p><code>setfield!</code> 是屬於內部的 API，這個不能覆寫，所以我們要用的是 <code>setproperty!</code>。</p><p><code>setproperty!</code> 的 API 可以藉由查詢文件得知：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setproperty!(value, name::<span class="built_in">Symbol</span>, x)</span><br></pre></td></tr></table></figure><p>也就是當你在呼叫 <code>a.b = c</code> 其實就會去呼叫 <code>setproperty!(a, :b, c)</code>。</p><p>依據上述的例子，我們可以示範以下程式碼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mutable struct Foo</span><br><span class="line">    A::Matrix</span><br><span class="line">    B::Matrix</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function setproperty!(obj::Foo, name::Symbol, x)</span><br><span class="line">    if name &#x3D;&#x3D; :A</span><br><span class="line">        if size(obj.B) &#x3D;&#x3D; size(x)</span><br><span class="line">            setfield!(obj, name, x)</span><br><span class="line">        else</span><br><span class="line">            throw(DimensionMismatch())</span><br><span class="line">        end</span><br><span class="line">    elseif name &#x3D;&#x3D; :B</span><br><span class="line">        if size(obj.A) &#x3D;&#x3D; size(x)</span><br><span class="line">            setfield!(obj, name, x)</span><br><span class="line">        else</span><br><span class="line">            throw(DimensionMismatch())</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        setfield!(obj, name, x)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>這邊有幾點需要特別注意，第一是語言中的 <code>setproperty!</code> 第一個參數是 <code>Any</code> 型別，所以第一個參數一定要指定自己的型別是什麼，不然會跟語言本身的衝突。</p><p>第二個參數吃進來的是 <code>Symbol</code> 型別，這個也要指定，不然會發生 ambiguous 的狀況。</p><p>第三個參數為了廣義，所以是 <code>Any</code> 型別。</p><p>函式裡頭要區分開不同的欄位，這邊用 if-else 處理。想要用多重分派的機制處理的也是可以，但會比較麻煩，而且用到 <code>Val()</code> 會有效能降低的現象。</p><p>通過檢查後，要真正設定物件欄位，這邊用 <code>setfield!(obj, name, x)</code> 是比較好的作法。如果呼叫 <code>obj.A = x</code>，則會去呼叫 <code>setproperty!(obj, :A, x)</code>，就會變成無限遞迴呼叫了，所以 <code>=</code> 跟 <code>setproperty!</code> 在這邊都沒辦法用。</p><p>最後，我們把要檢查的欄位都處理好之後，我們不想要動到其他的欄位設定的行為，那就讓其他的欄位都用 <code>setfield!(obj, name, x)</code> 處理掉吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Julia 中存取物件的欄位的時候，設計者會想要對於存取的過程中加上一些檢查，這個想法是來自於傳統物件導向 getter/setter 的概念。&lt;/p&gt;
&lt;p&gt;例如，在自己設計的物件當中有兩個矩陣，這兩個矩陣可以讓使用者隨意更新，但是需要保證這兩個矩陣的維度是一致的。這個時候就需要在使用者更新矩陣的時候加入檢查，以確保兩個矩陣之間的維度是一致的，如果檢查不通過，可能會跳例外或者是不讓矩陣被更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Linear Regression with Maximum Likelihood Estimation</title>
    <link href="https://yuehhua.github.io/2020/10/12/linear-regression-with-mle/"/>
    <id>https://yuehhua.github.io/2020/10/12/linear-regression-with-mle/</id>
    <published>2020-10-11T17:20:57.000Z</published>
    <updated>2020-10-12T08:39:03.657Z</updated>
    
    <content type="html"><![CDATA[<p>Maximum likelihood estimation is an essential approach to estimate parameters in statistics. It requires statistical assumptions on error pattern. I will introduce this technique with really simple statistical model - linear regression.</p><a id="more"></a><p>We usually want to infer the relationship between input and output. They can be cause and effect of a physical phenomena or some indirect relationship in social science. We always want to realize the truth about our interest. Statistical tools are the tools to help you. The relationship between input and output are formulated as a mathematical function as follow:</p><p>$$<br>y = f(x)<br>$$</p><p>A linear model is assumed in linear regression. The relationship between $x$ and $y$ is assumed to be linear and $w$ and $b$ are introduced as unknown parameters into the model. $w$ denotes the extent of $x$ contributing to $y$ while $b$ denotes an inherent bias in $y$.</p><p>$$<br>y = wx + b<br>$$</p><p>On the other side, data are collected in pair of $(x^i, y^i)$. The superscript $n$ denotes the index for each sample.</p><p>$$<br>\mathcal{D} = {(x^1, y^1), (x^2, y^2), \cdots, (x^n, y^n)}<br>$$</p><p>The maximum likelihood estimation starts from the likelihood function. A likelihood function quantified the likelihood of data generation from the model we specified. That is, how likely the sample $(x_i, y_i)$ are generated from the model. All parameters are reduced into $\theta$. Precisely, $\mathcal{L}(\theta \mid \mathcal{D})$ represents the likelihood of model with parameter $\theta$ given data $\mathcal{D}$. Notably, data is fixed here. Thus, we want the most likely model that fits our samples. The model with maximum likelihood is estimated.</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= f(\mathcal{D} \mid \theta) \\<br>&amp;= p((x^1, y^1), (x^2, y^2), \cdots, (x^n, y^n) \mid \theta)<br>\end{aligned}<br>$$</p><p>A probability distribution is used to estimate the likelihood of model $\theta$. The interpretation here is the probability of data generation from the model $\theta$.</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= p((x^1, y^1), (x^2, y^2), \cdots, (x^n, y^n) \mid \theta) \\<br>&amp;= p((x^1, y^1) \mid \theta) \cdot p((x^2, y^2) \mid \theta) \cdots p((x^n, y^n) \mid \theta)<br>\end{aligned}<br>$$</p><p>It is formed from the joint probability distributions. A critical statistical assumption is introduced here. Samples $(x^i, y^i)$ are generated <em>independently</em> such that the joint probability can be split into multiplication of probabilities. Further, samples are generated from the same population/model $\theta$. So, we call that data are <em>independently, identically distributed</em>, or <em>iid</em>, generated from some model.</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= p((x^1, y^1) \mid \theta) \cdot p((x^2, y^2) \mid \theta) \cdots p((x^n, y^n) \mid \theta) \\<br>&amp;= \prod_{i=1}^n p((x^i, y^i) \mid \theta)<br>\end{aligned}<br>$$</p><p>Normal distribution is used as error pattern in linear regression model. A linear regression model always infers the mean value of $y$ given $x$. The uncertainty of $y$ can be described by normal distribution. We add an error term after the linear regression model.</p><p>$$<br>y = wx + b + \epsilon<br>$$</p><p>$$<br>\epsilon = y - wx - b = \mathcal{N}(z \mid \mu = 0, \sigma^2)<br>$$</p><p>Or we can rewrite it into</p><p>$$<br>\epsilon = \mathcal{N}(y - wx - b \mid \mu = 0, \sigma^2)<br>$$</p><p>where $\mathcal{N}(x \mid \mu, \sigma^2) = \frac{1}{\sigma \sqrt{2 \pi}} exp(-\frac{1}{2} (\frac{x-\mu}{\sigma})^2)$.</p><p>Likelihood function would be</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= \prod_{i=1}^n p((x^i, y^i) \mid \theta) \\<br>&amp;= \prod_{i=1}^n \mathcal{N}(y^i - wx^i - b \mid \mu = 0, \sigma^2)<br>\end{aligned}<br>$$.</p><p>Negative log likelihood would be</p><p>$$<br>\begin{aligned}<br>\mathcal{l}(\theta \mid \mathcal{D}) &amp;= - ln \mathcal{L}(\theta \mid \mathcal{D}) \\<br>&amp;= - ln \prod_{i=1}^n \mathcal{N}(y^i - wx^i - b \mid \mu = 0, \sigma^2) \\<br>&amp;= - \sum_{i=1}^n ln \mathcal{N}(y^i - wx^i - b \mid \mu = 0, \sigma^2) \\<br>&amp;= - \sum_{i=1}^n - \frac{1}{2} (\frac{y^i - wx^i - b - 0}{\sigma})^2 - ln(\sigma \sqrt{2 \pi}) \\<br>&amp;= \sum_{i=1}^n \frac{1}{2} (\frac{y^i - wx^i - b}{\sigma})^2 + ln(\sigma) + ln(\sqrt{2 \pi})<br>\end{aligned}<br>$$</p><p>The primal goal is to maximize likelihood function $\arg\max_{\theta} \mathcal{L}(\theta \mid \mathcal{D})$, while we have to minimize the negative log likelihood (NLL) function</p><p>$$<br>\arg\min_{\theta} \mathcal{l}(\theta \mid \mathcal{D})<br>$$.</p><p>To solve this problem, we need to calculate the first-order derivative of NLL. The minimum value happens while $\frac{\partial \mathcal{l}}{\partial w} = 0$ and $\frac{\partial \mathcal{l}}{\partial b} = 0$ are satisfied.</p><p>$$<br>\begin{aligned}<br>\frac{\partial \mathcal{l}}{\partial w} &amp;= \frac{\partial}{\partial w} \sum_{i=1}^n \frac{1}{2} (\frac{y^i - wx^i - b}{\sigma})^2 + ln(\sigma) + ln(\sqrt{2 \pi}) \\<br>&amp;= \sum_{i=1}^n \frac{y^i - wx^i - b}{\sigma} \cdot \frac{\partial}{\partial w} \frac{y^i - wx^i - b}{\sigma} \\<br>&amp;= \sum_{i=1}^n \frac{y^i - wx^i - b}{\sigma} \frac{-x^i}{\sigma} \\<br>&amp;= \frac{-1}{\sigma^2} \sum_{i=1}^n x^i (y^i - wx^i - b) \\<br>&amp;= 0<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>\frac{-1}{\sigma^2} \sum_{i=1}^n x^i (y^i - wx^i - b) &amp;= 0 \\<br>\sum_{i=1}^n x^i (y^i - wx^i - b) &amp;= 0 \\<br>\sum_{i=1}^n{x^i y^i} - w \sum_{i=1}^n{(x^i)^2} - b \sum_{i=1}^n{x^i} &amp;= 0<br>\end{aligned}<br>$$</p><p>The same way we can have</p><p>$$<br>\sum_{i=1}^n{y^i} - w \sum_{i=1}^n{x^i} - b = 0<br>$$</p><p>derived from $\frac{\partial \mathcal{l}}{\partial b} = 0$.</p><p>Finally, we can estimate the parameters from the following two equations:</p><p>$$<br>\begin{cases}<br>(\sum_{i=1}^n{(x^i)^2}) w + (\sum_{i=1}^n{x^i}) b = \sum_{i=1}^n{x^i y^i} \\<br>(\sum_{i=1}^n{x^i}) w + b = \sum_{i=1}^n{y^i}<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>w = ? \\<br>b = ?<br>\end{cases}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maximum likelihood estimation is an essential approach to estimate parameters in statistics. It requires statistical assumptions on error pattern. I will introduce this technique with really simple statistical model - linear regression.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>從分享到建議</title>
    <link href="https://yuehhua.github.io/2020/10/12/from-sharing-to-suggestions/"/>
    <id>https://yuehhua.github.io/2020/10/12/from-sharing-to-suggestions/</id>
    <published>2020-10-11T16:29:36.000Z</published>
    <updated>2020-10-11T16:34:30.496Z</updated>
    
    <content type="html"><![CDATA[<p>這幾年，隨著接觸的東西變多，知道的東西變多，個性上也有點變化。</p><p>約莫四五年前，碩班時期接觸到一些很棒的網路技術文章，當時線上課程也非常熱門，很多優秀的大學紛紛把他們的上課內容做成教材釋出。也因為這樣，我自己其實從這些網路資源受惠非常多。當時也是自己在發展自學能力的輝煌時期。</p><a id="more"></a><p>也因為接觸開源文化，所以對於「分享」很有憧憬。覺得能夠分享自己的經驗的人很厲害，除了自己有些東西可以告訴別人，也有這個意願跟熱忱可以將自己所學回饋給社會的感覺。</p><p>後來畢業之後在研發替代役的過程中，一邊練習自己的溝通跟演講技術，一邊弄社群跟開一些小型的短期課程，還成為工研院的機器學習講師。過程當中也很開心可以真正可以把自己身上的東西跟大家分享，有的學員是私下來問我的看法或是建議。</p><p>漸漸地，隨著接觸的東西跟知道的東西變多，會開始知道有些作法或是想法上是有瑕疵或是問題的。一部份也是受到研替時的老闆的影響，老闆是個急性子，也不斷感受到壓力，久了之後心中也對有問題的方法莫名升起一種煩躁感。</p><p>煩躁感的出現，加上有能力表達，也有足夠的知識，變得開始會對身邊的人給建議。</p><p>有可能是談話中朋友表達他的某個想法，我會脫口而出這樣的想法背後可能會有什麼潛在的問題，抑或是我覺得這樣的想法好不好。話題範圍從我的專業領域到日常的電視廣告，只要是我有求證過或是我知道的，很多都會直接給出分析的結果。</p><p>目前正在博士的訓練路途上，博士的訓練是希望有獨立的分析跟研究能力，所以這樣能夠有批判性思考是很重要的能力。</p><p>這樣的分析似乎會困擾我身邊的人，畢竟不是每個人都需要「被建議」，他們或許覺得自己的作法很好，不然就是他就是想要這樣做。雖然我不太介意他是否會採納我的建議，但就是會講出口。有些時候講出口的剎那，對方會有種被否定或是攻擊的感覺，無論我的語氣是用「我覺得」或是「我建議」這種比較不強烈的。</p><p>大多數時候我是覺得我在發表自己的意見，對方也可以有自己的意見，我覺得這樣很公平。不過這些意見有時候是衝突，甚至相反的，有些人就會覺得被否定。的確，被否定的感覺很難受，意見被否定乃至於延伸到人格被否定，有些人是會失去自信的。</p><p>很多文章跟書本都告訴人不要主動給建議，建議只有當別人問的時候才給。或許該學著睜一隻眼閉一隻眼，即便是身邊再親的人也不要輕易給建議。</p><p>事情搞砸就是他的事，與我無關。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這幾年，隨著接觸的東西變多，知道的東西變多，個性上也有點變化。&lt;/p&gt;
&lt;p&gt;約莫四五年前，碩班時期接觸到一些很棒的網路技術文章，當時線上課程也非常熱門，很多優秀的大學紛紛把他們的上課內容做成教材釋出。也因為這樣，我自己其實從這些網路資源受惠非常多。當時也是自己在發展自學能力的輝煌時期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 怎麼用 async 跟 sync</title>
    <link href="https://yuehhua.github.io/2020/09/06/how-to-use-async-sync-in-julia/"/>
    <id>https://yuehhua.github.io/2020/09/06/how-to-use-async-sync-in-julia/</id>
    <published>2020-09-06T09:43:04.000Z</published>
    <updated>2020-10-11T16:36:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>這個問題在官方文件中並沒有詳細記載，所以覺得值得紀錄一下。</p><p>查閱 <code>@async</code> 的文件會講說，他會用一個 <code>Task</code> 把後面的表達式包裝起來，並且將他掛到排程器的佇列（queue）中。意思就是將表達式包裝成一個任務，並放到佇列中等待 CPU 核心的資源來執行他。</p><a id="more"></a><p>然而通常會搭配 <code>@sync</code> 來使用，<code>@sync</code> 的文件中提到，他會等到後面的 <code>@async</code>、<code>@spawn</code>、<code>@spawnat</code> 及 <code>@distributed</code> 都執行完畢。</p><p>使用情境比較像是（修改自<a href="https://stackoverflow.com/questions/37287020/how-and-when-to-use-async-and-sync-in-julia" target="_blank" rel="noopener">這篇 stackoverflow</a>）</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sync</span> <span class="keyword">for</span> (idx, pid) <span class="keyword">in</span> enumerate(workers())</span><br><span class="line">    <span class="meta">@async</span> a[idx] = remotecall_fetch(do_something, pid, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>@sync</code> 會等待這個 block 中的 <code>@async</code> 都執行結束才結束，<code>@async</code> 可以讓你指派一些非同步處理的任務，像是多執行緒或是多行程的平行運算。</p><p><code>@sync</code> 就比較像 python 當中的 <code>join()</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這個問題在官方文件中並沒有詳細記載，所以覺得值得紀錄一下。&lt;/p&gt;
&lt;p&gt;查閱 &lt;code&gt;@async&lt;/code&gt; 的文件會講說，他會用一個 &lt;code&gt;Task&lt;/code&gt; 把後面的表達式包裝起來，並且將他掛到排程器的佇列（queue）中。意思就是將表達式包裝成一個任務，並放到佇列中等待 CPU 核心的資源來執行他。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系統降噪</title>
    <link href="https://yuehhua.github.io/2020/09/06/linux-system-noise-cancellation/"/>
    <id>https://yuehhua.github.io/2020/09/06/linux-system-noise-cancellation/</id>
    <published>2020-09-06T09:22:33.000Z</published>
    <updated>2020-09-06T09:23:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 Linux 上測試麥克風，發現錄製的時候總會把背景雜訊給錄進去，會在有人講話的同時聽到雜音。</p><p>我用的是 OBS 來做桌面錄製，所以自然想用 OBS 來做音訊的降噪。在 OBS 裡有噪音閥及噪音抑制，似乎噪音閥的效果比較明顯，但是講話聲音背後仍有雜音。</p><p>這時候在網路上找了一下，發現可以用系統 pulseaudio 的驅動來做降噪，只是要特別設定開啟，預設是不會開啟的。試了之後效果超好，在這邊紀錄一下。</p><h2 id="步驟">步驟</h2><p>首先，編輯以下檔案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;pulse&#x2F;default.pa</span><br></pre></td></tr></table></figure><p>把以下這行加到檔案中，建議可以加到有個 Echo Cancellation 的地方：</p><p>load-module module-echo-cancel</p><p>重載 PulseAudio (pulseaudio -k) 就可以囉！</p><p>Ref: <a href="https://askubuntu.com/questions/18958/realtime-noise-removal-with-pulseaudio" target="_blank" rel="noopener">https://askubuntu.com/questions/18958/realtime-noise-removal-with-pulseaudio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在 Linux 上測試麥克風，發現錄製的時候總會把背景雜訊給錄進去，會在有人講話的同時聽到雜音。&lt;/p&gt;
&lt;p&gt;我用的是 OBS 來做桌面錄製，所以自然想用 OBS 來做音訊的降噪。在 OBS 裡有噪音閥及噪音抑制，似乎噪音閥的效果比較明顯，但是講話聲音背後仍有雜音。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Julia 中的表達問題（Expression problem in Julia）</title>
    <link href="https://yuehhua.github.io/2020/09/06/expression-problem-in-julia/"/>
    <id>https://yuehhua.github.io/2020/09/06/expression-problem-in-julia/</id>
    <published>2020-09-06T09:19:52.000Z</published>
    <updated>2020-10-11T16:36:31.074Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是啟發自 <a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions" target="_blank" rel="noopener">The Expression Problem and its solutions</a>，當中談論的是在撰寫程式的過程中，所採用的程式典範不同，會在程式表達上遇到不同程度的困難，稱之為表達問題（expression problem）。</p><a id="more"></a><h2 id="物件導向語言中的表達問題">物件導向語言中的表達問題</h2><p>以原文中的例子，作者想以物件導向語言來撰寫一個簡單的 expression evaluator。基本上採用直譯器模式（<a href="https://en.wikipedia.org/wiki/Interpreter_pattern" target="_blank" rel="noopener">interpreter pattern</a>），這邊我把程式碼以 python 重寫。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostring</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constant</span><span class="params">(Expr)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__value = value</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostring</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.__value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryPlus</span><span class="params">(Expr)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lhs, rhs)</span>:</span></span><br><span class="line">        self.__lhs = lhs</span><br><span class="line">        self.__rhs = rhs</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostring</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__lhs.tostring() + <span class="string">" + "</span> + self.__rhs.tostring()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__lhs.eval() + self.__rhs.eval()</span><br></pre></td></tr></table></figure><p>我們先定義了一個 <code>Expr</code>，我們希望提供 <code>tostring</code> 及 <code>eval</code> 兩種操作。我們後續定義了常數 <code>Constant</code>，也讓常數實作這兩種操作。</p><p>如果我們想要擴充 <code>Expr</code> 或是 <code>Constant</code> 的時候該怎麼做呢？更精確地說，如果我們想要新增新的操作到既有的類別上，我們該怎麼做？一般情況下可能就是直接在原有的類別上加上新的方法。不過這樣其實違反了軟體工程原則，開放封閉原則（open-closed principle），我們應該要對舊有的類別、方法、介面等等程式碼修改保持<em>封閉</em>，也就是不能去修改既有程式碼，我們應該對新增程式碼保持<em>開放</em>，也就是允許新增程式碼。</p><p>我們可以發現在物件導向語言當中，新增類別是容易的，但是新增方法是困難的。這是在物件導向語言中所遇到的表達問題。</p><h2 id="函數式語言中的表達問題">函數式語言中的表達問題</h2><p>以 Haskell 為例，撰寫以上的程式（這邊直接引用原文）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data Expr &#x3D; Constant Double</span><br><span class="line">          | BinaryPlus Expr Expr</span><br><span class="line"></span><br><span class="line">stringify :: Expr -&gt; String</span><br><span class="line">stringify(Constant c) &#x3D; show c</span><br><span class="line">stringify(BinaryPlus lhs rhs) &#x3D; stringify lhs</span><br><span class="line">                                ++ &quot; + &quot;</span><br><span class="line">                                ++ stringify rhs</span><br><span class="line"></span><br><span class="line">evaluate :: Expr -&gt; Double</span><br><span class="line">evaluate(Constant c) &#x3D; c</span><br><span class="line">evaluate(BinaryPlus lhs rhs) &#x3D; evaluate lhs + evaluate rhs</span><br></pre></td></tr></table></figure><p>在 Haskell 中，要新增方法是容易的，但是如果要新增型別的話，就得動到 <code>data</code> 的定義。在函數式語言中，新增型別是困難的。這是在函數式語言中所遇到的表達問題。</p><h2 id="Julia-語言中的表達問題？">Julia 語言中的表達問題？</h2><p>文章中有提到 Clojure 採用的是 multi-methods，他可以對應到 Julia 的多重分派（multiple dispatch）。多重分派可以好好地處理表達問題，讓新增型別及方法都是簡單的。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> <span class="built_in">Expr</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tostring(::<span class="built_in">Expr</span>) = <span class="number">0</span></span><br><span class="line">eval(::<span class="built_in">Expr</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Constant&#123;T&#125;</span><br><span class="line">    value::T</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tostring(::Constant) = <span class="built_in">String</span>(c.value)</span><br><span class="line">eval(c::Constant) = c.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BinaryPlus</span><br><span class="line">    lhs::<span class="built_in">Expr</span></span><br><span class="line">    rhs::<span class="built_in">Expr</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tostring(b::BinaryPlus) = tostring(b.lhs) * <span class="string">" + "</span> * tostring(b.rhs)</span><br><span class="line">eval(b::BinaryPlus) = eval(b.lhs) + eval(b.rhs)</span><br></pre></td></tr></table></figure><p>不過他文末也有提到一個關鍵是 open method，也就是將方法定義在類別之外，如此一來，新增方法就會是簡單的。所以真正解決表達問題的並不是多重分派的機制，而是 open method 的設計。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是啟發自 &lt;a href=&quot;https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Expression Problem and its solutions&lt;/a&gt;，當中談論的是在撰寫程式的過程中，所採用的程式典範不同，會在程式表達上遇到不同程度的困難，稱之為表達問題（expression problem）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 中如何合併集合容器</title>
    <link href="https://yuehhua.github.io/2020/08/28/merge-collections-in-julia/"/>
    <id>https://yuehhua.github.io/2020/08/28/merge-collections-in-julia/</id>
    <published>2020-08-28T14:37:43.000Z</published>
    <updated>2020-08-28T14:37:43.527Z</updated>
    
    <content type="html"><![CDATA[<p>我們都知道要將兩個 <code>Array</code> 接起來要用 <code>append!</code>，要將兩個 <code>Set</code> 合併起來要用 <code>union!</code>，但要將 <code>Dict</code> 合併起來要用什麼呢？</p><p>答案是 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.merge" target="_blank" rel="noopener">merge</a>！</p><h2 id="merge">merge</h2><p>廢話不多說，我們看範例：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = <span class="built_in">Dict</span>(:a =&gt; <span class="string">"A"</span>, :b =&gt; <span class="string">"B"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">julia&gt; b = <span class="built_in">Dict</span>(:c =&gt; <span class="string">"C"</span>, :d =&gt; <span class="string">"D"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line">  :c =&gt; <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">julia&gt; merge(a, b)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">4</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"B"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line">  :c =&gt; <span class="string">"C"</span></span><br></pre></td></tr></table></figure><p><code>merge</code> 可以將兩個 <code>Dict</code> 合併起來，並且產生一個新的 <code>Dict</code>。</p><p>有另一個函式 <code>merge!</code> 可以支援 in-place 版本的合併。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">julia&gt; merge!(a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line">julia&gt; a</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br></pre></td></tr></table></figure><h3 id="重複的鍵（key）">重複的鍵（key）</h3><p>如果要合併的兩個字典當中有重複的鍵出現的話，會發生什麼事呢？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; c = <span class="built_in">Dict</span>(:b =&gt; <span class="string">"C"</span>, :d =&gt; <span class="string">"D"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line">julia&gt; merge(a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br></pre></td></tr></table></figure><p>答案是會被後者蓋掉。</p><h3 id="NamedTuple">NamedTuple</h3><p><code>merge</code> 也可以用在 NamedTuple 上。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = (a=<span class="string">"A"</span>, b=<span class="string">"B"</span>)</span><br><span class="line">(a = <span class="string">"A"</span>, b = <span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; b = (c=<span class="string">"C"</span>, d=<span class="string">"D"</span>)</span><br><span class="line">(c = <span class="string">"C"</span>, d = <span class="string">"D"</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; merge(a, b)</span><br><span class="line">(a = <span class="string">"A"</span>, b = <span class="string">"B"</span>, c = <span class="string">"C"</span>, d = <span class="string">"D"</span>)</span><br></pre></td></tr></table></figure><h2 id="mergewith-require-v1-5-and-above">mergewith (require v1.5 and above)</h2><p>接下來介紹一個更好用的函式 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.mergewith" target="_blank" rel="noopener">mergewith</a>。</p><p>上面我們介紹的 <code>merge</code> 遇到相同的鍵，會把彼此蓋掉的行為，但有時候我們希望他們可以合併。</p><p>不囉唆，我們看範例：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = <span class="built_in">Dict</span>(:a =&gt; <span class="number">1</span>, :b =&gt; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :a =&gt; <span class="number">1</span></span><br><span class="line">  :b =&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">julia&gt; c = <span class="built_in">Dict</span>(:b =&gt; <span class="number">3</span>, :d =&gt; <span class="number">4</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :b =&gt; <span class="number">3</span></span><br><span class="line">  :d =&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line">julia&gt; mergewith(+, a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="number">1</span></span><br><span class="line">  :b =&gt; <span class="number">5</span></span><br><span class="line">  :d =&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>我們可以指定一個 aggregate function，如果遇到相同的鍵時，就把他們的值相加起來。</p><p>這個 aggregate function 可以是其他的，如此就可以處理多樣的資料。</p><p><code>mergewith</code> 一樣有 in-place 版本 <code>mergewith!</code>。</p><h3 id="curry-function">curry function</h3><p>最神奇的是，<code>mergewith</code> 有類似 curry function 的行為。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; mergewith(+)(a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="number">1</span></span><br><span class="line">  :b =&gt; <span class="number">5</span></span><br><span class="line">  :d =&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line">julia&gt; mergewith(+)</span><br><span class="line"><span class="comment">#140 (generic function with 1 method)</span></span><br></pre></td></tr></table></figure><p>你可以先給他一個 aggregate function，他會回傳一個匿名函式。</p><p>你可以拿這個匿名函式用在其他物件上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我們都知道要將兩個 &lt;code&gt;Array&lt;/code&gt; 接起來要用 &lt;code&gt;append!&lt;/code&gt;，要將兩個 &lt;code&gt;Set&lt;/code&gt; 合併起來要用 &lt;code&gt;union!&lt;/code&gt;，但要將 &lt;code&gt;Dict&lt;/code&gt; 合併起來要用什麼呢？
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia v1.5 釋出</title>
    <link href="https://yuehhua.github.io/2020/08/07/julia-v1-5-release/"/>
    <id>https://yuehhua.github.io/2020/08/07/julia-v1-5-release/</id>
    <published>2020-08-07T03:06:29.000Z</published>
    <updated>2020-08-07T03:14:34.552Z</updated>
    
    <content type="html"><![CDATA[<p>在新的 1.5 版是主要對記憶體的配置方式有改進，有最佳化記憶體布局（memory layout）。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><p>不可變型別（包含 tuples）現在可以被放到堆疊（stack）上，而且可以在陣列跟其他型別中被配置成 inline。(#33886)<br>有興趣的朋友可以查詢 inline allocation 相關關鍵字。如此一來就大幅降低了在堆積（heap）上配置的記憶體數量。<br>相對，任何需要是穩定定址（stable address）的物件就要必須是 <code>mutable struct</code>。(#34126)</p><h3 id="使用者功能">使用者功能</h3><ul><li>在互動式 REPL 環境提供了「軟性作用域」（soft scope）。像是在 <code>for</code> loop 的作用域中要指定值給全域變數，是可行的。如同在 IJulia 所提供的 Jupyter 環境一樣，但這只影響 REPL 環境，不影響腳本執行環境。(#28789, #33864)</li><li>如果在 REPL 外，例如腳本，執行以上行為會被視為模糊的（ambiguous），並且會發出 warning。</li><li>另外，有一個新的命令列選項是 <code>--warn-scope</code> 可以控制這個 warning。(#33864)</li><li>在三個雙引號所形成的字串中，空白移除（whitespace stripping）會優於跳脫字元執行。如此一來，以下例子會有不同的結果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">  a\n b&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>會產生 <code>&quot;a\n b&quot;</code> 的字串，而不是 <code>&quot; a\nb&quot;</code>，兩者差別在 <code>a</code> 之前有沒有空白。老舊的行為會被視為一種 bug。(#35001)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>現在可以在每個模組（module）中使用編譯器最佳化等級（compiler optimization level），是使用 <code>Base.Experimental.@optlevel n</code> 來設定。對於並不是那麼效能需求（performance-critical），可以設定成 0 或 1，可以提供相當的延遲改善（latency improvements）。(#34896)</li><li><code>@inline</code> 可以被用在短型的匿名函數。(#34953)</li><li>棄用警告（deprecation warnings）不再是預設顯示的，可以使用 <code>--depwarn=no</code> 來開啟。警告在執行測試 <code>Pkg.test()</code> 時是會顯示的。(#35362)</li><li>部份的多執行緒（multi-threading）API 被視為穩定。這包含了所有 <code>Base.Threads</code> 中被紀錄的 API，但除了 <code>atomic_</code> 操作。</li><li><code>@threads</code> 現在容許可選的排程參數（schedule argument）。用法像是 <code>@threads :static ...</code>。</li><li><code>@ccall</code> 現在被加入到 Base 中。這跟 <code>ccall</code> 很像，但多了類 Julia 語法。他也包裝了新的 <code>foreigncall</code> API，支援 varargs 中不同的型別，不過他缺乏呼叫指定 LLVM calling convention 的能力。(#32748)</li><li><code>@view</code> 及 <code>@views</code> 現在支援 <code>a[begin]</code> 語法。(#35289)</li></ul><h2 id="新功能">新功能</h2><ul><li><code>⨟</code> 現在是一個二元運算子，他是一個 composition operator，語意為 <code>f ⨟ g = g ∘ f</code>。在 REPL，可以使用 <code>\bbsemi</code> 加上 <kbd>TAB</kbd> 打出來。(#34722)</li><li>傳遞一個辨識子（identifier）<code>x</code> 作為關鍵字參數或是 named tuple，會等同於 <code>x=x</code>，會隱含地使用變數名稱本身作為關鍵字參數的名稱或 named tuple 的名稱。同樣地，傳遞 <code>a.b</code> 會使用 <code>b</code> 作為名稱。(#29333)</li><li>新增 <code>mergewith</code> 及 <code>mergewith!</code> 取代 <code>merge</code>、<code>merge!</code> 及參數 <code>combine</code> 的組合。(#34296)</li><li>新增 <code>isdisjoint</code> 來指示兩個集合容器是否為互斥。(#34427)</li><li>新增 <code>ismutable</code> 來取代 <code>isimmutable</code>，用來檢查某些東西是否為可變的。(#34652)</li><li>新增 <code>contains(haystack, needle)</code> 行為如同 <code>occursin(needle, haystack)</code>。(#35132)</li></ul><h2 id="新支援">新支援</h2><ul><li>使用 <code>open</code> 開檔時，多了 <code>lock</code> 關鍵字參數來控制檔案操作是否在多執行緒存取的狀況下需要鎖。當只有一個執行緒存取時，設定成 <code>false</code> 會有較好的性能。(#35426)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在新的 1.5 版是主要對記憶體的配置方式有改進，有最佳化記憶體布局（memory layout）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>真理</title>
    <link href="https://yuehhua.github.io/2020/05/23/the-truth/"/>
    <id>https://yuehhua.github.io/2020/05/23/the-truth/</id>
    <published>2020-05-23T04:55:01.000Z</published>
    <updated>2020-05-23T05:18:56.180Z</updated>
    
    <content type="html"><![CDATA[<p>今天意外看到一段話，出處應該是《不用數字的研究 ：質性研究的思辯脈絡》一書。</p><blockquote><p><strong>&quot;To achieve enlightenment, our political systems must relinquish their claims on truth, justice and freedom and have to replace them with the search for truth, justice, freedom and reason.&quot;</strong><br>– Immanuel Kant</p></blockquote><a id="more"></a><p><a href="https://commons.wikimedia.org/wiki/File:Kant_gemaelde_3.jpg#/media/File:Kant_gemaelde_3.jpg" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f2/Kant_gemaelde_3.jpg" alt="Kant gemaelde 3.jpg"></a><br>由 Johann Gottlieb Becker (1720-1782) - <a rel="nofollow noopener" class="external free" href="http://www.philosovieth.de/kant-bilder/bilddaten.html" target="_blank">http://www.philosovieth.de/kant-bilder/bilddaten.html</a>, 公有領域, <a href="https://commons.wikimedia.org/w/index.php?curid=32860677" target="_blank" rel="noopener">連結</a></p><p>康德是個歷史上重要的哲學家，他指出了面對真理的態度。</p><p>要得到開悟，我們的體系需要放棄他們對於真理、正義以及自由的定義。取而代之的是，對於真理、正義以及自由的追求與探索。</p><p>開悟的過程並不是去讀懂一些名人、大師的名言，也不是去崇尚大家所共識的真理。</p><p>真理、正義以及自由並不是由人定義出來的，而是經由追求與探索得到的。</p><p>這讓我想到科學不也是一個這樣的過程嗎？</p><p>科學並不是由教科書上所定義及構築出來的美好世界，科學本身是一種過程，科學是一種追求與探索真理的過程。</p><p>也就是說，一旦停滯了，不往前走，就不是科學了。在原地享用科學的成果也不是科學本身，科學必須前進，必須去拓展未知的領域。</p><h2 id="有限">有限</h2><p>然而大家目前看到的量子、人工智慧種種科技，並非科學本身，而是科學的產物。是有一群人秉持著這樣的想法不斷往前探索所得到的<strong>暫時的</strong>結論。</p><p>是的，所以在世的東西都是暫時的。知識會老去，會有新的知識產出。我們會證明舊的知識不再適用，有一套新的知識取而代之。</p><p>沒有什麼東西是永恆的。永恆只存在在當時間走到盡頭（$t \rightarrow \infty$），然而時間沒有盡頭。</p><p>當事物到了無限大的時候，永恆才存在，真理才存在，理論才存在。但在那之前都是暫時的，所有事物都有生死，是<strong>有限的</strong>。</p><p>人是有限的，但人常嚮往無限。</p><p>既然有限，當然也不會知道真理、正義以及自由的終極定義是什麼。</p><h2 id="往前">往前</h2><p>唯一能做的就是不斷地往前走，不斷地探索，不斷地尋找真理、正義以及自由。</p><p>企業不斷尋找市場，想知道最終市場會在哪裡，可惜的是它永遠是變動的，只能不斷追尋。</p><p>研究人員在尋找真理，尋找真理需要方法，可惜的是無法達到彼岸，只是不停地往前。</p><p>以科學的方式不斷地往前走及探索，才是科學本身。</p><h2 id="博士">博士</h2><p>念博士是個開悟的過程，從一個靜態的世界觀，走向一個動態的世界觀。</p><p>從一個有標準答案的世界，走向一個沒有標準答案的世界，甚至每個都有可能是答案。</p><p>從一個遵循定義，到可以隨處都是定義，或是所有定義都不存在。</p><h2 id="暫時的答案">暫時的答案</h2><p>很多研究結果是得到一個暫時的答案。</p><p>很多研究結果很快就被證明是錯的，或是可以做出同樣結論的人不多。</p><p>太快擁抱結果，或是擁抱單一的答案都是一種 overfitting，它失去對未來的適應性即可預測性。</p><p>但是如果不擁抱結果，你會一無所穫，事物都無法推進，裹足不前。</p><h2 id="方法">方法</h2><p>方法，就像搭橋，它連結了現在與未來，連結了有限與無限。</p><p>找到對的方法會讓你有比較穩固的方式連結現況與未來，錯誤的方法相對脆弱。</p><p>追求真理的過程其實大多都在尋找方法。</p><p>很多時候不是「XXX是錯誤的」，而是所用的方法不對而已，換個方法就是了。</p><h2 id="勇敢">勇敢</h2><p>既然達不到真理，那我們為什麼還要追求？</p><p>當然你也可以用現有的知識跟技術，就這樣生活下去。</p><p>很多的問題沒有好好地解決，環境問題、人權問題等等，我們仍舊可以依然固我地無視這些問題，繼續活在痛苦之中。</p><blockquote><p>「世界上只有一種真正的英雄主義，那就是在認清生活真相之後，依然熱愛生活。」——羅曼羅蘭</p></blockquote><p>我們認清什麼是真理，即便達不到真理，仍舊熱愛追求真理，稱之為英雄。</p><p>成為英雄，需要勇氣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天意外看到一段話，出處應該是《不用數字的研究 ：質性研究的思辯脈絡》一書。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;To achieve enlightenment, our political systems must relinquish their claims on truth, justice and freedom and have to replace them with the search for truth, justice, freedom and reason.&amp;quot;&lt;/strong&gt;&lt;br&gt;
– Immanuel Kant&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>可組合性（Composable）：Julia 語言的重要特性</title>
    <link href="https://yuehhua.github.io/2020/04/11/composable-the-key-feature-in-julia/"/>
    <id>https://yuehhua.github.io/2020/04/11/composable-the-key-feature-in-julia/</id>
    <published>2020-04-11T05:43:24.000Z</published>
    <updated>2020-04-11T14:42:46.670Z</updated>
    
    <content type="html"><![CDATA[<p>其實是受到 Julia 核心開發者之一 Lyndon White 的<a href="https://white.ucc.asn.au/2020/02/09/whycompositionaljulia.html" target="_blank" rel="noopener">文章</a>的啟發來撰寫本文的。</p><p>文章有 <a href="https://mp.weixin.qq.com/s/4_Sbi8q5EZDjHj6ouM1Ydg" target="_blank" rel="noopener">CSDNnews 簡中翻譯</a>。</p><p>本文並非以上文章的繁中版本，而是本人的一些心得及觀察。</p><h2 id="載入套件">載入套件</h2><p>比較深入了解 Julia 的朋友，會了解到這個語言的設計與其他語言的不同，像是 <code>using</code>。</p><p>當我們使用 <code>using</code> 來載入套件的時候，會發現有不少存在在 <code>Base</code> 中的函式是可以使用的。像是 <code>length</code> 可以用來取得陣列的長度，當你載入 DataStructures.jl 時，你同樣可以用 <code>length</code> 來取得 <code>Stack</code> 及 <code>Queue</code> 的長度。</p><p>或者是原文中的例子。使用者可以使用 <a href="https://github.com/invenia/NamedDims.jl" target="_blank" rel="noopener">NamedDims.jl</a> 來為你的陣列的維度命名，而你的陣列需要使用 <a href="https://github.com/JuliaGPU/CuArrays.jl" target="_blank" rel="noopener">CuArrays.jl</a> 送到 CUDA，這時候你不需要一個可以為 CUDA array 命名的套件來達成這件事。</p><p>你會發現在 Julia 語言中似乎不存在套件跟套件之間的差別，或是套件跟標準函式庫之間的區別。這是由於在 Julia 中對於命名空間（namespace）的概念較為薄弱，Julia 各模組之間仍然存在著命名空間，但是 Julia 在 <code>using</code> 時會將這些命名空間去除。這在工程上或許不是一個好的典範，因為會造成命名空間的汙染（namespace pollution）。反過來說，它促使人們相互溝通及協調，來提供更好的套件之間的可組合性。</p><p>在其他語言中，常常會告訴你，使用某個套件只需要載入你需要的部份，像是 <code>using Foo: bar, baz</code>，然而 Julia 並不去特別強調這點，<code>using Foo</code> 會載入套件開發者有導出的部份。如果有兩個套件都提供了 <code>predict</code> 來支援他們的模型，這邊借原文的例子再次說明：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Foo</span><br><span class="line"><span class="keyword">using</span> Bar</span><br><span class="line">training_data, test_data = ...</span><br><span class="line">mbar = BarModel(training_data)</span><br><span class="line">mfoo = FooModel(training_data)</span><br><span class="line">evaluate(predict(mbar), test_data)</span><br><span class="line">evaluate(predict(mfoo), test_data)</span><br></pre></td></tr></table></figure><p>這兩個 <code>predict</code> 分別來自雙方套件的各自定義及實作。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bar.predict(mbar)</span><br><span class="line">Foo.predict(mfoo)</span><br></pre></td></tr></table></figure><p>如此使用者便可以無縫地使用同樣一個介面 <code>predict</code>，而功能來自兩個不同的套件。</p><p>這樣的特性大概會有人聯想到介面（interface）。然而，Julia 並不明顯使用介面來規範開發者，Julia 隱含地使用鴨子定型（duck typing）。</p><p>在載入套件之後，Julia 允許使用者不冠上套件名稱來使用這些函式，像 <code>Bar.predict</code>，你可以自由地使用 <code>predict</code> 即可。總是會有套件之間的命名衝突，當衝突發生的時候，就是開發者需要負起責任彼此溝通及協調的時候。不過使用者仍然可以以 <code>Bar.predict</code> 的方式使用套件，只是每次載入套件的時候都會有警告。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">using</span> Gadfly</span><br><span class="line"></span><br><span class="line">julia&gt; plot</span><br><span class="line">WARNING: both Gadfly and Plots <span class="keyword">export</span> <span class="string">"plot"</span>; uses of it <span class="keyword">in</span> <span class="keyword">module</span> Main must be qualified</span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: plot not defined</span><br></pre></td></tr></table></figure><h2 id="鴨子定型及多重分派">鴨子定型及多重分派</h2><p>在原文中提到鴨子定型及多重分派是成就 Julia 成為一個可組合（composable）語言的基石。我個人也認為可組合是 Julia 提供最重要的特性之一，但卻鮮少被人提及。多數人仍然熱衷於語言效能及開發便利性。</p><p>鴨子定型的一個很好的比喻是，當一個東西會呱呱叫的時候，那麼他就是鴨子。當一個 <code>bar(x)</code> 可以呼叫時，我不需要去檢查 <code>x</code> 的型別為何，我就直接使用就是了。這樣會構成一種隱性的介面。</p><p>當我需要提供一個矩陣相乘的功能時，我會寫以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> multiply(A, B)</span><br><span class="line">    C = zeros(size(A, <span class="number">1</span>), size(B, <span class="number">2</span>))</span><br><span class="line">    A = A'</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>:size(C, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>:size(C, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">1</span>:size(A, <span class="number">2</span>)</span><br><span class="line">                C[i, j] = sum(A[:, k] .* B[:, k])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這可以用在一般的矩陣，但如果今天我有自定義的一個新的矩陣呢？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> NewArray</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上述的 <code>multiply</code> 中我只需要檢查 <code>NewArray</code> 是否提供相關的介面即可。像是裡頭用到了 <code>size</code>、<code>A[:, k]</code> 及 <code>sum</code>。我只需要支援這些介面的實作即可，如此，Julia 就可以以鴨子定型的方式，讓 <code>multiply</code> 接受 <code>NewArray</code> 了。</p><p>對於不同的型別需要有不同的行為，這在一般的物件導向語言中稱之為多型。多型在多數物件導向典範中使用的是單一分派（single dispatch），然而 Julia 也支援多型，但是以多重分派（multiple dispatch）的方式支援。因此，廣義而言，Julia 支援物件導向的方式是多重分派，卻不是典型的、語法上的封裝、繼承及（單一分派）多型。</p><p>多重分派，可以在需要更細緻行為定義時幫上忙。當 <code>NewArray</code> 支援 <code>sum</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray) = ...</span><br></pre></td></tr></table></figure><p>這是單一分派的方式，也可以有多重分派的方式。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray, ::<span class="built_in">Array</span>) = ...</span><br></pre></td></tr></table></figure><p>不過這樣只支援 <code>Array</code> 這個特定型別。或是我們可以乾脆這樣做。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray, ::<span class="built_in">AbstractArray</span>) = ...</span><br></pre></td></tr></table></figure><p>這樣只要是 <code>AbstractArray</code> 的子型別都可以接受。</p><h2 id="總結">總結</h2><p>以上種種的特性成為了可組合性的基石。一個具有可組合性的語言能夠成為各種東西。Julia 的個別的套件都不俱備所有的定義，需要依賴 Julia 語言及標準函式庫的介面及實作。</p><p>例如當 Julia 中載入了深度學習框架，那它，連同語言本身，就是一個完整支援深度學習功能的引擎。當同時載入了資料庫與深度學習相關套件，那它就成為了支援深度學習功能的 DBMS。當載入了科學計算及機器學習套件，那它就會變成一個強大的數值計算引擎。以 Julia 的可組合性出發，來打造各式各樣不同的引擎，就像一個單純的編輯器搭配有豐富的外掛（plug-in）一樣。這樣衍生出的生態帶來了各式各樣不同的可能性，也讓套件的 reusability 提升到最高的境界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其實是受到 Julia 核心開發者之一 Lyndon White 的&lt;a href=&quot;https://white.ucc.asn.au/2020/02/09/whycompositionaljulia.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>讓 Julia 像 Python 一樣擁有物件 property</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-property/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-property/</id>
    <published>2020-04-10T02:56:41.000Z</published>
    <updated>2020-04-10T02:56:41.889Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 的物件都有屬性，但這需要寫在型別中事先定義。但如果要為沒有任何屬性的型別增加屬性要怎麼做？</p><p>Julia 的屬性存取是來自 <code>Base.getproperty</code> 及 <code>Base.setproperty!</code> 兩個方法。</p><a id="more"></a><p>如果我們這樣定義。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">struct</span> Foo <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Base.getproperty(::Foo, x::<span class="built_in">Symbol</span>) = <span class="string">"<span class="variable">$x</span>"</span></span><br></pre></td></tr></table></figure><p>來測試不同的 property。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; foo = Foo()</span><br><span class="line">Foo()</span><br><span class="line"></span><br><span class="line">julia&gt; foo.a</span><br><span class="line"><span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.x</span><br><span class="line"><span class="string">"x"</span></span><br></pre></td></tr></table></figure><p>以及設定的部份。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.setproperty!(::Foo, x::<span class="built_in">Symbol</span>, v) = <span class="literal">nothing</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.b = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>不過要注意的是，如果對本身就有屬性的型別增加 <code>Base.getproperty</code> 及 <code>Base.setproperty!</code> 兩個方法，會去更動到原先的屬性存取行為喔！這邊要注意一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 的物件都有屬性，但這需要寫在型別中事先定義。但如果要為沒有任何屬性的型別增加屬性要怎麼做？&lt;/p&gt;
&lt;p&gt;Julia 的屬性存取是來自 &lt;code&gt;Base.getproperty&lt;/code&gt; 及 &lt;code&gt;Base.setproperty!&lt;/code&gt; 兩個方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>設定 Julia 多執行緒</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-multithread-setup/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-multithread-setup/</id>
    <published>2020-04-10T02:19:55.000Z</published>
    <updated>2020-04-10T02:19:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 從 v1.3 起支援多執行緒（multithreading）。</p><p>這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。</p><a id="more"></a><p>一般要在 Julia 中使用多執行緒，可以在啟動 Julia 時，以環境變數的形式指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JULIA_NUM_THREADS&#x3D;4 julia</span><br></pre></td></tr></table></figure><p>但不想在每次啟動時都加入，這樣會很麻煩。</p><p>我們可以將這個寫到環境變數當中。像是在 Linux 環境中，可以將以下環境變數寫到 ~/.bashrc 或 ~/.bash_profile 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JULIA_NUM_THREADS&#x3D;4</span><br></pre></td></tr></table></figure><p>Ref: <a href="https://docs.julialang.org/en/v1/manual/environment-variables/index.html" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/environment-variables/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 從 v1.3 起支援多執行緒（multithreading）。&lt;/p&gt;
&lt;p&gt;這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>編譯 Julia 套件來避免過長的載入時間</title>
    <link href="https://yuehhua.github.io/2020/04/10/compile-julia-package/"/>
    <id>https://yuehhua.github.io/2020/04/10/compile-julia-package/</id>
    <published>2020-04-10T02:06:04.000Z</published>
    <updated>2020-06-01T17:12:08.617Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（<code>using</code>）過於冗長。</p><p>Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。</p><p>為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。</p><p>PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。</p><p>近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。</p><a id="more"></a><h2 id="動態語言編譯">動態語言編譯</h2><p>在動態語言中，編譯一直是一個大問題。編譯時，需要知道更多底層的細節，像是變數的型別。例如 <code>foo(a::Any, b::Any)</code> 這樣的函式在動態語言中非常常見。Julia 會在呼叫 <code>foo(3, 4)</code> 時，經由型別推斷（type inference）知道它需要編譯 <code>foo(a::Int64, b::Int64)</code> 這樣的方法出來。當下次呼叫 <code>foo(3., 4.)</code> 時，則需要編譯 <code>foo(a::Float64, b::Float64)</code>。然而，要完整的編譯 <code>foo</code> 這個函式，需要編譯多少種方法呢？在型別的排列組合上會造成組合爆炸的問題，讓需要編譯的方法多到難以處理。這一直以來是動態語言無法完整編譯的問題點。</p><p>那麼 Julia 怎麼做？PackageCompiler.jl 套件的編譯來自於 JIT，所以它直接將 Julia session 中已經編譯的函式儲存下來，以利後續使用。編譯的函式會以動態函式庫（.so）的形式儲存，就如同其他語言一樣。然而，Julia 仍然沒有完整編譯，Julia 只有部份編譯便存入動態函式庫。若是需要使用到未編譯的函式，就會在使用時 JIT 去處理。或許可以藉由套件的測試來增加編譯的函式數目，例如提高測試的覆蓋度來儘可能觸發各式各樣的方法進行編譯，然後儲存下來。</p><h2 id="編譯套件">編譯套件</h2><p>這邊我以編譯 Plots.jl 套件為例，繪圖相關套件的載入時間總是異常地久，所以我選擇 Plots.jl 套件來舉例。</p><p>請確定 Julia 中已經安裝 Plots.jl 套件。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> PackageCompiler</span><br><span class="line"></span><br><span class="line">julia&gt; create_sysimage(:Plots; sysimage_path=<span class="string">"Plots.so"</span>)</span><br><span class="line">[ Info: PackageCompiler: creating system image object file, this might take a <span class="keyword">while</span>...</span><br></pre></td></tr></table></figure><p><code>create_sysimage</code> 會編譯並產生 sysimage，這個 image 可以在 Julia 啟動時一併載入，它會以動態函式庫的形式儲存下來。第一個參數請指定需要編譯的套件名稱，可以同時編譯多個套件，例如 <code>[:Plots, :Gadfly]</code>。關鍵字參數 <code>sysimage_path=&quot;Plots.so&quot;</code> 需要指定 system image 的檔名。執行後需要一段時間進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ls</span><br><span class="line">Plots.so</span><br></pre></td></tr></table></figure><p>編譯完成後便可以在目前的資料夾下看到編譯完成的檔案 <a href="http://Plots.so" target="_blank" rel="noopener">Plots.so</a>。</p><p>在下次使用時使用的話，請在啟動 Julia 時加入參數 <code>-JPlots.so</code>。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; exit()</span><br><span class="line"></span><br><span class="line">$ julia -JPlots.so</span><br></pre></td></tr></table></figure><p>如此，我們就可以看到在啟動 Julia 之後載入的套件就有 Plots.jl 囉！Plots.jl 套件的載入時間被包含在 Julia 啟動時間中。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.loaded_modules</span><br><span class="line"><span class="built_in">Dict</span>&#123;Base.PkgId,<span class="built_in">Module</span>&#125; with <span class="number">72</span> entries:</span><br><span class="line">  <span class="built_in">Future</span> [<span class="number">9</span>fa8497b-<span class="number">333</span>b-<span class="number">5362</span>-<span class="number">9e8</span>d-<span class="number">4</span>d0656e87820]           =&gt; <span class="built_in">Future</span></span><br><span class="line">  Requires [ae029012-a4dd-<span class="number">5104</span>-<span class="number">9</span>daa-d747884805df]         =&gt; Requires</span><br><span class="line">  RecipesBase [<span class="number">3</span>cdcf5f2-<span class="number">1</span>ef4-<span class="number">517</span>c-<span class="number">9805</span>-<span class="number">6587</span>b60abb01]      =&gt; RecipesBase</span><br><span class="line">  InteractiveUtils [b77e0a4c-d291-<span class="number">57</span>a0-<span class="number">90e8</span>-<span class="number">8</span>db25a27a240] =&gt; InteractiveUtils</span><br><span class="line">  Pkg [<span class="number">44</span>cfe95a-<span class="number">1</span>eb2-<span class="number">52</span>ea-b672-e2afdf69b78f]              =&gt; Pkg</span><br><span class="line">  Printf [de0858da-<span class="number">6303</span>-<span class="number">5e67</span>-<span class="number">8744</span>-<span class="number">51</span>eddeeeb8d7]           =&gt; Printf</span><br><span class="line">  Base64 [<span class="number">2</span>a0f44e3-<span class="number">6</span>c83-<span class="number">55</span>bd-<span class="number">87e4</span>-b1978d98bd5f]           =&gt; Base64</span><br><span class="line">  Test [<span class="number">8</span>dfed614-e22c-<span class="number">5e08</span>-<span class="number">85e1</span>-<span class="number">65</span>c5234f0b40]             =&gt; Test</span><br><span class="line">  Reexport [<span class="number">189</span>a3867-<span class="number">3050</span>-<span class="number">52</span>da-a836-e630ba90ab69]         =&gt; Reexport</span><br><span class="line">  Dates [ade2ca70-<span class="number">3891</span>-<span class="number">5945</span>-<span class="number">98</span>fb-dc099432e06a]            =&gt; Dates</span><br><span class="line">  DelimitedFiles [<span class="number">8</span>bb1440f-<span class="number">4735</span>-<span class="number">579</span>b-a4ab-<span class="number">409</span>b98df4dab]   =&gt; DelimitedFiles</span><br><span class="line">  LAME_jll [c1c5ebd0-<span class="number">6772</span>-<span class="number">5130</span>-a774-d5fcae4a789d]         =&gt; LAME_jll</span><br><span class="line">  Missings [e1d29d7a-bbdc-<span class="number">5</span>cf2-<span class="number">9</span>ac0-f12de2c33e28]         =&gt; Missings</span><br><span class="line">  __PackagePrecompilationStatementModule [top-level]      =&gt; __PackagePrecompilationStatementModule</span><br><span class="line">  Opus_jll [<span class="number">91</span>d4177d-<span class="number">7536</span>-<span class="number">5919</span>-b921-<span class="number">800302f37372</span>]         =&gt; Opus_jll</span><br><span class="line">  StatsBase [<span class="number">2913</span>bbd2-ae8a-<span class="number">5f71</span>-<span class="number">8</span>c99-<span class="number">4</span>fb6c76f3a91]        =&gt; StatsBase</span><br><span class="line">  libfdk_aac_jll [f638f0a6-<span class="number">7</span>fb0-<span class="number">5443</span>-<span class="number">88</span>ba-<span class="number">1</span>cc74229b280]   =&gt; libfdk_aac_jll</span><br><span class="line">  libvorbis_jll [f27f6e37-<span class="number">5</span>d2b-<span class="number">51</span>aa-<span class="number">960</span>f-b287f2bc3b7a]    =&gt; libvorbis_jll</span><br><span class="line">  REPL [<span class="number">3</span>fa0cd96-eef1-<span class="number">5676</span>-<span class="number">8</span>a61-b3b8758bbffb]             =&gt; REPL</span><br><span class="line">  x265_jll [dfaa095f-<span class="number">4041</span>-<span class="number">5</span>dcd-<span class="number">9319</span>-<span class="number">2</span>fabd8486b76]         =&gt; x265_jll</span><br><span class="line">  LibGit2 [<span class="number">76f85450</span>-<span class="number">5226</span>-<span class="number">5</span>b5a-<span class="number">8</span>eaa-<span class="number">529</span>ad045b433]          =&gt; LibGit2</span><br><span class="line">  Distributed [<span class="number">8</span>ba89e20-<span class="number">285</span>c-<span class="number">5</span>b6f-<span class="number">9357</span>-<span class="number">94700520</span>ee1b]      =&gt; Distributed</span><br><span class="line">  Plots [<span class="number">91</span>a5bcdd-<span class="number">55</span>d7-<span class="number">5</span>caf-<span class="number">9e0</span>b-<span class="number">520</span>d859cae80]            =&gt; Plots</span><br><span class="line">  LinearAlgebra [<span class="number">37e2</span>e46d-f89d-<span class="number">539</span>d-b4ee-<span class="number">838</span>fcccc9c8e]    =&gt; LinearAlgebra</span><br><span class="line">  ⋮                                                       =&gt; ⋮</span><br><span class="line"></span><br><span class="line">julia&gt; Plots.plot</span><br><span class="line">plot (generic <span class="keyword">function</span> with <span class="number">3</span> methods)</span><br></pre></td></tr></table></figure><h2 id="編譯到預設位置">編譯到預設位置</h2><p>Julia 在系統中有 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它預設會在 Julia 啟動時載入，我們可以利用預先編譯好的函式庫來取代它，就可以不用參數的情況下自動載入。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_sysimage([:Debugger, :OhMyREPL]; replace_default=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>將 <code>sysimage_path</code> 換成 <code>replace_default=true</code>，來將編譯的函式庫取代 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它會將原本的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 備份到 sys.so.backup，並將編譯好的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 寫入。</p><h2 id="增量編譯（incremental-compilation）">增量編譯（incremental compilation）</h2><p>sysimage 可以進行增量編譯。增量編譯是指既有的函式並不會重新編譯，只會編譯那些新加入的函式。如果已經有 sysimage，那麼下次呼叫 <code>create_sysimage</code> 時，只會編譯新加入的部份，並且用新的函式庫檔案取代舊的。</p><p>如果你想要關閉這個功能，那需要加入 <code>incremental=false</code> 來關閉增量編譯，這樣就會編譯一個全新的函式庫。</p><h2 id="利用套件的測試程式碼做編譯">利用套件的測試程式碼做編譯</h2><p>一般而言，在動態語言中，我們無法編譯所有可能的方法，取而代之的是，我們可以<strong>儘可能</strong>編譯更多方法。編譯更多方法越可能可以避免 Julia 啟動 JIT 在執行時期去編譯新的方法。這時候我們可以利用套件中的測試程式碼，當套件中自帶的測試程式碼，如果覆蓋率夠高，那麼就可以有越完善的編譯。這時候我們可以在編譯之前執行測試來促使 JIT 編譯各種方法。</p><p>我們可以利用以下程式碼來執行測試，並促使 JIT 進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Plots</span><br><span class="line">include(joinpath(pkgdir(Plots), <span class="string">"test"</span>, <span class="string">"runtests.jl"</span>))</span><br></pre></td></tr></table></figure><p>套件的測試期間常常會有其他的相依套件，缺乏相依套件都會使測試失敗。需要不斷執行測試，並且檢查及安裝缺失的相依套件。</p><p>等測試都執行完成了，就可以進行套件編譯了。</p><h2 id="編譯被使用的方法">編譯被使用的方法</h2><p>如果需要編譯被使用的方法，例如在特定腳本被使用到，這時候我們需要更細緻的編譯方式。我們需要知道哪些方法在腳本當中被使用到，這時候我們可以在啟動 Julia 時加入 <code>--trace-compile=precompile.jl</code>。<code>--trace-compile</code> 會讓 Julia 紀錄下哪些方法有被編譯過，並且輸出在 precompile.jl 檔案中紀錄下來。</p><p><code>--trace-compile</code> 會紀錄哪些方法需要預編譯（precompilation）。例如執行 <code>julia --trace-compile=precompile.jl -e '1+1'</code> 會得到一個 precompile.jl 檔案，其中測試了 <code>1+1</code> 的預編譯，並且紀錄下來。因此，會在 precompile.jl 檔案中看到以下內容：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.similar), <span class="built_in">Array</span>&#123;Base.Grisu.Bignums.Bignum, <span class="number">1</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.length), <span class="built_in">Array</span>&#123;Base.Grisu.Bignums.Bignum, <span class="number">1</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.deepcopy_internal), <span class="built_in">Any</span>, Base.IdDict&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.deepcopy_internal), <span class="built_in">Array</span>&#123;<span class="built_in">UInt32</span>, <span class="number">1</span>&#125;, Base.IdDict&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>這就是 <code>--trace-compile</code> 將需要預編譯的方法輸出的結果。</p><p>我們可以將這些結果放到 <code>create_sysimage</code> 中。可以在 <code>create_sysimage</code> 加入關鍵字參數 <code>precompile_statements_file=&quot;precompile.jl&quot;</code>，並且指定剛剛輸出的預編譯紀錄檔 precompile.jl。它會讓 Julia 根據紀錄檔中所需要使用到的方法進行編譯。如此就可以編譯在腳本當中被使用到的方法了！</p><p>Ref: <a href="https://julialang.github.io/PackageCompiler.jl/dev/sysimages/" target="_blank" rel="noopener">https://julialang.github.io/PackageCompiler.jl/dev/sysimages/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（&lt;code&gt;using&lt;/code&gt;）過於冗長。&lt;/p&gt;
&lt;p&gt;Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。&lt;/p&gt;
&lt;p&gt;為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。&lt;/p&gt;
&lt;p&gt;PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。&lt;/p&gt;
&lt;p&gt;近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia 的多重分派</title>
    <link href="https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/"/>
    <id>https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/</id>
    <published>2020-04-01T15:27:42.000Z</published>
    <updated>2020-04-01T15:27:42.500Z</updated>
    
    <content type="html"><![CDATA[<p>今天來談談 Julia 的多重分派（multiple dispatch）。</p><p>很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。</p><p>在現今的物件導向程式設計當中，我們會將函式歸納到某個類別底下成為其類別的方法，而這個方法就屬於這個類別。</p><h2 id="多重分派-v-s-單一分派">多重分派 v.s. 單一分派</h2><p>這樣的觀點就是單一分派的精神，單一分派是指一個方法的呼叫，要如何決定呼叫的是哪一個方法實作呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(x)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure><p>像以上的 python 程式碼，<code>foo.abc(x)</code> 就是去呼叫 <code>Foo</code> 的方法，而 <code>bar.abc(x)</code> 則是去呼叫 <code>Bar</code> 的方法。</p><p>也就是說，方法的呼叫是由第一個參數所決定的，這邊要注意的是第一個參數並不是 <code>x</code>，而是 <code>self</code> 喔！也就是物件本身！</p><p>相對於單一分派，多重分派是指他會參考所有的參數型別及其組合來決定到底要呼叫哪一個方法。</p><p>所以我們也有了更細緻的選擇。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(foo::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(foo::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><p>當第一個參數型別是 <code>Foo</code> 時，就回傳字串，而當第一個參數型別是 <code>Bar</code> 時，就回傳整數。</p><p>我們可以去區別，當 <code>x</code> 已經是整數或是字串時就不用去處理它，直接回傳即可。若是有不同型別時，個別處理。</p><p>這邊我們並沒有使用到第一個型別的參數，在 Julia 裡可以省略變數本身，只寫型別。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><h2 id="多重分派的自由與限制">多重分派的自由與限制</h2><p>使用多重分派可以讓語言有更細緻的定義，也有更高的自由度。</p><p>我們可以看看以下的例子，這邊使用了常常被使用的 null pattern：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push!(ls::List, obj::NullObject) = ls</span><br><span class="line"></span><br><span class="line">psuh!(ls::List, obj::Object) = push!(ls.array, obj)</span><br></pre></td></tr></table></figure><p>當我要去表示一類物件，我們會實作 <code>Object</code>，但往往我們會想要表示一個為空的物件，這時候我們就會有一個 <code>NullObject</code> 來表達這件事。</p><p>當我們想要將一個 <code>Object</code> 放到 <code>List</code> 中的時候，我們會實作 <code>push!</code>，然而當一個 <code>NullObject</code> 被放入 <code>List</code> 的時候，我們並不需要真的做什麼樣的動作。實作就會如同上面的程式碼。</p><p>相對在 python 或是一般物件導向語言當中，我們就會看到以下的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> type(obj) == NullObject:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">elif</span> type(obj) == Object:</span><br><span class="line">            self.array.append(obj)</span><br></pre></td></tr></table></figure><p>我們需要自己去判斷接收進來的參數型別，然後進一步做處理。這樣的話會讓我們的程式碼充滿 if-else，當條件一多時，會變得相當難以閱讀及修改。</p><p>使用多重分派並不是只有優點，他也有缺點。多重分派會引入模糊性（ambiguity）。</p><p>考慮以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b) = a</span><br><span class="line">foo(a, b::B) = b</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br></pre></td></tr></table></figure><p>請問 <code>foo(a, b)</code> 該呼叫哪一個方法呢？</p><p>這樣的呼叫在 Julia 會產生錯誤，也就是編譯器不知道該呼叫哪一個方法。</p><p>這時候編譯器會建議修改的方式，就是定義一個更明確的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b::B)</span><br></pre></td></tr></table></figure><h2 id="應用情境">應用情境</h2><p>我們來寫個簡單的剪刀石頭布遊戲！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Paper <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Scissor <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Stone <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們分別有三個型別分別代表剪刀石頭布。</p><p>接下來我們定義運算，先定義贏的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">play(::Paper, ::Stone) = <span class="number">1</span></span><br><span class="line">play(::Scissor, ::Paper) = <span class="number">1</span></span><br><span class="line">play(::Stone, ::Scissor) = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>當雙方是相同時就平手：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(::T, ::T) <span class="keyword">where</span> &#123;T&#125; = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>這邊我們利用了 Julia 的參數化方法，當兩個有相同的型別時，就回傳 0。</p><p>最後，是輸的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(a, b) = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>也就是，如果沒有符合以上的狀況的方法呼叫，就會落到這個狀況來，所以這邊我們允許最廣義的 <code>Any</code> 型別。</p><p>希望大家可以經由這個簡單的例子來理解 Julia 的多重分派有多好用，甚至是搭配上參數化方法根本是逆天阿！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天來談談 Julia 的多重分派（multiple dispatch）。&lt;/p&gt;
&lt;p&gt;很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。&lt;/p&gt;
&lt;p&gt;在現今的物件導向程式設計當中，我們會將函式歸納
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
</feed>
