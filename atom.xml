<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Maker</title>
  
  <subtitle>Love Math, Science, Biology, Computer science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuehhua.github.io/"/>
  <updated>2020-03-29T15:12:54.590Z</updated>
  <id>https://yuehhua.github.io/</id>
  
  <author>
    <name>Yueh-Hua Tu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Julia 的閉包（closure）效能</title>
    <link href="https://yuehhua.github.io/2020/03/29/julia-closure-performance/"/>
    <id>https://yuehhua.github.io/2020/03/29/julia-closure-performance/</id>
    <published>2020-03-29T15:12:13.000Z</published>
    <updated>2020-03-29T15:12:54.590Z</updated>
    
    <content type="html"><![CDATA[<p>前一陣子意外看到<a href="https://quinnj.home.blog/2019/12/31/byo-closures-for-performance/" target="_blank" rel="noopener">這篇文章</a>，當中 JuliaData 的核心開發者描述他在開發過程中遇到的問題。他撞到一個有名的效能問題，這個效能瓶頸與閉包（closure）有關。</p><a id="more"></a><h2 id="閉包">閉包</h2><p>閉包（closure）在眾多語言當中都有支援，他是指函式中會包含外部的變數，像是將「變數」關進函式當中一樣。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">function</span> foo(a)</span><br><span class="line">           <span class="keyword">return</span> x + a</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">foo (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; foo(<span class="number">5</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>如以上函式 <code>foo</code> 就將 <code>x</code> 封進函式當中，所以運算結果就如同程式碼呈現。</p><p>一旦外部的變數改變，而運算的結果也會跟著變動。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo(<span class="number">5</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>而這樣有什麼效能問題呢？</p><h2 id="效能問題">效能問題</h2><p>我們可以來測測看這樣的運算需要多久的時間？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> BenchmarkTools</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@btime</span> foo(<span class="number">5</span>)</span><br><span class="line">  <span class="number">25.731</span> ns (<span class="number">0</span> allocations: <span class="number">0</span> bytes)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>這樣的時間對於一個整數加法來說算久嗎？我們需要一個對照組：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">function</span> bar(a)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">2</span> + a</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">bar (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; bar(<span class="number">5</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@btime</span> bar(<span class="number">5</span>)</span><br><span class="line">  <span class="number">0.021</span> ns (<span class="number">0</span> allocations: <span class="number">0</span> bytes)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>我們模擬不用閉包的狀況，單純計算兩個整數相加的狀況，所以直接將整數寫在函式當中。<br>會發現其實整數加法非常快，連 0.1 ns 都不到。這樣的話跟使用閉包的效能有相當大的差異，約是 1225 倍！</p><h2 id="分析">分析</h2><p>那面對這樣的效能問題的原因是什麼呢？<br>追根究底，這樣的效能問題來自 type instability。<br>也就是被封進函式的變數無法進行型別推斷（type inference），導致的效能低落。<br>我們用 <code>@code_warntype</code> 來看看，他可以顯示在函式的哪一個部份型別推斷的結果仍然是 <code>Any</code> 或 <code>Union{}</code>，這會造成效能問題。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="meta">@code_warntype</span> foo(<span class="number">5</span>)</span><br><span class="line">Variables</span><br><span class="line">  <span class="comment">#self#::Core.Compiler.Const(foo, false)</span></span><br><span class="line">  a::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">Body::<span class="built_in">Any</span></span><br><span class="line"><span class="number">1</span> ─ %<span class="number">1</span> = (Main.x + a)::<span class="built_in">Any</span></span><br><span class="line">└──      <span class="keyword">return</span> %<span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@code_warntype</span> bar(<span class="number">5</span>)</span><br><span class="line">Variables</span><br><span class="line">  <span class="comment">#self#::Core.Compiler.Const(bar, false)</span></span><br><span class="line">  a::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">Body::<span class="built_in">Int64</span></span><br><span class="line"><span class="number">1</span> ─ %<span class="number">1</span> = (<span class="number">2</span> + a)::<span class="built_in">Int64</span></span><br><span class="line">└──      <span class="keyword">return</span> %<span class="number">1</span></span><br></pre></td></tr></table></figure><p>我們可以很明顯看到 <code>foo(5)</code> 的型別推斷結果是 <code>Body::Any</code>，而 <code>bar(5)</code> 則是 <code>Body::Int64</code>。<br>代表兩者會回傳不同的型別的結果。在 <code>foo(5)</code> 中並不確定 <code>Main.x</code> 是什麼樣的型別，由於這個變數所存在的作用域（scope）並不在這個函式中，所以無法推斷其型別。相對 <code>bar(5)</code> 就好很多。</p><h2 id="解法">解法</h2><p>知道原因了，那我們有沒有什麼解法呢？<br>解法有兩種：</p><h3 id="使用常數">使用常數</h3><p>使用常數來定義要被封進函式的變數，由於常數本身的型別是固定的，所以編譯器就有辦法進行型別推斷。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">const</span> x = <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo(<span class="number">5</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@btime</span> foo(<span class="number">5</span>)</span><br><span class="line">  <span class="number">0.020</span> ns (<span class="number">0</span> allocations: <span class="number">0</span> bytes)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@code_warntype</span> foo(<span class="number">5</span>)</span><br><span class="line">Variables</span><br><span class="line">  <span class="comment">#self#::Core.Compiler.Const(foo, false)</span></span><br><span class="line">  a::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">Body::<span class="built_in">Int64</span></span><br><span class="line"><span class="number">1</span> ─ %<span class="number">1</span> = (Main.x + a)::<span class="built_in">Int64</span></span><br><span class="line">└──      <span class="keyword">return</span> %<span class="number">1</span></span><br></pre></td></tr></table></figure><p>我們可以看到使用常數後，執行時間變得非常接近 <code>bar</code> 了，而 <code>@code_warntype</code> 也顯示可以進行型別推斷。<br>可是我們不一定能總是把要封進閉包的變數設定為常數阿，這樣會非常不方便。</p><h3 id="使用-let">使用 <code>let</code></h3><p>另一個作法是使用 <code>let</code>，<code>let</code> 可以創造出一個作用域，在這個作用域當中被宣告的變數會存在。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; foo = <span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">       a -&gt; x + a</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="comment">#3 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@code_warntype</span> foo(<span class="number">5</span>)</span><br><span class="line">Variables</span><br><span class="line">  <span class="comment">#self#::var"#3#4"&#123;Int64&#125;</span></span><br><span class="line">  a::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">Body::<span class="built_in">Int64</span></span><br><span class="line"><span class="number">1</span> ─ %<span class="number">1</span> = Core.getfield(<span class="comment">#self#, :x)::Int64</span></span><br><span class="line">│   %<span class="number">2</span> = (%<span class="number">1</span> + a)::<span class="built_in">Int64</span></span><br><span class="line">└──      <span class="keyword">return</span> %<span class="number">2</span></span><br><span class="line"></span><br><span class="line">julia&gt; <span class="meta">@btime</span> foo(<span class="number">5</span>)</span><br><span class="line">  <span class="number">19.774</span> ns (<span class="number">0</span> allocations: <span class="number">0</span> bytes)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>這個作法就是有個 <code>let</code> 區塊，並且定義在這個作用域中 <code>x = 2</code>。然後我在這個區塊中定義了匿名函式，匿名函式最後指定給 <code>foo</code>，這樣我就可以把 <code>foo</code> 當成一般的函式呼叫了。<br>我們可以看到有成功的型別推斷，但是執行時間似乎沒有好太多。這邊又牽涉到 Julia 底層的作用機制了。（攤手<br>今天我們的解析就先到這邊為止，感謝大家閱讀。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一陣子意外看到&lt;a href=&quot;https://quinnj.home.blog/2019/12/31/byo-closures-for-performance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;這篇文章&lt;/a&gt;，當中 JuliaData 的核心開發者描述他在開發過程中遇到的問題。他撞到一個有名的效能問題，這個效能瓶頸與閉包（closure）有關。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>julia v1.4 釋出</title>
    <link href="https://yuehhua.github.io/2020/03/24/julia-v1-4-release/"/>
    <id>https://yuehhua.github.io/2020/03/24/julia-v1-4-release/</id>
    <published>2020-03-24T04:02:05.000Z</published>
    <updated>2020-03-24T04:02:05.904Z</updated>
    
    <content type="html"><![CDATA[<p>Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。<br>底下新功能後面會有括弧，附註相關的實作程式碼。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><h3 id="使用者功能">使用者功能</h3><ul><li><code>import</code> 允許符號，例如 <code>import Base.:+</code>。(#33158)</li><li>允許使用 <code>a[begin]</code> 來存取 <code>a</code> 的首位元素。首位元素的索引是由 <code>firstindex(a)</code> 計算得出。(#33946)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; x[<span class="keyword">begin</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>值可以藉由 <code>$</code> 內插到 <code>@async</code> 及 <code>@spawn</code> 中，它會將值直接複製一份到閉包（closure）中。(#33119)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>結構 <code>struct</code> 當中，所有位元（isbits）或是位元聯集（isbitsunion）的欄位（fields）都會儲存為陣列的元素。(#32448)</li></ul><p>以前在 Julia 的結構當中，只有所有欄位都有相同的型別，而且型別都是原始型別時，Julia 底層會將他們封裝到一個陣列中，如此可以加速。在 v1.4 版後放寬了這樣的限制，讓有所有位元欄位都儲存為陣列。</p><h2 id="新功能">新功能</h2><ul><li>Iterators 模組中有 <code>accumulate</code> 實作。(#34033)</li></ul><p>Jeff 頗驚訝，之前怎麼沒有這個功能XD</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; iter = Iterators.accumulate(+, x)</span><br><span class="line">Base.Iterators.Accumulate&#123;typeof(+),<span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;&#125;(+, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; foreach(println, iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>功能與 <code>Base.accumulate</code> 雷同，但是屬於 lazy evaluation。</p><ul><li><code>evalpoly</code> 可以用來計算多項式函數，例如 <code>evalpoly(x, (p1, p2, p3))</code>。(#32753)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; evalpoly(<span class="number">5</span>, (<span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>相當於計算 $p(5) = 10 + 3\times5 + 1\times5^2$。</p><ul><li>允許複合函數（function composition）<code>∘(f, g, h) = f ∘ g ∘ h</code>，以及解開 <code>∘(fs...)</code>，當中 <code>fs</code> 可以是 Iterable 的函數集合。(#33568)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; f(x) = x + <span class="number">1</span></span><br><span class="line">f (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; g(x) = <span class="number">2</span>x</span><br><span class="line">g (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; F = f∘g</span><br><span class="line"><span class="comment">#64 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; F(<span class="number">5</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="新支援">新支援</h2><ul><li><code>gcd</code>、<code>lcm</code> 及 <code>gcdx</code> 支援 <code>Rational</code> 型別的參數。(#33910)</li><li><code>splitpath</code> 支援任何 <code>AbstractString</code> 型別，然而以前只支援 <code>String</code> 的路徑。(#33012)</li><li><code>filter</code> 可以作用在 <code>Tuple</code> 上。(#32968)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。&lt;br&gt;
底下新功能後面會有括弧，附註相關的實作程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>從 iterator 及 generator 到 iterable</title>
    <link href="https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/"/>
    <id>https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/</id>
    <published>2020-03-01T06:31:49.000Z</published>
    <updated>2020-03-05T16:32:51.101Z</updated>
    
    <content type="html"><![CDATA[<p>今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 <code>in</code> 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？</p><a id="more"></a><p>很基本的作法是去實作一個設計模式（design pattern）中的 iterator，假設我們要迭代一個陣列裡的元素，iterator 有別於陣列本身，是另外一個物件。Iterator 可以提供你一個介面，例如 <code>next()</code>，讓你可以取得陣列裡的下一個元素。</p><p>像這樣的方式很常見也很簡單可以實作，在 Julia 裡就像這樣：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> ArrayIterator</span><br><span class="line">    array::<span class="built_in">Array</span></span><br><span class="line">    index::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">    ArrayIterator(array::<span class="built_in">Array</span>) = new(array, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">has_next(iter::ArrayIterator) = (iter.index &lt; length(iter.array))</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> next(iter::ArrayIterator)</span><br><span class="line">    x = iter.array[iter.index]</span><br><span class="line">    iter.index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">2</span>:<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; iter = ArrayIterator(v);</span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>各位可以看到 iterator 一般都會實作 <code>has_next()</code> 及 <code>next()</code> 函式，是用來確認是否有下一個元素存在及取得下一個元素。Iterator 中會包含陣列本身，也就是想要迭代的集合本身，還有一個 <code>index</code> 會指向目前的元素，並在取得元素之後移往下一個。</p><p>Iterator 是一個物件，它需要一個已經存在的集合來作為它迭代的集合。這代表這個集合必須事先存在，如果這個集合很大，那就會佔去不少記憶體空間。有沒有什麼方法可以不需要集合就可以迭代的呢？Generator 是一個方式。</p><p>Generator，顧名思義，它會在你取得下一個元素的時候產生出來，並不會事先計算，所以集合也不會存在。Julia 的 generator 很好撰寫，如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (i^<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這就是一個會產生 1 到 10 數字的 generator。Generator 也可以被放到 for 迴圈裡被迭代，但唯一不同的是，它並不佔記憶體空間，只需要即時的計算即可。</p><p>Julia 目前提供的方式稱為 Iterable，只要有實作 <code>iterate()</code> 這個 API 的就稱為 Iterable。像以下例子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Character</span><br><span class="line">    start::<span class="built_in">Char</span></span><br><span class="line">    length::<span class="built_in">Int</span></span><br><span class="line">    Character() = new(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(char::Character, (el, i)=(char.start, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> i &lt; char.length</span><br><span class="line">        <span class="keyword">return</span> (el, (el+<span class="number">1</span>, i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.length(char::Character) = char.length</span><br><span class="line">Base.eltype(::Character) = <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p><code>iterate()</code> 的輸入是「狀態」，輸出是下一個狀態，而狀態包含兩個物件：要迭代的元素以及順序。因此，會看起來像是這個樣子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(el1, (el2, i+<span class="number">1</span>)) = iterate(iter, (el1, i))</span><br></pre></td></tr></table></figure><p>特別要說明的是，在輸出的狀態中，需要帶有目前元素的資訊 <code>(el1, (el2, i+1))</code>。如果要結束迴圈，那就回傳 <code>nothing</code>。我們就可以來世試看這個可以迭代輸出 ASCII 碼的 Iterable。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; c = Character()</span><br><span class="line">Character(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c, (<span class="string">'B'</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="string">'C'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> c</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br><span class="line">F</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣可以有 generator 的好處，而且本身也是一個 iterator。它不需要是一個物件，只要有實作 <code>iterate()</code> 這個 API 的物件就可以使用，所以我們還可以拿來這樣用。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> IterableNumber</span><br><span class="line">    start::<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.iterate(iter::IterableNumber, (el, i)=(iter.start, <span class="number">0</span>)) = i &lt; <span class="literal">Inf</span> ? (el, (el+<span class="number">1</span>, i+<span class="number">1</span>)) : <span class="literal">nothing</span></span><br></pre></td></tr></table></figure><p>這是一個可以自定義起點的可迭代數字，數字可以持續到無限大。你得手動把它停下來！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; iter = IterableNumber(<span class="number">0</span>)</span><br><span class="line">IterableNumber(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> i <span class="keyword">in</span> iter</span><br><span class="line">           println(i)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或是你想做個 sliding window：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SlidingWindow</span><br><span class="line">    vec::<span class="built_in">Vector</span></span><br><span class="line">    n::<span class="built_in">Int</span></span><br><span class="line">    start::<span class="built_in">SubArray</span></span><br><span class="line"></span><br><span class="line">    SlidingWindow(vec::<span class="built_in">Vector</span>, n) = new(vec, n, view(vec, <span class="number">1</span>:n))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(iter::SlidingWindow, (el, i)=(iter.start, <span class="number">1</span>))</span><br><span class="line">    <span class="literal">e</span> = i + iter.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">e</span> &lt;= length(iter.vec)</span><br><span class="line">        <span class="keyword">return</span> (el, (view(iter.vec, i:<span class="literal">e</span>), i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊用 <code>view(iter.vec, i:e)</code> 做取值的方式，比起用 <code>iter.vec[i:e]</code> 取值來的快很多。<code>iter.vec[i:e]</code> 這種方式會造出一個新的陣列，而 view 不會。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; sw = SlidingWindow(v, <span class="number">5</span>)</span><br><span class="line">SlidingWindow([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>  …  <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>], <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> sw</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這邊介紹了三種迭代的方法，而 iterable 則是目前由 Julia 官方支援的主流方式。除了可以迭代數字以外還可以有其他用途，甚至可以迭代直到無限大的數字。Sliding window 這樣的東西在計算上或是深度學習上是很實用的結構！是不是覺得 Julia 越來越像 functional language 了XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 &lt;code&gt;in&lt;/code&gt; 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>One-way ANOVA and sum of squares</title>
    <link href="https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/"/>
    <id>https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/</id>
    <published>2020-02-09T16:01:59.000Z</published>
    <updated>2020-03-09T17:07:49.402Z</updated>
    
    <content type="html"><![CDATA[<p><strong>An</strong>alysis <strong>o</strong>f <strong>va</strong>riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms <strong>explained variance</strong> (or <strong>between-group variance</strong> in categorical factor) and <strong>unexplained variance</strong> (or <strong>within-group variance</strong> in categorical factor).</p><a id="more"></a><h2 id="Sum-of-squares">Sum of squares</h2><p>Sum of squares come from the concept of calculating the (squared Euclidean) distance among data. Let’s consider the total sum of squares $SS_{total}$.</p><p>$$<br>SS_{total} = \sum_i (y_i - \bar{y})^2<br>$$</p><p>$y_i$ represents the true data value, $\bar{y}$ represents the mean of data $y_i$. We can get variance from $SS_{total}$ by dividing the <strong>degree of freedom</strong> ($df$).</p><p>$$<br>\begin{align}<br>Var[Y] &amp;= \frac{SS_{total}}{df} \\<br>&amp;= \frac{1}{n-1} \sum_i (y_i - \bar{y})^2<br>\end{align}<br>$$</p><p>The equation above shows the relation between sum of square and variance.</p><p>We always attempt to model the phonomena from data. Constructing the hypothesis or model and validate our hypothesis by testing their siginificant. If our model is true, then model must catch some variance and extract information from data for us. If the model is not true, model catch less variance just as the noise does.</p><p>So, we defined two kinds of sum of squares to measure how much variance is caught by model or not. We usually use a regression to model our data, so we have regression sum of square $SS_{reg}$, which represents the amount of sum of square explained by model. Sum of square other than regression sum of square is left as residual sum of square $SS_{res}$, which represents the amount of sum of square unexplained by model.</p><p>$$<br>SS_{reg} = \sum_i (\hat{y}_i - \bar{y})^2<br>$$</p><p>$\hat{y}_i$ represents the prediction value given by the model. If the sum of square is modeled, then the distance between the mean and the model prediction is explained by model.</p><p>$$<br>SS_{res} = \sum_i (y_i - \hat{y}_i)^2<br>$$</p><p>If the sum of square is not modeled, then the distance between the data and the model prediction is left unexplained as noise.</p><p>There is a relationship amoung them. We are going to proof it. However, the tools are not enough to prove it. We need the following two equations:</p><p>$$<br>\sum_i e_i = \sum_i (y_i - \hat{y}_i) = 0<br>$$</p><p>$$<br>\sum_i \hat{y}_i e_i = 0<br>$$</p><p>We start from $SS_{total}$.</p><p>$$<br>\begin{align}<br>SS_{total} &amp;= \sum_i (y_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i + \hat{y}_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + (\hat{y}_i - \bar{y})^2 + 2(y_i - \hat{y}_i)(\hat{y}_i - \bar{y}) \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + \sum_i (\hat{y}_i - \bar{y})^2 + 2 \sum_i \hat{y}_i(y_i - \hat{y}_i) - 2\bar{y} \sum_i (y_i - \hat{y}_i) \\<br>\end{align}<br>$$</p><p>Now you may see $SS_{reg}$ and $SS_{res}$ in the formula.</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res} + 2 \sum_i \hat{y}_i e_i - 2\bar{y} \sum_i e_i<br>$$</p><p>Due to the fact that the last two summation terms are zero. So we have:</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res}<br>$$</p><p>So now we have it! If we face a dataset, assuming that we know nothing about the data, we could only measure the mean and variance about the data.</p><p>Mean tells us the “location” about the data. If I told you the average height of whole people in the class, you prabably could have a idea or even guess <em>where data locate</em>.</p><p>Variance tell us the “range”, or formally “dispersion”, about the dataset. If the variance is large, we have high uncertainty about the data. Sometimes, we even know the mean, we still cannot guess the answer accurately, because we have no idea about <em>what is the scale of data</em>. In some sense, variance is associated with sum of squares(, and it truely is).</p><p>If we know the model in advance, we know the inner structure of phenomena and how the data is generated. That’s why we usually want to model things. If we introduce a model, it can help us extracting the inner structure (or information) from uncertainty. It reduce the uncertainty and give us information.</p><p>The total sum of squares act as the total uncertainty we face, and it can further be decoupled into two parts. If we have a model to help us, model extracts information and represents as regression sum of squares. The rest of uncertainty remains as <strong>residuals</strong>.</p><h2 id="One-way-ANOVA">One-way ANOVA</h2><p>ANOVA is a way to decouple sum of squares so that we can quantify how well the model is.</p><p>We can further make the ANOVA table as follow:</p><p>$$<br>\begin{array}{l c c c}<br>\ &amp; SS &amp; df &amp; MS &amp; F \\<br>\hline<br>model &amp; SS_{reg} &amp; k-1 &amp; MS_{reg} &amp; \frac{MS_{reg}}{MS_{res}} \\<br>error &amp; SS_{res} &amp; n-k &amp; MS_{res} &amp; \\<br>\hline<br>total &amp; SS_{total} &amp; n-1 &amp; MS_{total} &amp; \\<br>\end{array}<br>$$</p><p>Fill in the corresponding cell. Degree of freedom is about how many parameters you used to estimate your model. However, it is not always the case, you may want to read statistics textbook for some theoretical reasons. $k$ is the random variables you used in your model.</p><p>$$<br>MS_{reg} = \frac{SS_{reg}}{k-1} \\<br>MS_{res} = \frac{SS_{res}}{n-k}<br>$$</p><p>$MS$ means <em>mean of squares</em>, which it $SS$ divided by $df$. Moreover, we can calculate the F statistics for F test and the F test itself is so called <strong>one-way ANOVA</strong>.</p><p>$$<br>F = \frac{\text{explained variance}}{\text{unexplained variance}}<br>$$</p><p>F-value has its own meaning. It measures <em>how much variance is caught by our model</em> (or $MS_{reg}$), and it is a relative measurement, so it is divided by <em>the variance not caught by our model</em> (or $MS_{res}$). In aonother way, the model can <strong>explained</strong> part of variance, and the rest is left <strong>unexplained</strong>.</p><p>If the model we used is not something like linear regression, rather, we separate data into different categories. We used the following formula:</p><p>$$<br>F = \frac{\text{between-group variance}}{\text{within-group variance}}<br>$$</p><p>We could further test if the F-value is significant or not.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;An&lt;/strong&gt;alysis &lt;strong&gt;o&lt;/strong&gt;f &lt;strong&gt;va&lt;/strong&gt;riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms &lt;strong&gt;explained variance&lt;/strong&gt; (or &lt;strong&gt;between-group variance&lt;/strong&gt; in categorical factor) and &lt;strong&gt;unexplained variance&lt;/strong&gt; (or &lt;strong&gt;within-group variance&lt;/strong&gt; in categorical factor).&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>Relationship between variance and pairwise distance</title>
    <link href="https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/"/>
    <id>https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/</id>
    <published>2020-02-09T14:28:52.000Z</published>
    <updated>2020-03-06T07:55:43.094Z</updated>
    
    <content type="html"><![CDATA[<p>Random variable $X$, we have the variance</p><p>$$<br>\begin{align}<br>Var[X] &amp;= \mathbb{E}[(X - \mu)^2] \\<br>&amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2<br>\end{align}<br>$$</p><a id="more"></a><p>Pairwise (squared Euclidean) distance will be<br>Andrew Gerrand<br>$$<br>\begin{align}<br>\sum_{i \ne j} d(x_i, x_j) &amp;= \sum_{i=1}^n \sum_{j=i+1}^n (x_i - x_j)^2 \\<br>&amp;= \sum_{i=1}^n \sum_{j=i+1}^n ((x_i - \mu) - (x_j - \mu))^2 \\<br>&amp;= n \sum_{i=1}^n (x_i - \mu)^2 \\<br>&amp;= n^2 \mathbb{E}[(X - \mu)^2] \\<br>&amp;= n^2 Var[X]<br>\end{align}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Random variable $X$, we have the variance&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;
\begin{align}&lt;br&gt;
Var[X] &amp;amp;= \mathbb{E}[(X - \mu)^2] \\&lt;br&gt;
&amp;amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2&lt;br&gt;
\end{align}&lt;br&gt;
$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>程式設計師勝任程度</title>
    <link href="https://yuehhua.github.io/2019/12/11/programmer-competency/"/>
    <id>https://yuehhua.github.io/2019/12/11/programmer-competency/</id>
    <published>2019-12-11T07:08:58.000Z</published>
    <updated>2019-12-11T07:08:58.297Z</updated>
    
    <content type="html"><![CDATA[<p>先前看到了 <a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a>，所以就自己幫自己評比一下。</p><ul><li>Computer Science<ul><li>data structures: level 3</li><li>algorithms: level 3</li><li>systems programming: level 2</li></ul></li><li>Software Engineering<ul><li>source code version control: level 3</li><li>build automation: level 2</li><li>automated testing: level 2</li></ul></li><li>Programming<ul><li>problem decomposition: level 3</li><li>systems decomposition: level 2</li><li>communication: level 3</li><li>code organization within a file: level 2</li><li>code organization across files: level 2</li><li>source tree organization: level 3</li><li>code readability: level 3</li><li>defensive coding: level 2</li><li>error handling: level 1</li><li>IDE: level 2</li><li>API: level 1</li><li>frameworks: level 3</li><li>requirements: level 2</li><li>scripting: level 2</li><li>database: level 2</li></ul></li><li>Experience<ul><li>languages with professional experience: level 1~2 (familiar with OO language with functional patterns)</li><li>platforms with professional experience: level 2</li><li>years of professional experience: level 2</li><li>domain knowledge: level 2</li></ul></li><li>Knowledge<ul><li>tool knowledge: level 2</li><li>languages exposed to: level 2~3 (used Prolog before)</li><li>codebase knowledge: level 3 (I started a project before)</li><li>knowledge of upcoming technologies: level 2</li><li>platform internals: level 1~2 (not sure)</li><li>books: level 2 (actually used and read books)</li><li>blogs: level 3 (but not regularly update blog posts)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先前看到了 &lt;a href=&quot;http://sijinjoseph.com/programmer-competency-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programmer Competency Matrix&lt;/a&gt;，所以就自
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Name binding 與 dispatch</title>
    <link href="https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/"/>
    <id>https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/</id>
    <published>2019-12-01T02:49:40.000Z</published>
    <updated>2019-12-01T02:49:40.195Z</updated>
    
    <content type="html"><![CDATA[<p>Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。</p><p>Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。</p><a id="more"></a><p>一般而言，當物件被去除綁定，那物件將會被垃圾回收（garbage collection）機制給處理掉。</p><p>Name binding 依據時間分為：</p><ul><li>Static binding (or early binding)：在編譯時期（compile time）進行綁定</li><li>Dynamic binding (or late binding)：在執行時期（runtime）進行綁定</li></ul><p>Static binding 的一個經典例子是 C 的函式呼叫，它在編譯時期就將函式內容綁定到識別符上，而無法在執行時期變更。</p><p>Dynamic binding 的一個相對應的例子則是 C++ 的虛擬方法呼叫，由於多型的機制，物件的型別無法在編譯時期得知，所以綁定會在執行時期處理。</p><p>在執行時期，如果識別符變更參考到其他的物件，我們稱為重新綁定（rebinding）。如果是變更識別符指向的物件本身，那麼我們稱為突變（mutation）。</p><p>在這邊提到多型的機制，就不得不去提 dispatch 的機制。一般在物件導向語言中以 dynamic dispatch 為主，表示在多型機制下，方法的選定是由第一個參數的型別來決定。</p><p>Dispatch 是個選擇的問題，而 binding 是個綁定的問題。選擇一定要發生在綁定後。</p><p>Dynamic dispatch 可以是 static binding 也可以是 dynamic binding，但是 dynamic binding 就只能在執行時間做 dispatch 了。</p><p>Dynamic dispatch 一般指 single dispatch，也就是由第一個參數的型別來決定要呼叫哪一個方法。相對也有 multiple dispatch，就會利用所有的參數型的排列組合來決定要呼叫哪一個方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。&lt;/p&gt;
&lt;p&gt;Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Compiler" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Compiler/"/>
    
    
  </entry>
  
  <entry>
    <title>魔術數字</title>
    <link href="https://yuehhua.github.io/2019/09/06/magic-numbers/"/>
    <id>https://yuehhua.github.io/2019/09/06/magic-numbers/</id>
    <published>2019-09-06T06:35:26.000Z</published>
    <updated>2019-09-06T06:35:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>很多人在寫程式的時候會有些壞習慣，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X &#x3D; rand(3, 4)</span><br><span class="line">for i &#x3D; 1:3</span><br><span class="line">    for j &#x3D; 1:4</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可能多數人看以上這段程式碼並沒有什麼特別的感覺，但是如果要維護的時候就會發現你突然不太理解這段程式碼。</p><p>有人知道這邊的 <code>3</code> 是什麼意思嗎？嗯…或許可以從上下文猜出來是陣列的列數的意思。</p><p>一旦要更改陣列的大小的時候勢必就要更改這些數字，甚至這些數字散落在程式碼的各個角落就會更加頭痛。</p><p>這些數字稱為魔術數字（magic numbers），因為沒有人知道他的意義是什麼！</p><h2 id="解法一：使用常數">解法一：使用常數</h2><p>如果這些數字很常被使用到，而且不會在程式中被變更，請使用常數，像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ROWS &#x3D; 3</span><br><span class="line">const COLUMNS &#x3D; 4</span><br><span class="line">X &#x3D; rand(ROWS, COLUMNS)</span><br><span class="line">for i &#x3D; 1:ROW</span><br><span class="line">    for j &#x3D; 1:COLUMNS</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如此，以後要更改陣列大小只需要更改常數即可，也讓程式碼的可讀性上升。</p><p>如果你的程式會更改到這些數字，那麼就用變數。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rows &#x3D; 3</span><br><span class="line">columns &#x3D; 4</span><br><span class="line">X &#x3D; rand(rows, columns)</span><br><span class="line">for i &#x3D; 1:rows</span><br><span class="line">    for j &#x3D; 1:columns</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="解法二：動態">解法二：動態</h2><p>如果陣列的大小不是事先知道的，或是需要動態取得，那麼可以用 <code>size</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1:size(X, 1)</span><br><span class="line">    for j &#x3D; 1:size(X, 2)</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如此可以用在未知大小的陣列上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多人在寫程式的時候會有些壞習慣，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 的 inbounds</title>
    <link href="https://yuehhua.github.io/2019/09/06/inbounds-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inbounds-in-julia/</id>
    <published>2019-09-06T03:17:13.000Z</published>
    <updated>2019-09-06T03:17:13.549Z</updated>
    
    <content type="html"><![CDATA[<p>有在做套件開發的開發者們應該不陌生 <code>@inbounds</code> 這個 macro，在很多現代程式語言中也有。</p><p>在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。</p><p>邊界檢查會檢查所存取的索引值是否在陣列的範圍內，但是這樣的檢查會有些微的效能損耗，尤其在迴圈內的情況更有可能被累積而放大，關於 Julia 的 邊界檢查可以參考官方文件 <a href="https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html" target="_blank" rel="noopener">Bounds checking</a>。</p><p>如果可以確定所存取的索引值一定在範圍內，我們就可以把邊界檢查給移除，以加速陣列的存取。如以下範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; rand(3, 4)</span><br><span class="line">@inbounds for i &#x3D; 1:size(A, 1)</span><br><span class="line">    println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>或是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; rand(3, 4)</span><br><span class="line">for i &#x3D; 1:size(A, 1)</span><br><span class="line">    @inbounds println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>@inbounds</code> 會將程式碼區塊中的邊界檢查給移除，可以參考 <code>@inbounds</code> 的<a href="https://docs.julialang.org/en/latest/base/base/#Base.@inbounds" target="_blank" rel="noopener">官方文件</a>。使用時必須注意存取的索引值，否則小則存取的值錯誤，大則可能導致程式崩潰。</p><p>先養成好的索引習慣，再考慮將效能提升，加入 <code>@inbounds</code>。相關的資訊也紀錄在官方的<a href="https://docs.julialang.org/en/latest/manual/performance-tips/#man-performance-annotations-1" target="_blank" rel="noopener">效能建議</a>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有在做套件開發的開發者們應該不陌生 &lt;code&gt;@inbounds&lt;/code&gt; 這個 macro，在很多現代程式語言中也有。&lt;/p&gt;
&lt;p&gt;在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。&lt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 中的行內函式（inline functions）</title>
    <link href="https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/</id>
    <published>2019-09-06T02:34:58.000Z</published>
    <updated>2019-09-06T03:16:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>剛好看到一些跟編譯器相關的議題，所以來紀錄一下。</p><p>在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。</p><p>最知名應該是 C 跟 C++ 的 <code>inline</code>。</p><p>Inline function 會在編譯時期直接將函式內容展開到程式碼中，不過展開與否是由編譯器決定的，<code>inline</code> 的標記只是告訴編譯器這個函式可以成為 inline function。</p><p><a href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank" rel="noopener">Inline expansion</a> 就是編譯時期會由編譯器執行的一個動作，看起來與 macro expansion 相似，但不同的是 macro expansion 是在前處理（preprocessing）時期做的，會直接展開在原始碼裡頭，而 inline expansion 則是在編譯時期做的，會在呼叫位點（call site）直接展開。</p><p>展開後編譯器便可以進行最佳化，執行時，就不需要做函式呼叫，也不會在 function stack 上多配置空間。一般使用在短小的函式上會有好處，在巨大的函式上使用不一定會有好處。然而過多的 inline function 反而可能造成過多的指令快取的消耗，造成反效果。</p><p>在 Julia 中，編譯器會自動偵測哪些函式可以被展開，會自動做 inline expansion。一般短小的函式會自動被編譯器判定要 inline，不過也可以由程式設計師自己指定哪些巨大函式可以 inline，可以參考[文件]](<a href="https://docs.julialang.org/en/v1.2/base/base/#Base.@inline" target="_blank" rel="noopener">https://docs.julialang.org/en/v1.2/base/base/#Base.@inline</a>)。</p><p>除了 <code>@inline</code> 以外，還有 <code>@noinline</code>。為了避免過多的 inline 反而傷害效能，也可以標記一些短小的函式不要 inline。</p><p>範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@inline function bigfunc(x)</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>相關技術：<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">Inline caching</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;剛好看到一些跟編譯器相關的議題，所以來紀錄一下。&lt;/p&gt;
&lt;p&gt;在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。&lt;/p&gt;
&lt;p&gt;最知名應該是 C 跟 C++ 的 &lt;code&gt;inline&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Inl
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>一次開源專案貢獻經驗</title>
    <link href="https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/"/>
    <id>https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/</id>
    <published>2019-07-08T14:08:04.000Z</published>
    <updated>2019-09-06T03:19:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。</p><p>我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。</p><a id="more"></a><p>起初，我只想用最簡單、直接的方式可以相容於原本的 API，並且達到我想要的功能。</p><p>後來專案的審查者希望我將較為底層的功能一起做調整，在不是很情願的情形下，我提出了我認為比較好的修改方案。畢竟動下去等於是整個架構要重新改掉了。</p><p>幾次的來回討論以及確認目標後，我確實需要把這部份的功能全部打掉重做。</p><p>其中包含審查者注意到 Julia 是個 column-major 的語言，原本的 row-major 的計算方式要改掉，以讓效能最大化。要如何處理 API 的更動，無非是加入 deprecation warning，然後還得考慮預設值的問題，在這邊審查者一直無法決定預設值該是什麼。</p><p>再來是，由 API 將資料收進來之後，該如何有效率而優雅地處理資料是個問題。有效率代表程式碼不能有多餘的動作，包含多餘的記憶體耗用、轉置與否。優雅代表 API 底下設計的函式之間的轉換跟呼叫也需要保持簡潔跟可讀性，如函數式程式設計般簡潔，如物件導向般可讀性，不能有重複的程式碼（Don’t repeat yourself, DRY）。像是在 API 下層還要繼續設計 API 一般，直到最底層演算法都要保持這樣的原則，你不會有機會做骯髒的手腳。</p><p>來來回回在 PR 上的討論，一則都會有十行以上的文字。想必工程師最討厭的就是需要不斷地跟別人溝通想法，會不斷有想法拋出去，也不斷地被否決，理由通常都是這麼做不夠簡潔、不夠有可讀性、不夠有效率。</p><p>不過我想我們的目標是一致的，希望貢獻開源專案，無非是將好的東西貢獻到專案上。種種的批評跟新想法都是促進彼此的成長，有時候是我的方法不夠有效率，有時候是審查者的想法無法通過自動測試，這時候他會為他的想法道歉。我也曾經誤解了他的英文，讓他需要再重新解釋一遍。</p><p>很多時候會遇到一些挫折，像是我覺得他這樣做超級蠢，或是我辛辛苦苦改完一個版本上傳，但是對方卻隔了一個禮拜沒有來看。我想除了技術以外，如何跟別人溝通就在這裡展現出重要性。我講講我自己的心法：</p><ol><li><p>開源專案是大家一起討論出來的結果，沒有辦法說是誰的 idea，除非你真的貢獻超級多或是是專案的擁有者。</p></li><li><p>溝通的時候先溝通目的，將目的說明清楚，別讓別人摸不著頭緒或是不斷猜測浪費時間。</p></li><li><p>溝通時請儘量客觀而表達明確，有必要的話，直接寫一個小的例子。</p></li><li><p>不斷來回的議題通常會產生一些負面情緒，請耐著性子跟對方解釋清楚。在做的好的地方不吝給個稱讚或是表情符號。</p></li><li><p>你認為是對的事情就該明確講出來，將事情說明清楚就好，不需要過於強烈的用字。</p></li></ol><p>到目前為止，PR 都還沒 merge，卻已經歷時了兩個月，累積了 93 次的對話，產生了 15 次的 commit。增加了 339 行程式碼，刪除了 112 程式碼，diff 100%，意味著所有程式碼都被我修改過了。不過我想這不會是最後一次，不過會是一次蠻特別的經驗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。&lt;/p&gt;
&lt;p&gt;我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
    
  </entry>
  
  <entry>
    <title>運算 Julia 參數型別上的值</title>
    <link href="https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/</id>
    <published>2019-05-06T05:56:52.000Z</published>
    <updated>2019-09-06T03:19:59.125Z</updated>
    
    <content type="html"><![CDATA[<p>之前介紹過將值放在參數型別上。</p><p>今天來介紹一下如何可以做到類似運算的效果。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a1 = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">a2 = A&#123;<span class="number">3</span>&#125;()</span><br></pre></td></tr></table></figure><p>在一些應用場景上會希望將參數欄位上的值做運算，例如加總。</p><p>這時候我們可以這樣做：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Base:+</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> +(::A&#123;T&#125;, ::A&#123;S&#125;) <span class="keyword">where</span> &#123;T, S&#125;</span><br><span class="line">x = T + S</span><br><span class="line"><span class="keyword">return</span> A&#123;x&#125;()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以簡單搞定囉！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(a1 + a2)</span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">8</span>&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前介紹過將值放在參數型別上。&lt;/p&gt;
&lt;p&gt;今天來介紹一下如何可以做到類似運算的效果。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>彰化行</title>
    <link href="https://yuehhua.github.io/2019/03/11/changhua-with-ning/"/>
    <id>https://yuehhua.github.io/2019/03/11/changhua-with-ning/</id>
    <published>2019-03-10T17:19:06.000Z</published>
    <updated>2019-09-11T12:50:34.574Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Enter password to read the article</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="3815e404e28251f2aa216d376639685ed9a8f54150c59eba8f8390c7ce4d096c">999302eb3da7ba0830f0d4430dd24ff4e338e2068524d9e60b85b93fd82eb6496ac5b6e68e9e454804fe0df94e0eec66f38528b520d44e36d91ae62b8c8517268ba45789e4a5831ab98cbd2c8bab4eb3772a0d4f59d8888e75380e3d1a667ba69eb22f0f7c4c328da923eea82afe8cdba2f114a8d409b6d8d709fb555d8fed0b74129534d47165114470049deeaf37ad377430daf9514f69ddb5102a535953b7bff718c5a3a516aa32b10354df91745a234bb6a0b227f13dd085e115f42c735a0dd4773aeabe28c4d2878cc1d8ea89af548368e7723b95eb1ad15ace513cd28a63748c2e4d0bc6d368069ecdbe38ddadb500d0010a1012bdfa174d1b18f103827c8d75a87b8d2004f9c5df1776ecf2efbdfa7d77e9a4ae2ee825f917026ae9bfb185e593e62d7ae895d93e5cf16422499532ddcd28436bc91551d6e5a6779cfb7ef6ad202dccd3b13ddf30e5cece6597e5157646b9b7ae44520d426285fa9d2ae0112d31c4af83dcbfeaf86da38bde7376e9d3a0421913db00a526c1872b7a51a1162b40698189e5af252984244b0ae0a49ba566787c4c29f7a7f8dc3d9e4aca4234ee1abae5fdc0fe51e59f17ba2cf44952fd35537b22bb1bd7e6480ff781672c2f5a53cd515c7e8caac3dfae67f78840ee6961a174519d854a3ab2ea61d1fb4a9986d46f2d7ca8902a2cd5e2b78a70c86973fdcdbc07b99fc7728ecc6780c34b400f4231a3342add16f7ef6453d2fca047f1caffd13b66df4417892f8fa8385c6ac8de32c2028f4fb84ba5cff3dfe46a5f6defe2fe48e832af84d3ae5b0d914c1e0ef3f32e1e0fc1d58f28abbdc00df6b72c7effc376ac9a9fb6eb81d91070f77d7b961a13f125f08c7f2bf671f44660d40cd7784e2e54bf9d1500b0f88c46be209b1c3d774c3e02451092dc3b67be05664cd45ae271fa6f4124074a18a51da797428fca161213e8fe5be6879574b3c7117d318d08ea1845cb600857b61a59727b76b63a114e845e507a929440fa222c27c1f95fd0acac5171a642d2571d044102e4f4c597e8965163e4a13670816b1244686d936521aae807020f6074a4d01893c9441f168e7a8030ff8b232329a28c7cddf3597425832b333cd362829407c8259ab7e09a93a517b45256cdd5a90fdeba31ec8b0b5ece3ead908784a14384170b25fb93e86eabc0b241d5db33282fd1ec1afe3b5c15f83813bb0f3ea1a3338e24fcf28a784c3b71798761ee7ace4fcb4b58fdf918c87c2ff6fe88f1a497a9676229735c88b864b875d5566b5457ec50891630e16af3ad2a6d124dd08b0fa721147a495a52cb57728bfcba558ef7ca3fa1a8e31005a561eddbc607f1adb05826575996a205b2363b0c9307f66e7805acdfdb07937212824b5d3314b370e8e878bf024efe01e1b18a9435ae61dcf756ff7d41683a9c20e0ebec26f051e3a9f7a90315c60d3043211520eeae02036a86eef2d52f50c23db32015fd276f6147686362b08756f02752f2de9d807d053a00aa795509272e20b67642704d1d67904967ed8561e7eaf63bdd07ff4bdddd49e24933b9626509e8b4a676d5452e461a1bef1aa06a190eeb8c3c1a8041140c98ff1227e89d53095774ecabe752c93b194a3be93db8a2695abbc57a5687d3fa4bd90275bf3146667fb248287cbd8297077015b9ba6ddbdb7ec1cbeabc04e8c983fc5a39e5659b45537558a088691ef24d404fe498aeb7d80aeb7495df582527d62a3757658515c05dccf5485ed8f8e0136f5bccd02419a012a4605918ed13efb1976c3bb502eb8ce8e06c4755cad0c358517612cd8c00486cc88d8d57b983151e379859570ee6d86bdec1bcc3ec580d97b4f1ebcaeb1d78ed51913e1a88f242aea91144d02f4b4b58c2d3dca37cf767474a21cb133605eb9366b3c2787aea01afacd8c7d099cf0f46dc39be5b38bc64cff9ef520e33ee0edbd1274b912b3773720848a08aa0f095b6b84d6c5f7c79339ab1395704f7a3d82e376a24f99435eb32d178da743a1fab1bf62fc03843b415c64b8c876dea4fabfbddf13618ce934705af2e58d0e94749c62ce5dfb52c5a7a94a6117638ecee53fbbd5fcf68ea400565966826b60330857ecceeeba4a7e7b86705b572acc1f76764a5fcef4bbf4e7c3bda3e04726cbfccaa268ecfb12ea497fc04a8588bd17d857ef6486890ff20cb4f0e911546aa6b9d1c2ed1bfd31459a53e967e400bc723088a67181c8584fe703700dfeaf08e7c8f07a08096f8ef3fbf26f855a0035744fe7c71ca18b6cb82c79cbc1f5870d132a8fc3631e0716c20e615d512b6f10b5ea44eae5c7c0e1daba48a8d778492dfa25d0122a96865999ec0df3c98a3af82d7b7ae942b6da80a158d74500f1981648e6f921de3d771aa83bb8ac9ff173b007bd6285b1460e41e061b5ecc3ae388a1855459498cc1e80606993904e85f165d4e67382b6b968cb65f6d45d0371c3211791902475c5d4aba5dae375a56b9766d2e0b669f08436fdbe4e4d21810bf9df82add67fd1e6538e912026cbe3308c2853b425ee41fe9e3952d4fdcb99013ac4232273735eec0faa8cdee9f4a330302aee85332ee687df4a05bd0f6f0b1fd903336b7e48b3d3c125e65ff8caa128d57cc54f8a12dc7364b75078ba9348f5a8fefccfa8d9502ae67aaa8ce3cd3537b9450a4016e702b71289f72076141317597dd665a6cd27c898543bd23bac8b860b1f1eff4f8a88c9e006aa521904915557de61b3247e898156eeb5c477ba97db23e3e6f3e3e46c0fc7370a54a006ed3c014d3b26c2d4dd78feb12c1703901874f8c84f2dc148e797e1e0faf2d4a727ad5d477cd7d96a68c5bc861be829352841780a7386e8d50cf424b8f9d3b170bcbc6db98b7da66a041c54b98949a21f746e6bd7016899b55e0977941d49d49969acdc00f7f5240094eb05d2d3f190d05d5f1713d3c6b83951508eb4de23c02d856a66c64ccc71c4d23b348102650c86c66908f20d690d4ccf5a9f9f17689993e11243bb8d1e85427cfa2b7dc7d8c4d7e7509b6c92cacf604994974bdf587d1a3356414196742050cc9c79a983094336b6e3b20e7ed74bf769699416b459eca57d6c069868b1c61c70035a1009ed80c0917f4484c4e0f72ee16af24302e13230665e571366e1aca3b5cc57a997d5951eb3bebefaa971f1fe878aab143ead2329a1bfd65d2f2332864dfebfed2b778311667b527df6497ebd0cf261b08cc8090076d4a758a536d6d3ba2c68b89b77c61d300fd5f7bd22b3b6f7a3f8c1b87c7db796957804cf0ba805cf7b1aac1ddde96c194b76e51bd3e4e77f5589e3b0c9a0229f17f64f914f3219d8c822f72f018205f62222c489d045a5e6c7c0c7cd5fd9821a129a5a0025742ba9c965c1fbbeaedf4d346a671cf259af8debd94e6dd309b4a22bec1b4a4e54b1c71a343d6643b531ff1930d7b52183488aea4ba81bd118435d4f8a02f8cd416877ec662d0973421c9f533d8e265f0c045edc5cfd0c94aa8426370b88ff028058c18bfff30d23f46ee272d4a53da19c20a0ec78fd2aeb7f7e1eb5e01f10b01d1a87b3d70f7dc57029d0844b116f6fc77009bbd8b1ff7b124e0d870f2037acb0f87cdc00f15aa1cc671814bcec30dbbe93aa82401718804772b2e0fab79511c92c26826fc2fca2d96afaf5a31ec8138e9798e3633dff8e802e528d432eb562ad3ea01646c878932b02da36a177854e68d86c8d6ae482248ac55ced934c799278b8561429b9e457901e4fa52eb97fe85180ac386c533bab26dddd5b148cab522dfce77e5c85b21dfbc56b446563671aa7602c1e200e84eceaeb58b9982c20eb8b4d6f5bc8f4ab754a9135bfc55959c6d9ad77f7fadd10e2eb5fc7327074dc891dda751d05dd58f4c5da3fb2c0024400ad5929a4eda88e5e498cebcee9872d8efd01c6f1f95ffa2d69d68d3cbf09ab741652df9559b8ff66774efb16de887470b31947ab18ee20524555fc34e663756766d71aa3d31f45970406fa40ce86e57c86c6504384597334dd3a4fe097cdcf3b6f51cfd7fe043af898361980e7e89e4802ac281eed5c9e13e4b18f2246708c5832d40845cb00d95d830a6d743adffec2248b28fd646c2bffb28f0f1a1c91339d8b8238503a88a65583ed8e2b8f608e85779a5277600a496ae130395d6a6d5e964af1e5c8ebee0daae2e3c7c29be9f368e95e0f8457cd9df85e94056881ccd2d8bcd9ff7e8fd576a8ed14f3d7a42a1f76f5bcc57c426905b8fcce12034edb6f486115b156584dcc004484bf9e2e9dbea3edfae955163a95c1cafbe0a664d760fd5f67804386ed5031278b3b96414ae2240f7b44df5e59537725c97c214997d3c842b781e14cbe16f2fda55b1acb2834b2fd15be5a446f9f211ee039aeaf53591d95a9e7459970dde5f74b2b920b514981ba5ae56213bfb39234a2ebf0baf74693d88bf6dea699bbd44e41a58d36fafde72e46f628b1b34034432053cedbf5c50208618b02ca449312493e4e0866e4c18c21f2495b80cdad58545ca12073d45880369022738eb01cf59db539e48be9554e3596718362b0e8df8296c4fc83a8866e2ea2f4d4f6f0aa530da0bbc1cb2668bcf1d1d598692df869e12f7a354cea568096fe732e5ed6361c62ebc1cb578ad1c31a67d95235596012e68f94f22a6b17b0fd2b11940d5f980351bbe7d4c44971a46ab0066d50d734ffdf5ee6bd6c99cd7e95129dfe3414c32787bb46d3e20b2dcf2b16b1388afe4127da3a11d46d908fb976269c1efda70dddefe9c014da408535fed7efb9f0cfed3386daac91d5f9851391caa6efbc35da868ef1efe304e18f86a3c5bcfe5ff14e5a752b00fdd749c5f4f495d8e987fcb1ead3aa6c0d69dd106eef8439353f6faa0e2af7e295a96fb9b57404f3ef87984411a2a717688a7bd58b657115c3b758f42498eda37601329c974ce537f1b027003b0c54bc43016322ba19bf08c5d661d5e74a57b4f93a7a8e00bcc3bf3ffb4af9b037e009650a56adc87cabeef4f7f809eb00888e091ac65725117a4d83b7cb4a586db62846e47c3b5f188aac65d773090c59f8ebc70242df738c1cdd858606346d7bfa77df0a01b41d01aea497396cda6e5468ef8632db399a31b7b52e730dad45178ef1c7946d4faee311a5a11383490120c58553df4c6a6ff7601aabdcd5a28346ef83fcf7d24b38bd640b521628e9d0483b03f295ee1e0c110db8298c76bf1563f84c3756b80aa212cb3e74b2840e802b790eb20ec571e22e57d480b67df443fbfbe449b2cacbf598b2cc1567229497a329c82fd88dbe4b3fb53127ff227e1167ae8b696daf6f58f99d8ae6b38ff3d23efd6ebc478724cd4896cecad71607d6936641388abe802852eaa32da359becff255d9623b1e176a97ac500a9e1571cef23e9</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Private post
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Friends" scheme="https://yuehhua.github.io/categories/My-Style/Friends/"/>
    
    
  </entry>
  
  <entry>
    <title>金錢是最廉價的表達</title>
    <link href="https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/"/>
    <id>https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/</id>
    <published>2019-03-01T04:20:45.000Z</published>
    <updated>2019-05-06T05:59:11.172Z</updated>
    
    <content type="html"><![CDATA[<p>人們常常對自己的親人朋友表達情感。</p><p>很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。</p><a id="more"></a><p>我認為利用金錢來表達這些情感非常的廉價。</p><p>金錢並不包含一個人想表達的情感跟意志。</p><p>除了金錢以外，還有什麼是更珍貴更值得付出，更能表達誠意的。</p><p>是時間，你花時間寫的文字比罐頭簡訊或是七彩的卡片溫暖，花時間做的料理或是點心更能彰顯你對另一半的關愛。</p><p>那些以金錢買來的禮品、請客，比不上更真誠的陪伴跟暢談。</p><p>對我而言，我不會讓摯友跟親人以金錢取代真摯的情感。而那些會接受以金錢表達的，多半是泛泛之交。</p><p>相較起時間的付出，金錢真的非常廉價。我始終不認為金錢可以買到友誼、愛情或是親情。如果有人買到了，那一定無比虛假。不過或許可以用金錢買到專業跟努力。</p><p>現代人生活節奏很快，時間更是珍貴，所以願意付出時間的人才是重視對方的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人們常常對自己的親人朋友表達情感。&lt;/p&gt;
&lt;p&gt;很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>神經微分方程（Neural Ordinary Differential Equations）</title>
    <link href="https://yuehhua.github.io/2019/02/24/neural-ode/"/>
    <id>https://yuehhua.github.io/2019/02/24/neural-ode/</id>
    <published>2019-02-24T07:47:10.000Z</published>
    <updated>2019-02-25T16:18:15.950Z</updated>
    
    <content type="html"><![CDATA[<p>這篇被選為 NeurIPS 2018 最佳論文，他將連續的概念帶入了神經網路架構中，並且善用以往解微分方程的方法來做逼近，可以做到跟原方法（倒傳遞）一樣好的程度，而參數使用複雜度卻是常數，更短的訓練時間。</p><h2 id="核心觀念">核心觀念</h2><p>概念上來說，就是將神經網路<strong>離散的層</strong>觀念打破，將他貫通成為<strong>連續的層</strong>的網路架構。</p><p>連續和離散的差別來自於倒傳遞的過程：</p><p>$$<br>\mathbb{y}_{t+1} = \mathbb{y}_t - \eta \nabla \mathcal{L}<br>$$</p><p>其中 $\nabla \mathcal{L}$ 就是梯度的部份，是向量的，然而我們把他簡化成純量來看的話，他不過就是</p><p>$$<br>\frac{d \mathcal{L}}{dt}<br>$$</p><p>廣義上來說，一個函數的微分，如果是離散的版本就會是</p><p>$$<br>\frac{dy}{dt} = \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>如此一來，所形成的方程式就會是差分方程，然而連續的版本就是</p><p>$$<br>\frac{dy}{dt} = \lim_{\Delta \rightarrow 0} \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>這個所形成的會是微分方程。</p><h2 id="從離散到連續">從離散到連續</h2><p>我們可以從離散的版本</p><p>$$<br>\frac{dy}{dt} = \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>把他轉成以下的樣貌</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt}<br>$$</p><p>要將他貫通的話，我們就得由從神經網路的基礎開始，如果是一般的前回饋網路（feed-forward network）當中的隱藏層是像下列這個樣子：</p><p>$$<br>h_{t+1} = f(h_t, \theta)<br>$$</p><p>我們可以發現像是 ResNet 這類的網路有 skip connection 的設置，所以跟一般的前回饋網路不同</p><p>$$<br>h_{t+1} = h_t + f(h_t, \theta)<br>$$</p><p>而 RNN 等等有序列概念的模型也有類似的結構，就是會是前一層的結果加上通過 $f$ 運算後的結果，成為下一層的結果。</p><p>這樣的形式跟我們前面提到的形式不謀而合</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt}<br>$$</p><p>只要我們把 $\Delta = 1$ 代入，就成了</p><p>$$<br>y(t+1) = y(t) + \frac{dy}{dt}<br>$$</p><p>以下給大家比對一下</p><p>$$<br>h_{t+1} = h_t + f(h_t, \theta) \\<br>y(t+1) = y(t) + \frac{dy}{dt}<br>$$</p><p>也就是，我們可以讓</p><p>$$<br>\frac{dy}{dt} = f(h_t, \theta)<br>$$</p><p>神奇的事情就發生了！神經網路 $f$ 就可以被我們拿來計算微分 $\frac{dy}{dt}$！</p><p>比較精確的說法是，把神經網路的層 $f$ 拿來逼近微分項，或是說梯度。這樣我們後面就可以用數值方法來逼近解。</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt} \\<br>\downarrow \\<br>y(t + \Delta) = y(t) + \Delta f(t, h(t), \theta_t)<br>$$</p><p>要拉成連續的還有一個重要的手段，就是將不同的層 $t$ 從離散的變成連續的，所以作者將 $t$ 做了參數化，將他變成 $f$ 的參數之一，如此一來，就可以在任意的層中放入資料做運算。</p><p>最重要的概念導出了這樣的式子</p><p>$$<br>h(t) \rightarrow \frac{dy(t)}{dt} = f(h(t), t, \theta) \rightarrow y(t)<br>$$</p><h2 id="神經網路作為一個系統的微分形式">神經網路作為一個系統的微分形式</h2><p>在傳統科學或是工程領域，我們會以微分式來表達以及建構一個系統。</p><p>$$<br>\nu = \frac{dx}{dt} = t + 1<br>$$</p><p>其實在這邊是一樣的道理，整體來說，我們是換成用神經網路去描述一個微分式，其實本質上就是這樣。</p><p>原本的層的概念就是用數學函數來建立的，而層與層之間傳遞著計算的結果。</p><p>$$<br>\mathbb{h_1} = \sigma(W_1 \mathbb{x} + \mathbb{b_1}) \\<br>\mathbb{y} = \sigma(W_2 \mathbb{h_1} + \mathbb{b_2})<br>$$</p><p>然而變成連續之後，我們等於是用神經網路中的層去建立跟描繪微分形式。</p><p>$$<br>\frac{d h(t)}{dt} = \sigma(W(t) \mathbb{x}(t) + \mathbb{b(t)}) \\<br>\frac{d y(t)}{dt} = \sigma(W(t) \mathbb{h}(t) + \mathbb{b(t)})<br>$$</p><p>是不是跟如出一轍呢？</p><p>$$<br>\frac{dy(t)}{dt} = f(h(t), t, \theta)<br>$$</p><h2 id="向前傳遞解微分式">向前傳遞解微分式</h2><p>我們可以來計算看看隱藏層是長什麼樣子的。在隱藏層的微分式中，也是利用隱藏層去計算出來的。</p><p>$$<br>\frac{dh(t)}{dt} = f(h(t), t, \theta)<br>$$</p><p>基本上，我們只要對上式做積分就可以了。</p><p>$$<br>h(t) = \int f(h(t), t, \theta) dt<br>$$</p><p>這是一個怎樣的概念呢？我們可以來看看下圖。</p><p><img src="/images/hidden-state1.svg" alt=""></p><p>我們做積分這件事其實是用 $h(t_0)$ 來推斷 $h(t_1)$ 的，這跟神經網路的向前傳遞是一樣的行為。</p><p>$$<br>h(t_1) = F(h(t), t, \theta) \bigg|_{t=t_0}<br>$$</p><p>這樣的積分動作，我們可以用 $t_0$ 時間點的資訊來解 $h(t_1)$。</p><p>這樣的解法在程式上就會交由 ODE Solver 去處理。</p><p>$$<br>h(t_1) = ODESolve(h(t_0), t_0, t_1, \theta, f)<br>$$</p><h2 id="反向傳遞解函數">反向傳遞解函數</h2><p>$$<br>\mathcal{L}(t_0, t, \theta) = \mathcal{L}(ODESolve(\cdot))<br>$$</p><p>$$<br>\frac{\partial \mathcal{L}}{\partial h(t)} = -a(t)<br>$$</p><p>adjoint state</p><p>$$<br>a(t) = \int -a(t)^T \frac{\partial f}{\partial h} dt = - \frac{\partial \mathcal{L}}{\partial h(t)}<br>$$</p><p>$$<br>a(t) = \int_{t_1}^{t_0} -a(t)^T \frac{\partial f(h(t), t, \theta)}{\partial h(t)} dt<br>$$</p><p><img src="/images/adjoint-state.svg" alt=""></p><h2 id="擴充狀態（augmented-state）">擴充狀態（augmented state）</h2><p>$\frac{d \theta}{dt} = 0$</p><p>$\frac{dt}{dt} = 1$</p><p>let $\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}$ be a augmented state</p><p>augmented state function:</p><p>$$<br>f_{aug}(\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}) =<br>\begin{bmatrix}<br>f(h(t), t, \theta) \\<br>0 \\<br>1<br>\end{bmatrix}<br>$$</p><p>augmented state dynamics:</p><h1>$$<br>\frac{d}{dt}<br>\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}</h1><p>f_{aug}(<br>\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix})<br>$$</p><p>augmented adjoint state:</p><p>$$<br>\begin{bmatrix}<br>a \\<br>a_{\theta} \\<br>a_t<br>\end{bmatrix}<br>$$</p><p>$a = \frac{\partial \mathcal{L}}{\partial h}$</p><p>$a_{\theta} = \frac{\partial \mathcal{L}}{\partial \theta}$</p><p>$a_t = \frac{\partial \mathcal{L}}{\partial t}$</p><p>$$<br>\frac{d a_{aug}}{dt} = -<br>\begin{bmatrix}<br>a \frac{\partial f}{\partial h} \\<br>a \frac{\partial f}{\partial \theta} \\<br>a \frac{\partial f}{\partial t}<br>\end{bmatrix}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇被選為 NeurIPS 2018 最佳論文，他將連續的概念帶入了神經網路架構中，並且善用以往解微分方程的方法來做逼近，可以做到跟原方法（倒傳遞）一樣好的程度，而參數使用複雜度卻是常數，更短的訓練時間。&lt;/p&gt;
&lt;h2 id=&quot;核心觀念&quot;&gt;核心觀念&lt;/h2&gt;
&lt;p&gt;概念上
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://yuehhua.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>筆記 - 從向量空間到函數空間</title>
    <link href="https://yuehhua.github.io/2019/02/24/note-of-vector-space-to-function-space/"/>
    <id>https://yuehhua.github.io/2019/02/24/note-of-vector-space-to-function-space/</id>
    <published>2019-02-24T04:54:02.000Z</published>
    <updated>2019-02-24T04:54:02.908Z</updated>
    
    <content type="html"><![CDATA[<p>參考<a href="https://ccjou.wordpress.com/2009/08/18/%E5%BE%9E%E5%B9%BE%E4%BD%95%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93%E5%88%B0%E5%87%BD%E6%95%B8%E7%A9%BA%E9%96%93/" target="_blank" rel="noopener">從幾何向量空間到函數空間| 線代啟示錄</a>。</p><ol><li>由 $\mathbb{R}^n$ 拓展到 $\mathbb{R}^{\infty}$ 所需俱備的條件是什麼？</li></ol><p>由於一個向量 $\mathbb{v} \in \mathbb{R}^{\infty}$，在無限維度下我們需要考慮一個問題，就是 norm。</p><p>如果這個空間有定義 norm 的話，我們就要考慮他有沒有收斂，也就是 $||\mathbb{v}||^2$ 要存在。</p><p>所以條件就是</p><p>$$<br>||\mathbb{v}||^2 = \sum_{i=1}^{\infty} v_i^2<br>$$</p><p>要收斂。</p><ol start="2"><li>從 $\mathbb{R}^{\infty}$ 無限維度的向量空間再拓展到 $C^{\omega}$ 函數空間，所需要俱備的條件是什麼？</li></ol><p>一個無限維度的向量是一個離散的版本，由剛剛的式子可以看的出來</p><p>$$<br>||\mathbb{v}||^2 = \sum_{i=1}^{\infty} v_i^2<br>$$</p><p>而一個（解析）函數則是連續的</p><p>$$<br>||f||^2 = \int f^2(x) dx<br>$$</p><p>除了以上的 norm 要收斂外，從離散到連續應該有些假設或是條件才是。</p><ol start="3"><li>函數的基底</li></ol><p>Fourier series</p><p>$$<br>f(x) = a_0 + a_1 \cos x + b_1 \sin x + a_2 \cos 2x + b_2 \sin 2x + \cdots<br>$$</p><p>所以基底就是</p><p>$$<br>&lt;\beta&gt; = &lt;1, \cos x, \sin x, \cos 2x, \sin 2x, \cdots&gt;<br>$$</p><ol start="4"><li>非週期性函數基底</li></ol><p>Legendre polynomial</p><ol start="5"><li>Least square problem</li></ol><p>$$<br>(A^TA)\hat{y} = A^Tb<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;參考&lt;a href=&quot;https://ccjou.wordpress.com/2009/08/18/%E5%BE%9E%E5%B9%BE%E4%BD%95%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93%E5%88%B0%E5%87%BD%E6%95
      
    
    </summary>
    
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>在參數化型別中使用值的效能分析</title>
    <link href="https://yuehhua.github.io/2019/02/22/performance-analysis-of-value-in-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/02/22/performance-analysis-of-value-in-parametric-type/</id>
    <published>2019-02-22T04:24:37.000Z</published>
    <updated>2019-09-06T03:20:20.510Z</updated>
    
    <content type="html"><![CDATA[<p>我在使用的時候有注意到<em>在參數化型別中使用值</em>的方式與<em>傳統封裝</em>的方式有效能上的差異。</p><p>所以我就做了一些測試。</p><p>在參數化型別中使用值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>傳統型別封裝：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> B</span><br><span class="line">    x::<span class="built_in">Int64</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>全文出現的程式碼為實際測試程式碼</em></p><p>因為 Julia 有提供好用的 <code>@code_llvm</code> 及 <code>@code_native</code> 來觀察一行程式碼實際被轉換成 LLVM 或是組合語言的時候會產生多少行的程式碼，藉此我們可以用低階程式碼來評估是否有效率。程式碼的行數愈少是越有效率的。</p><h2 id="建立">建立</h2><p>我們來測試一個物件被建立需要多少行的程式碼。</p><h3 id="A-LLVM">A - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[1]:3 within `Type'</span></span><br><span class="line"><span class="comment">define nonnull %jl_value_t addrspace(10)* @japi1_Type_12238(%jl_value_t addrspace(10)*, %jl_value_t addrspace(10)**, i32) #0 &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  %3 = alloca %jl_value_t addrspace(10)**, align 8</span></span><br><span class="line"><span class="comment">  store volatile %jl_value_t addrspace(10)** %1, %jl_value_t addrspace(10)*** %3, align 8</span></span><br><span class="line"><span class="comment">  ret %jl_value_t addrspace(10)* addrspacecast (%jl_value_t* inttoptr (i64 140407726014496 to %jl_value_t*) to %jl_value_t addrspace(10)*)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="B-LLVM">B - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[1]:2 within `Type'</span></span><br><span class="line"><span class="comment">define &#123; i64 &#125; @julia_Type_12221(%jl_value_t addrspace(10)*, i64) &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  %.fca.0.insert = insertvalue &#123; i64 &#125; undef, i64 %1, 0</span></span><br><span class="line"><span class="comment">  ret &#123; i64 &#125; %.fca.0.insert</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="A-Assembly">A - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[1]:3 within &#96;Type&#39;</span><br><span class="line">movq%rsi, -8(%rsp)</span><br><span class="line">movabsq$140407726014496, %rax  # imm &#x3D; 0x7FB338A20020</span><br><span class="line">retq</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h3 id="B-Assembly">B - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[1]:2 within &#96;Type&#39;</span><br><span class="line">movq%rsi, %rax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h2 id="取值">取值</h2><p>接著測試從物件當中取值出來的效能。</p><p>定義取值的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_value(::A&#123;T&#125;) <span class="keyword">where</span> &#123;T&#125; = T</span><br><span class="line">get_value(b::B) = b.x</span><br></pre></td></tr></table></figure><p>事先建立好物件：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">b = B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="A-LLVM-2">A - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> get_value(a)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[8]:1 within `get_value'</span></span><br><span class="line"><span class="comment">define i64 @julia_get_value_12274() &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  ret i64 5</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="B-LLVM-2">B - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> get_value(b)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[5]:1 within `get_value'</span></span><br><span class="line"><span class="comment">define i64 @julia_get_value_12630(&#123; i64 &#125; addrspace(11)* nocapture nonnull readonly dereferenceable(8)) &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">; ┌ @ sysimg.jl:18 within `getproperty'</span></span><br><span class="line"><span class="comment">   %1 = getelementptr inbounds &#123; i64 &#125;, &#123; i64 &#125; addrspace(11)* %0, i64 0, i32 0</span></span><br><span class="line"><span class="comment">; └</span></span><br><span class="line"><span class="comment">  %2 = load i64, i64 addrspace(11)* %1, align 8</span></span><br><span class="line"><span class="comment">  ret i64 %2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="A-Assembly-2">A - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> get_value(a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[8]:1 within &#96;get_value&#39;</span><br><span class="line">movl$5, %eax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h3 id="B-Assembly-2">B - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> get_value(b)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[5]:1 within &#96;get_value&#39;</span><br><span class="line">movq(%rdi), %rax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><p>給大家參考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在使用的時候有注意到&lt;em&gt;在參數化型別中使用值&lt;/em&gt;的方式與&lt;em&gt;傳統封裝&lt;/em&gt;的方式有效能上的差異。&lt;/p&gt;
&lt;p&gt;所以我就做了一些測試。&lt;/p&gt;
&lt;p&gt;在參數化型別中使用值：&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在參數化型別中定義值</title>
    <link href="https://yuehhua.github.io/2019/02/22/define-values-in-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/02/22/define-values-in-parametric-type/</id>
    <published>2019-02-21T17:22:42.000Z</published>
    <updated>2019-09-06T03:21:46.486Z</updated>
    
    <content type="html"><![CDATA[<p>應該不少人看到這個標題會摸不著頭緒到底要做什麼，但是看完 Julia 中常見的程式碼你就會了解了。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">Any</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>有沒有曾經納悶過那個數字 2 到底是怎麼進到參數的位置上的呢？</p><p>參數的位置不是只能放型別（type）嗎？</p><p>這同時也是我困惑已久的問題，就搜尋了一下，果不其然被我找到了方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><p>原來這麼簡單就可以完成了！語法上並沒有限定一定要是<em>型別</em>，要放型別以外的東西似乎是可以的。</p><p>我目前測試了可以的有：Int64、Float64、Complex、Char、Bool、Symbol，所以估計數字應該都是可以的。</p><p>不行的有：String、Array，估計物件或是陣列都是不行的。</p><h2 id="定義範圍">定義範圍</h2><p>不過使用上並沒有任何限制會有點危險，所以還是定義一下範圍會比較好，像是：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;<span class="literal">I</span>&#125;</span><br><span class="line">    <span class="keyword">function</span> A&#123;<span class="literal">I</span>&#125;() <span class="keyword">where</span> &#123;<span class="literal">I</span>&#125;</span><br><span class="line">        <span class="keyword">isa</span>(<span class="literal">I</span>,<span class="built_in">Integer</span>) || error(<span class="string">"bad parameter"</span>)</span><br><span class="line">        new()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這樣就可以限制參數要是整數的範圍。</p><h2 id="從參數取值">從參數取值</h2><p>那我們能不能從型別的參數當中取值呢？</p><p>可以。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_value(::A&#123;<span class="literal">I</span>&#125;) <span class="keyword">where</span> A&#123;<span class="literal">I</span>&#125; = <span class="literal">I</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以從型別中拿到值了。</p><h2 id="好處？">好處？</h2><p>這麼做有什麼好處？</p><p>當你把值的資訊放到型別當中，型別就多了一些資訊可以提供編譯器處理，這對於要自己設計型別階層可是非常好用的。</p><p>例如像是你可以將陣列的長度資訊儲存到型別上，這樣編譯器就可以處理陣列的長度資訊了。</p><p>這樣的程式風格會跟 dependent type language 有些相似了。</p><p>大家可以玩玩看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;應該不少人看到這個標題會摸不著頭緒到底要做什麼，但是看完 Julia 中常見的程式碼你就會了解了。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Note - Mathematical objects</title>
    <link href="https://yuehhua.github.io/2019/02/06/mathematical-objects/"/>
    <id>https://yuehhua.github.io/2019/02/06/mathematical-objects/</id>
    <published>2019-02-05T16:02:53.000Z</published>
    <updated>2019-02-05T16:02:53.088Z</updated>
    
    <content type="html"><![CDATA[<p>20th century Cantor:</p><blockquote><p>All mathematical objects can be defined as sets.</p></blockquote><p>Fundamentals:</p><ul><li>numbers</li><li>permutations</li><li>partitions</li><li>matrices</li><li>sets</li><li>functions</li><li>relations</li></ul><p>Geometry:</p><ul><li>hexagons</li><li>points</li><li>lines</li><li>triangles</li><li>circles</li><li>spheres</li><li>polyhedra</li><li>topological space</li><li>manifolds</li></ul><p>Algebra:</p><ul><li>groups</li><li>rings</li><li>fields</li><li>lattices</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;20th century Cantor:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All mathematical objects can be defined as sets.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Fundamentals:&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>生物資訊的初衷</title>
    <link href="https://yuehhua.github.io/2019/02/01/original-intention-to-bioinformatics/"/>
    <id>https://yuehhua.github.io/2019/02/01/original-intention-to-bioinformatics/</id>
    <published>2019-01-31T16:25:47.000Z</published>
    <updated>2019-01-31T16:25:47.679Z</updated>
    
    <content type="html"><![CDATA[<p>受到其他文章的啟發，我也來寫一篇為什麼我踏入生物資訊領域好了。</p><p>受到啟發應該算是從高中的時候說起，高中的時候喜歡數學、物理跟生物。對於數學，喜歡他的抽象及純粹，而物理可以解釋這個世界的法則，對於生物則是一直以來隱隱約約有些感覺的。小時候對於生命現象一直很好奇，對於生物的多樣性感到驚奇，但到了高中卻成了考卷上的考題，我不認為那是我要的。</p><p>還記得高中生物上到下視丘的時候會講到很多不同種的激素調控，我突然覺得這一切的背後似乎有著什麼，我對「調控」產生了興趣。接著到了高中快結束，終於上到近代的生物技術以及 DNA 分子的轉錄轉譯，雖然對當時的我來說有點複雜，但是我喜歡挑戰理解這種複雜的事物，我將他轉化成比較好理解的「設計圖」解釋。DNA 就像是一台車子的整體設計圖，RNA 就是將設計圖的一部份零件複製一份出來，並且製造出蛋白質，也就是真實的零件。理解了這些讓我非常開心。</p><p>大學念了醫學檢驗生物技術，但卻不是我的第一志願，不過我確定我對生物技術是有興趣的，我也非常認真對待我的選擇。在傳統的生物醫學研究都是花了十幾年的時間在研究一個蛋白或是一個基因的功能或是交互作用。</p><p>我大三的某天在逛維基百科（你沒看錯，我會去逛維基百科）被我發現了系統生物學這個領域，看到頁面的當下非常震驚，可以以一個系統的觀點切入生物的議題，那麼就可以不用那麼辛苦的一個基因一個基因研究了。而且系統的概念直接串起了在生化中學到的調控，他不只是 pathway，而是一個複雜的網路，可以藉由網路的調控或是反應機制，讓生物體做出特定的行為。生物體就是個巨大的機械，但是複雜度卻遠高於機械，也不像機構那樣那麼容易理解，很多事情是人類目前還不知道的。</p><p>因為這樣的未知，這樣的複雜，這樣的調控系統，讓我決心研究所要往這個方向走。</p><p>大四的時候有進階生物技術，接觸到定序技術、生物資訊、序列處理的議題。同時雙主修資訊工程，我更享受在資工系的課程當中，雖然他講的是程式、作業系統等等，但是對於（建造）系統的概念始終是保留的。我最有興趣的大概是離散數學、演算法跟訊號與系統了，離散數學中的圖論可以說是非常神妙，而圖論的用途也超級廣，可以拿來 model 很多不同的事物。演算法則是去證明一件事情可以被如何的完成是最快的，這些魔法都來自於數學。訊號與系統講述了如何去探知或是解析一個系統，我們怎麼從一個系統的行為當中去反推這個系統的架構。</p><p>到研究所真正接觸了生物資訊與我的認知相去不遠，不過還是少了點什麼，看了看課程發現了機器學習的課程，也詢問了學長關於這個領域，聽說還蠻推薦的，但是受限於開課時間，就乾脆自己去找了 coursera 上林軒田老師的機器學習課程看，大概一個月左右就把他看完了。看的當下非常開心，學到了跟演算法非常相似的技術，而當時大數據剛開始紅，所以就以這個技術為主軸開始了我的研究。</p><p>殊不知，後來的深度學習的崛起，AI 的爆紅，讓機器學習變得異常的熱門。不過我還是希望繼續做系統生物學，應該說是計算生物學。來把這迷樣的生物系統 model 出來吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;受到其他文章的啟發，我也來寫一篇為什麼我踏入生物資訊領域好了。&lt;/p&gt;
&lt;p&gt;受到啟發應該算是從高中的時候說起，高中的時候喜歡數學、物理跟生物。對於數學，喜歡他的抽象及純粹，而物理可以解釋這個世界的法則，對於生物則是一直以來隱隱約約有些感覺的。小時候對於生命現象一直很好奇，
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
