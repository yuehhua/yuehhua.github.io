<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Maker</title>
  
  <subtitle>Love Math, Science, Biology, Computer science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuehhua.github.io/"/>
  <updated>2020-08-07T03:14:34.552Z</updated>
  <id>https://yuehhua.github.io/</id>
  
  <author>
    <name>Yueh-Hua Tu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Julia v1.5 釋出</title>
    <link href="https://yuehhua.github.io/2020/08/07/julia-v1-5-release/"/>
    <id>https://yuehhua.github.io/2020/08/07/julia-v1-5-release/</id>
    <published>2020-08-07T03:06:29.000Z</published>
    <updated>2020-08-07T03:14:34.552Z</updated>
    
    <content type="html"><![CDATA[<p>在新的 1.5 版是主要對記憶體的配置方式有改進，有最佳化記憶體布局（memory layout）。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><p>不可變型別（包含 tuples）現在可以被放到堆疊（stack）上，而且可以在陣列跟其他型別中被配置成 inline。(#33886)<br>有興趣的朋友可以查詢 inline allocation 相關關鍵字。如此一來就大幅降低了在堆積（heap）上配置的記憶體數量。<br>相對，任何需要是穩定定址（stable address）的物件就要必須是 <code>mutable struct</code>。(#34126)</p><h3 id="使用者功能">使用者功能</h3><ul><li>在互動式 REPL 環境提供了「軟性作用域」（soft scope）。像是在 <code>for</code> loop 的作用域中要指定值給全域變數，是可行的。如同在 IJulia 所提供的 Jupyter 環境一樣，但這只影響 REPL 環境，不影響腳本執行環境。(#28789, #33864)</li><li>如果在 REPL 外，例如腳本，執行以上行為會被視為模糊的（ambiguous），並且會發出 warning。</li><li>另外，有一個新的命令列選項是 <code>--warn-scope</code> 可以控制這個 warning。(#33864)</li><li>在三個雙引號所形成的字串中，空白移除（whitespace stripping）會優於跳脫字元執行。如此一來，以下例子會有不同的結果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">  a\n b&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>會產生 <code>&quot;a\n b&quot;</code> 的字串，而不是 <code>&quot; a\nb&quot;</code>，兩者差別在 <code>a</code> 之前有沒有空白。老舊的行為會被視為一種 bug。(#35001)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>現在可以在每個模組（module）中使用編譯器最佳化等級（compiler optimization level），是使用 <code>Base.Experimental.@optlevel n</code> 來設定。對於並不是那麼效能需求（performance-critical），可以設定成 0 或 1，可以提供相當的延遲改善（latency improvements）。(#34896)</li><li><code>@inline</code> 可以被用在短型的匿名函數。(#34953)</li><li>棄用警告（deprecation warnings）不再是預設顯示的，可以使用 <code>--depwarn=no</code> 來開啟。警告在執行測試 <code>Pkg.test()</code> 時是會顯示的。(#35362)</li><li>部份的多執行緒（multi-threading）API 被視為穩定。這包含了所有 <code>Base.Threads</code> 中被紀錄的 API，但除了 <code>atomic_</code> 操作。</li><li><code>@threads</code> 現在容許可選的排程參數（schedule argument）。用法像是 <code>@threads :static ...</code>。</li><li><code>@ccall</code> 現在被加入到 Base 中。這跟 <code>ccall</code> 很像，但多了類 Julia 語法。他也包裝了新的 <code>foreigncall</code> API，支援 varargs 中不同的型別，不過他缺乏呼叫指定 LLVM calling convention 的能力。(#32748)</li><li><code>@view</code> 及 <code>@views</code> 現在支援 <code>a[begin]</code> 語法。(#35289)</li></ul><h2 id="新功能">新功能</h2><ul><li><code>⨟</code> 現在是一個二元運算子，他是一個 composition operator，語意為 <code>f ⨟ g = g ∘ f</code>。在 REPL，可以使用 <code>\bbsemi</code> 加上 <kbd>TAB</kbd> 打出來。(#34722)</li><li>傳遞一個辨識子（identifier）<code>x</code> 作為關鍵字參數或是 named tuple，會等同於 <code>x=x</code>，會隱含地使用變數名稱本身作為關鍵字參數的名稱或 named tuple 的名稱。同樣地，傳遞 <code>a.b</code> 會使用 <code>b</code> 作為名稱。(#29333)</li><li>新增 <code>mergewith</code> 及 <code>mergewith!</code> 取代 <code>merge</code>、<code>merge!</code> 及參數 <code>combine</code> 的組合。(#34296)</li><li>新增 <code>isdisjoint</code> 來指示兩個集合容器是否為互斥。(#34427)</li><li>新增 <code>ismutable</code> 來取代 <code>isimmutable</code>，用來檢查某些東西是否為可變的。(#34652)</li><li>新增 <code>contains(haystack, needle)</code> 行為如同 <code>occursin(needle, haystack)</code>。(#35132)</li></ul><h2 id="新支援">新支援</h2><ul><li>使用 <code>open</code> 開檔時，多了 <code>lock</code> 關鍵字參數來控制檔案操作是否在多執行緒存取的狀況下需要鎖。當只有一個執行緒存取時，設定成 <code>false</code> 會有較好的性能。(#35426)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在新的 1.5 版是主要對記憶體的配置方式有改進，有最佳化記憶體布局（memory layout）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>真理</title>
    <link href="https://yuehhua.github.io/2020/05/23/the-truth/"/>
    <id>https://yuehhua.github.io/2020/05/23/the-truth/</id>
    <published>2020-05-23T04:55:01.000Z</published>
    <updated>2020-05-23T05:18:56.180Z</updated>
    
    <content type="html"><![CDATA[<p>今天意外看到一段話，出處應該是《不用數字的研究 ：質性研究的思辯脈絡》一書。</p><blockquote><p><strong>&quot;To achieve enlightenment, our political systems must relinquish their claims on truth, justice and freedom and have to replace them with the search for truth, justice, freedom and reason.&quot;</strong><br>– Immanuel Kant</p></blockquote><a id="more"></a><p><a href="https://commons.wikimedia.org/wiki/File:Kant_gemaelde_3.jpg#/media/File:Kant_gemaelde_3.jpg" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f2/Kant_gemaelde_3.jpg" alt="Kant gemaelde 3.jpg"></a><br>由 Johann Gottlieb Becker (1720-1782) - <a rel="nofollow noopener" class="external free" href="http://www.philosovieth.de/kant-bilder/bilddaten.html" target="_blank">http://www.philosovieth.de/kant-bilder/bilddaten.html</a>, 公有領域, <a href="https://commons.wikimedia.org/w/index.php?curid=32860677" target="_blank" rel="noopener">連結</a></p><p>康德是個歷史上重要的哲學家，他指出了面對真理的態度。</p><p>要得到開悟，我們的體系需要放棄他們對於真理、正義以及自由的定義。取而代之的是，對於真理、正義以及自由的追求與探索。</p><p>開悟的過程並不是去讀懂一些名人、大師的名言，也不是去崇尚大家所共識的真理。</p><p>真理、正義以及自由並不是由人定義出來的，而是經由追求與探索得到的。</p><p>這讓我想到科學不也是一個這樣的過程嗎？</p><p>科學並不是由教科書上所定義及構築出來的美好世界，科學本身是一種過程，科學是一種追求與探索真理的過程。</p><p>也就是說，一旦停滯了，不往前走，就不是科學了。在原地享用科學的成果也不是科學本身，科學必須前進，必須去拓展未知的領域。</p><h2 id="有限">有限</h2><p>然而大家目前看到的量子、人工智慧種種科技，並非科學本身，而是科學的產物。是有一群人秉持著這樣的想法不斷往前探索所得到的<strong>暫時的</strong>結論。</p><p>是的，所以在世的東西都是暫時的。知識會老去，會有新的知識產出。我們會證明舊的知識不再適用，有一套新的知識取而代之。</p><p>沒有什麼東西是永恆的。永恆只存在在當時間走到盡頭（$t \rightarrow \infty$），然而時間沒有盡頭。</p><p>當事物到了無限大的時候，永恆才存在，真理才存在，理論才存在。但在那之前都是暫時的，所有事物都有生死，是<strong>有限的</strong>。</p><p>人是有限的，但人常嚮往無限。</p><p>既然有限，當然也不會知道真理、正義以及自由的終極定義是什麼。</p><h2 id="往前">往前</h2><p>唯一能做的就是不斷地往前走，不斷地探索，不斷地尋找真理、正義以及自由。</p><p>企業不斷尋找市場，想知道最終市場會在哪裡，可惜的是它永遠是變動的，只能不斷追尋。</p><p>研究人員在尋找真理，尋找真理需要方法，可惜的是無法達到彼岸，只是不停地往前。</p><p>以科學的方式不斷地往前走及探索，才是科學本身。</p><h2 id="博士">博士</h2><p>念博士是個開悟的過程，從一個靜態的世界觀，走向一個動態的世界觀。</p><p>從一個有標準答案的世界，走向一個沒有標準答案的世界，甚至每個都有可能是答案。</p><p>從一個遵循定義，到可以隨處都是定義，或是所有定義都不存在。</p><h2 id="暫時的答案">暫時的答案</h2><p>很多研究結果是得到一個暫時的答案。</p><p>很多研究結果很快就被證明是錯的，或是可以做出同樣結論的人不多。</p><p>太快擁抱結果，或是擁抱單一的答案都是一種 overfitting，它失去對未來的適應性即可預測性。</p><p>但是如果不擁抱結果，你會一無所穫，事物都無法推進，裹足不前。</p><h2 id="方法">方法</h2><p>方法，就像搭橋，它連結了現在與未來，連結了有限與無限。</p><p>找到對的方法會讓你有比較穩固的方式連結現況與未來，錯誤的方法相對脆弱。</p><p>追求真理的過程其實大多都在尋找方法。</p><p>很多時候不是「XXX是錯誤的」，而是所用的方法不對而已，換個方法就是了。</p><h2 id="勇敢">勇敢</h2><p>既然達不到真理，那我們為什麼還要追求？</p><p>當然你也可以用現有的知識跟技術，就這樣生活下去。</p><p>很多的問題沒有好好地解決，環境問題、人權問題等等，我們仍舊可以依然固我地無視這些問題，繼續活在痛苦之中。</p><blockquote><p>「世界上只有一種真正的英雄主義，那就是在認清生活真相之後，依然熱愛生活。」——羅曼羅蘭</p></blockquote><p>我們認清什麼是真理，即便達不到真理，仍舊熱愛追求真理，稱之為英雄。</p><p>成為英雄，需要勇氣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天意外看到一段話，出處應該是《不用數字的研究 ：質性研究的思辯脈絡》一書。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;To achieve enlightenment, our political systems must relinquish their claims on truth, justice and freedom and have to replace them with the search for truth, justice, freedom and reason.&amp;quot;&lt;/strong&gt;&lt;br&gt;
– Immanuel Kant&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>可組合性（Composable）：Julia 語言的重要特性</title>
    <link href="https://yuehhua.github.io/2020/04/11/composable-the-key-feature-in-julia/"/>
    <id>https://yuehhua.github.io/2020/04/11/composable-the-key-feature-in-julia/</id>
    <published>2020-04-11T05:43:24.000Z</published>
    <updated>2020-04-11T14:42:46.670Z</updated>
    
    <content type="html"><![CDATA[<p>其實是受到 Julia 核心開發者之一 Lyndon White 的<a href="https://white.ucc.asn.au/2020/02/09/whycompositionaljulia.html" target="_blank" rel="noopener">文章</a>的啟發來撰寫本文的。</p><p>文章有 <a href="https://mp.weixin.qq.com/s/4_Sbi8q5EZDjHj6ouM1Ydg" target="_blank" rel="noopener">CSDNnews 簡中翻譯</a>。</p><p>本文並非以上文章的繁中版本，而是本人的一些心得及觀察。</p><h2 id="載入套件">載入套件</h2><p>比較深入了解 Julia 的朋友，會了解到這個語言的設計與其他語言的不同，像是 <code>using</code>。</p><p>當我們使用 <code>using</code> 來載入套件的時候，會發現有不少存在在 <code>Base</code> 中的函式是可以使用的。像是 <code>length</code> 可以用來取得陣列的長度，當你載入 DataStructures.jl 時，你同樣可以用 <code>length</code> 來取得 <code>Stack</code> 及 <code>Queue</code> 的長度。</p><p>或者是原文中的例子。使用者可以使用 <a href="https://github.com/invenia/NamedDims.jl" target="_blank" rel="noopener">NamedDims.jl</a> 來為你的陣列的維度命名，而你的陣列需要使用 <a href="https://github.com/JuliaGPU/CuArrays.jl" target="_blank" rel="noopener">CuArrays.jl</a> 送到 CUDA，這時候你不需要一個可以為 CUDA array 命名的套件來達成這件事。</p><p>你會發現在 Julia 語言中似乎不存在套件跟套件之間的差別，或是套件跟標準函式庫之間的區別。這是由於在 Julia 中對於命名空間（namespace）的概念較為薄弱，Julia 各模組之間仍然存在著命名空間，但是 Julia 在 <code>using</code> 時會將這些命名空間去除。這在工程上或許不是一個好的典範，因為會造成命名空間的汙染（namespace pollution）。反過來說，它促使人們相互溝通及協調，來提供更好的套件之間的可組合性。</p><p>在其他語言中，常常會告訴你，使用某個套件只需要載入你需要的部份，像是 <code>using Foo: bar, baz</code>，然而 Julia 並不去特別強調這點，<code>using Foo</code> 會載入套件開發者有導出的部份。如果有兩個套件都提供了 <code>predict</code> 來支援他們的模型，這邊借原文的例子再次說明：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Foo</span><br><span class="line"><span class="keyword">using</span> Bar</span><br><span class="line">training_data, test_data = ...</span><br><span class="line">mbar = BarModel(training_data)</span><br><span class="line">mfoo = FooModel(training_data)</span><br><span class="line">evaluate(predict(mbar), test_data)</span><br><span class="line">evaluate(predict(mfoo), test_data)</span><br></pre></td></tr></table></figure><p>這兩個 <code>predict</code> 分別來自雙方套件的各自定義及實作。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bar.predict(mbar)</span><br><span class="line">Foo.predict(mfoo)</span><br></pre></td></tr></table></figure><p>如此使用者便可以無縫地使用同樣一個介面 <code>predict</code>，而功能來自兩個不同的套件。</p><p>這樣的特性大概會有人聯想到介面（interface）。然而，Julia 並不明顯使用介面來規範開發者，Julia 隱含地使用鴨子定型（duck typing）。</p><p>在載入套件之後，Julia 允許使用者不冠上套件名稱來使用這些函式，像 <code>Bar.predict</code>，你可以自由地使用 <code>predict</code> 即可。總是會有套件之間的命名衝突，當衝突發生的時候，就是開發者需要負起責任彼此溝通及協調的時候。不過使用者仍然可以以 <code>Bar.predict</code> 的方式使用套件，只是每次載入套件的時候都會有警告。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">using</span> Gadfly</span><br><span class="line"></span><br><span class="line">julia&gt; plot</span><br><span class="line">WARNING: both Gadfly and Plots <span class="keyword">export</span> <span class="string">"plot"</span>; uses of it <span class="keyword">in</span> <span class="keyword">module</span> Main must be qualified</span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: plot not defined</span><br></pre></td></tr></table></figure><h2 id="鴨子定型及多重分派">鴨子定型及多重分派</h2><p>在原文中提到鴨子定型及多重分派是成就 Julia 成為一個可組合（composable）語言的基石。我個人也認為可組合是 Julia 提供最重要的特性之一，但卻鮮少被人提及。多數人仍然熱衷於語言效能及開發便利性。</p><p>鴨子定型的一個很好的比喻是，當一個東西會呱呱叫的時候，那麼他就是鴨子。當一個 <code>bar(x)</code> 可以呼叫時，我不需要去檢查 <code>x</code> 的型別為何，我就直接使用就是了。這樣會構成一種隱性的介面。</p><p>當我需要提供一個矩陣相乘的功能時，我會寫以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> multiply(A, B)</span><br><span class="line">    C = zeros(size(A, <span class="number">1</span>), size(B, <span class="number">2</span>))</span><br><span class="line">    A = A'</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>:size(C, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>:size(C, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">1</span>:size(A, <span class="number">2</span>)</span><br><span class="line">                C[i, j] = sum(A[:, k] .* B[:, k])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這可以用在一般的矩陣，但如果今天我有自定義的一個新的矩陣呢？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> NewArray</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上述的 <code>multiply</code> 中我只需要檢查 <code>NewArray</code> 是否提供相關的介面即可。像是裡頭用到了 <code>size</code>、<code>A[:, k]</code> 及 <code>sum</code>。我只需要支援這些介面的實作即可，如此，Julia 就可以以鴨子定型的方式，讓 <code>multiply</code> 接受 <code>NewArray</code> 了。</p><p>對於不同的型別需要有不同的行為，這在一般的物件導向語言中稱之為多型。多型在多數物件導向典範中使用的是單一分派（single dispatch），然而 Julia 也支援多型，但是以多重分派（multiple dispatch）的方式支援。因此，廣義而言，Julia 支援物件導向的方式是多重分派，卻不是典型的、語法上的封裝、繼承及（單一分派）多型。</p><p>多重分派，可以在需要更細緻行為定義時幫上忙。當 <code>NewArray</code> 支援 <code>sum</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray) = ...</span><br></pre></td></tr></table></figure><p>這是單一分派的方式，也可以有多重分派的方式。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray, ::<span class="built_in">Array</span>) = ...</span><br></pre></td></tr></table></figure><p>不過這樣只支援 <code>Array</code> 這個特定型別。或是我們可以乾脆這樣做。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray, ::<span class="built_in">AbstractArray</span>) = ...</span><br></pre></td></tr></table></figure><p>這樣只要是 <code>AbstractArray</code> 的子型別都可以接受。</p><h2 id="總結">總結</h2><p>以上種種的特性成為了可組合性的基石。一個具有可組合性的語言能夠成為各種東西。Julia 的個別的套件都不俱備所有的定義，需要依賴 Julia 語言及標準函式庫的介面及實作。</p><p>例如當 Julia 中載入了深度學習框架，那它，連同語言本身，就是一個完整支援深度學習功能的引擎。當同時載入了資料庫與深度學習相關套件，那它就成為了支援深度學習功能的 DBMS。當載入了科學計算及機器學習套件，那它就會變成一個強大的數值計算引擎。以 Julia 的可組合性出發，來打造各式各樣不同的引擎，就像一個單純的編輯器搭配有豐富的外掛（plug-in）一樣。這樣衍生出的生態帶來了各式各樣不同的可能性，也讓套件的 reusability 提升到最高的境界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其實是受到 Julia 核心開發者之一 Lyndon White 的&lt;a href=&quot;https://white.ucc.asn.au/2020/02/09/whycompositionaljulia.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>讓 Julia 像 Python 一樣擁有物件 property</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-property/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-property/</id>
    <published>2020-04-10T02:56:41.000Z</published>
    <updated>2020-04-10T02:56:41.889Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 的物件都有屬性，但這需要寫在型別中事先定義。但如果要為沒有任何屬性的型別增加屬性要怎麼做？</p><p>Julia 的屬性存取是來自 <code>Base.getproperty</code> 及 <code>Base.setproperty!</code> 兩個方法。</p><a id="more"></a><p>如果我們這樣定義。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">struct</span> Foo <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Base.getproperty(::Foo, x::<span class="built_in">Symbol</span>) = <span class="string">"<span class="variable">$x</span>"</span></span><br></pre></td></tr></table></figure><p>來測試不同的 property。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; foo = Foo()</span><br><span class="line">Foo()</span><br><span class="line"></span><br><span class="line">julia&gt; foo.a</span><br><span class="line"><span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.x</span><br><span class="line"><span class="string">"x"</span></span><br></pre></td></tr></table></figure><p>以及設定的部份。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.setproperty!(::Foo, x::<span class="built_in">Symbol</span>, v) = <span class="literal">nothing</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.b = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>不過要注意的是，如果對本身就有屬性的型別增加 <code>Base.getproperty</code> 及 <code>Base.setproperty!</code> 兩個方法，會去更動到原先的屬性存取行為喔！這邊要注意一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 的物件都有屬性，但這需要寫在型別中事先定義。但如果要為沒有任何屬性的型別增加屬性要怎麼做？&lt;/p&gt;
&lt;p&gt;Julia 的屬性存取是來自 &lt;code&gt;Base.getproperty&lt;/code&gt; 及 &lt;code&gt;Base.setproperty!&lt;/code&gt; 兩個方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>設定 Julia 多執行緒</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-multithread-setup/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-multithread-setup/</id>
    <published>2020-04-10T02:19:55.000Z</published>
    <updated>2020-04-10T02:19:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 從 v1.3 起支援多執行緒（multithreading）。</p><p>這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。</p><a id="more"></a><p>一般要在 Julia 中使用多執行緒，可以在啟動 Julia 時，以環境變數的形式指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JULIA_NUM_THREADS&#x3D;4 julia</span><br></pre></td></tr></table></figure><p>但不想在每次啟動時都加入，這樣會很麻煩。</p><p>我們可以將這個寫到環境變數當中。像是在 Linux 環境中，可以將以下環境變數寫到 ~/.bashrc 或 ~/.bash_profile 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JULIA_NUM_THREADS&#x3D;4</span><br></pre></td></tr></table></figure><p>Ref: <a href="https://docs.julialang.org/en/v1/manual/environment-variables/index.html" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/environment-variables/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 從 v1.3 起支援多執行緒（multithreading）。&lt;/p&gt;
&lt;p&gt;這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>編譯 Julia 套件來避免過長的載入時間</title>
    <link href="https://yuehhua.github.io/2020/04/10/compile-julia-package/"/>
    <id>https://yuehhua.github.io/2020/04/10/compile-julia-package/</id>
    <published>2020-04-10T02:06:04.000Z</published>
    <updated>2020-06-01T17:12:08.617Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（<code>using</code>）過於冗長。</p><p>Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。</p><p>為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。</p><p>PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。</p><p>近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。</p><a id="more"></a><h2 id="動態語言編譯">動態語言編譯</h2><p>在動態語言中，編譯一直是一個大問題。編譯時，需要知道更多底層的細節，像是變數的型別。例如 <code>foo(a::Any, b::Any)</code> 這樣的函式在動態語言中非常常見。Julia 會在呼叫 <code>foo(3, 4)</code> 時，經由型別推斷（type inference）知道它需要編譯 <code>foo(a::Int64, b::Int64)</code> 這樣的方法出來。當下次呼叫 <code>foo(3., 4.)</code> 時，則需要編譯 <code>foo(a::Float64, b::Float64)</code>。然而，要完整的編譯 <code>foo</code> 這個函式，需要編譯多少種方法呢？在型別的排列組合上會造成組合爆炸的問題，讓需要編譯的方法多到難以處理。這一直以來是動態語言無法完整編譯的問題點。</p><p>那麼 Julia 怎麼做？PackageCompiler.jl 套件的編譯來自於 JIT，所以它直接將 Julia session 中已經編譯的函式儲存下來，以利後續使用。編譯的函式會以動態函式庫（.so）的形式儲存，就如同其他語言一樣。然而，Julia 仍然沒有完整編譯，Julia 只有部份編譯便存入動態函式庫。若是需要使用到未編譯的函式，就會在使用時 JIT 去處理。或許可以藉由套件的測試來增加編譯的函式數目，例如提高測試的覆蓋度來儘可能觸發各式各樣的方法進行編譯，然後儲存下來。</p><h2 id="編譯套件">編譯套件</h2><p>這邊我以編譯 Plots.jl 套件為例，繪圖相關套件的載入時間總是異常地久，所以我選擇 Plots.jl 套件來舉例。</p><p>請確定 Julia 中已經安裝 Plots.jl 套件。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> PackageCompiler</span><br><span class="line"></span><br><span class="line">julia&gt; create_sysimage(:Plots; sysimage_path=<span class="string">"Plots.so"</span>)</span><br><span class="line">[ Info: PackageCompiler: creating system image object file, this might take a <span class="keyword">while</span>...</span><br></pre></td></tr></table></figure><p><code>create_sysimage</code> 會編譯並產生 sysimage，這個 image 可以在 Julia 啟動時一併載入，它會以動態函式庫的形式儲存下來。第一個參數請指定需要編譯的套件名稱，可以同時編譯多個套件，例如 <code>[:Plots, :Gadfly]</code>。關鍵字參數 <code>sysimage_path=&quot;Plots.so&quot;</code> 需要指定 system image 的檔名。執行後需要一段時間進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ls</span><br><span class="line">Plots.so</span><br></pre></td></tr></table></figure><p>編譯完成後便可以在目前的資料夾下看到編譯完成的檔案 <a href="http://Plots.so" target="_blank" rel="noopener">Plots.so</a>。</p><p>在下次使用時使用的話，請在啟動 Julia 時加入參數 <code>-JPlots.so</code>。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; exit()</span><br><span class="line"></span><br><span class="line">$ julia -JPlots.so</span><br></pre></td></tr></table></figure><p>如此，我們就可以看到在啟動 Julia 之後載入的套件就有 Plots.jl 囉！Plots.jl 套件的載入時間被包含在 Julia 啟動時間中。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.loaded_modules</span><br><span class="line"><span class="built_in">Dict</span>&#123;Base.PkgId,<span class="built_in">Module</span>&#125; with <span class="number">72</span> entries:</span><br><span class="line">  <span class="built_in">Future</span> [<span class="number">9</span>fa8497b-<span class="number">333</span>b-<span class="number">5362</span>-<span class="number">9e8</span>d-<span class="number">4</span>d0656e87820]           =&gt; <span class="built_in">Future</span></span><br><span class="line">  Requires [ae029012-a4dd-<span class="number">5104</span>-<span class="number">9</span>daa-d747884805df]         =&gt; Requires</span><br><span class="line">  RecipesBase [<span class="number">3</span>cdcf5f2-<span class="number">1</span>ef4-<span class="number">517</span>c-<span class="number">9805</span>-<span class="number">6587</span>b60abb01]      =&gt; RecipesBase</span><br><span class="line">  InteractiveUtils [b77e0a4c-d291-<span class="number">57</span>a0-<span class="number">90e8</span>-<span class="number">8</span>db25a27a240] =&gt; InteractiveUtils</span><br><span class="line">  Pkg [<span class="number">44</span>cfe95a-<span class="number">1</span>eb2-<span class="number">52</span>ea-b672-e2afdf69b78f]              =&gt; Pkg</span><br><span class="line">  Printf [de0858da-<span class="number">6303</span>-<span class="number">5e67</span>-<span class="number">8744</span>-<span class="number">51</span>eddeeeb8d7]           =&gt; Printf</span><br><span class="line">  Base64 [<span class="number">2</span>a0f44e3-<span class="number">6</span>c83-<span class="number">55</span>bd-<span class="number">87e4</span>-b1978d98bd5f]           =&gt; Base64</span><br><span class="line">  Test [<span class="number">8</span>dfed614-e22c-<span class="number">5e08</span>-<span class="number">85e1</span>-<span class="number">65</span>c5234f0b40]             =&gt; Test</span><br><span class="line">  Reexport [<span class="number">189</span>a3867-<span class="number">3050</span>-<span class="number">52</span>da-a836-e630ba90ab69]         =&gt; Reexport</span><br><span class="line">  Dates [ade2ca70-<span class="number">3891</span>-<span class="number">5945</span>-<span class="number">98</span>fb-dc099432e06a]            =&gt; Dates</span><br><span class="line">  DelimitedFiles [<span class="number">8</span>bb1440f-<span class="number">4735</span>-<span class="number">579</span>b-a4ab-<span class="number">409</span>b98df4dab]   =&gt; DelimitedFiles</span><br><span class="line">  LAME_jll [c1c5ebd0-<span class="number">6772</span>-<span class="number">5130</span>-a774-d5fcae4a789d]         =&gt; LAME_jll</span><br><span class="line">  Missings [e1d29d7a-bbdc-<span class="number">5</span>cf2-<span class="number">9</span>ac0-f12de2c33e28]         =&gt; Missings</span><br><span class="line">  __PackagePrecompilationStatementModule [top-level]      =&gt; __PackagePrecompilationStatementModule</span><br><span class="line">  Opus_jll [<span class="number">91</span>d4177d-<span class="number">7536</span>-<span class="number">5919</span>-b921-<span class="number">800302f37372</span>]         =&gt; Opus_jll</span><br><span class="line">  StatsBase [<span class="number">2913</span>bbd2-ae8a-<span class="number">5f71</span>-<span class="number">8</span>c99-<span class="number">4</span>fb6c76f3a91]        =&gt; StatsBase</span><br><span class="line">  libfdk_aac_jll [f638f0a6-<span class="number">7</span>fb0-<span class="number">5443</span>-<span class="number">88</span>ba-<span class="number">1</span>cc74229b280]   =&gt; libfdk_aac_jll</span><br><span class="line">  libvorbis_jll [f27f6e37-<span class="number">5</span>d2b-<span class="number">51</span>aa-<span class="number">960</span>f-b287f2bc3b7a]    =&gt; libvorbis_jll</span><br><span class="line">  REPL [<span class="number">3</span>fa0cd96-eef1-<span class="number">5676</span>-<span class="number">8</span>a61-b3b8758bbffb]             =&gt; REPL</span><br><span class="line">  x265_jll [dfaa095f-<span class="number">4041</span>-<span class="number">5</span>dcd-<span class="number">9319</span>-<span class="number">2</span>fabd8486b76]         =&gt; x265_jll</span><br><span class="line">  LibGit2 [<span class="number">76f85450</span>-<span class="number">5226</span>-<span class="number">5</span>b5a-<span class="number">8</span>eaa-<span class="number">529</span>ad045b433]          =&gt; LibGit2</span><br><span class="line">  Distributed [<span class="number">8</span>ba89e20-<span class="number">285</span>c-<span class="number">5</span>b6f-<span class="number">9357</span>-<span class="number">94700520</span>ee1b]      =&gt; Distributed</span><br><span class="line">  Plots [<span class="number">91</span>a5bcdd-<span class="number">55</span>d7-<span class="number">5</span>caf-<span class="number">9e0</span>b-<span class="number">520</span>d859cae80]            =&gt; Plots</span><br><span class="line">  LinearAlgebra [<span class="number">37e2</span>e46d-f89d-<span class="number">539</span>d-b4ee-<span class="number">838</span>fcccc9c8e]    =&gt; LinearAlgebra</span><br><span class="line">  ⋮                                                       =&gt; ⋮</span><br><span class="line"></span><br><span class="line">julia&gt; Plots.plot</span><br><span class="line">plot (generic <span class="keyword">function</span> with <span class="number">3</span> methods)</span><br></pre></td></tr></table></figure><h2 id="編譯到預設位置">編譯到預設位置</h2><p>Julia 在系統中有 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它預設會在 Julia 啟動時載入，我們可以利用預先編譯好的函式庫來取代它，就可以不用參數的情況下自動載入。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_sysimage([:Debugger, :OhMyREPL]; replace_default=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>將 <code>sysimage_path</code> 換成 <code>replace_default=true</code>，來將編譯的函式庫取代 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它會將原本的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 備份到 sys.so.backup，並將編譯好的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 寫入。</p><h2 id="增量編譯（incremental-compilation）">增量編譯（incremental compilation）</h2><p>sysimage 可以進行增量編譯。增量編譯是指既有的函式並不會重新編譯，只會編譯那些新加入的函式。如果已經有 sysimage，那麼下次呼叫 <code>create_sysimage</code> 時，只會編譯新加入的部份，並且用新的函式庫檔案取代舊的。</p><p>如果你想要關閉這個功能，那需要加入 <code>incremental=false</code> 來關閉增量編譯，這樣就會編譯一個全新的函式庫。</p><h2 id="利用套件的測試程式碼做編譯">利用套件的測試程式碼做編譯</h2><p>一般而言，在動態語言中，我們無法編譯所有可能的方法，取而代之的是，我們可以<strong>儘可能</strong>編譯更多方法。編譯更多方法越可能可以避免 Julia 啟動 JIT 在執行時期去編譯新的方法。這時候我們可以利用套件中的測試程式碼，當套件中自帶的測試程式碼，如果覆蓋率夠高，那麼就可以有越完善的編譯。這時候我們可以在編譯之前執行測試來促使 JIT 編譯各種方法。</p><p>我們可以利用以下程式碼來執行測試，並促使 JIT 進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Plots</span><br><span class="line">include(joinpath(pkgdir(Plots), <span class="string">"test"</span>, <span class="string">"runtests.jl"</span>))</span><br></pre></td></tr></table></figure><p>套件的測試期間常常會有其他的相依套件，缺乏相依套件都會使測試失敗。需要不斷執行測試，並且檢查及安裝缺失的相依套件。</p><p>等測試都執行完成了，就可以進行套件編譯了。</p><h2 id="編譯被使用的方法">編譯被使用的方法</h2><p>如果需要編譯被使用的方法，例如在特定腳本被使用到，這時候我們需要更細緻的編譯方式。我們需要知道哪些方法在腳本當中被使用到，這時候我們可以在啟動 Julia 時加入 <code>--trace-compile=precompile.jl</code>。<code>--trace-compile</code> 會讓 Julia 紀錄下哪些方法有被編譯過，並且輸出在 precompile.jl 檔案中紀錄下來。</p><p><code>--trace-compile</code> 會紀錄哪些方法需要預編譯（precompilation）。例如執行 <code>julia --trace-compile=precompile.jl -e '1+1'</code> 會得到一個 precompile.jl 檔案，其中測試了 <code>1+1</code> 的預編譯，並且紀錄下來。因此，會在 precompile.jl 檔案中看到以下內容：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.similar), <span class="built_in">Array</span>&#123;Base.Grisu.Bignums.Bignum, <span class="number">1</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.length), <span class="built_in">Array</span>&#123;Base.Grisu.Bignums.Bignum, <span class="number">1</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.deepcopy_internal), <span class="built_in">Any</span>, Base.IdDict&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.deepcopy_internal), <span class="built_in">Array</span>&#123;<span class="built_in">UInt32</span>, <span class="number">1</span>&#125;, Base.IdDict&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>這就是 <code>--trace-compile</code> 將需要預編譯的方法輸出的結果。</p><p>我們可以將這些結果放到 <code>create_sysimage</code> 中。可以在 <code>create_sysimage</code> 加入關鍵字參數 <code>precompile_statements_file=&quot;precompile.jl&quot;</code>，並且指定剛剛輸出的預編譯紀錄檔 precompile.jl。它會讓 Julia 根據紀錄檔中所需要使用到的方法進行編譯。如此就可以編譯在腳本當中被使用到的方法了！</p><p>Ref: <a href="https://julialang.github.io/PackageCompiler.jl/dev/sysimages/" target="_blank" rel="noopener">https://julialang.github.io/PackageCompiler.jl/dev/sysimages/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（&lt;code&gt;using&lt;/code&gt;）過於冗長。&lt;/p&gt;
&lt;p&gt;Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。&lt;/p&gt;
&lt;p&gt;為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。&lt;/p&gt;
&lt;p&gt;PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。&lt;/p&gt;
&lt;p&gt;近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia 的多重分派</title>
    <link href="https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/"/>
    <id>https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/</id>
    <published>2020-04-01T15:27:42.000Z</published>
    <updated>2020-04-01T15:27:42.500Z</updated>
    
    <content type="html"><![CDATA[<p>今天來談談 Julia 的多重分派（multiple dispatch）。</p><p>很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。</p><p>在現今的物件導向程式設計當中，我們會將函式歸納到某個類別底下成為其類別的方法，而這個方法就屬於這個類別。</p><h2 id="多重分派-v-s-單一分派">多重分派 v.s. 單一分派</h2><p>這樣的觀點就是單一分派的精神，單一分派是指一個方法的呼叫，要如何決定呼叫的是哪一個方法實作呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(x)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure><p>像以上的 python 程式碼，<code>foo.abc(x)</code> 就是去呼叫 <code>Foo</code> 的方法，而 <code>bar.abc(x)</code> 則是去呼叫 <code>Bar</code> 的方法。</p><p>也就是說，方法的呼叫是由第一個參數所決定的，這邊要注意的是第一個參數並不是 <code>x</code>，而是 <code>self</code> 喔！也就是物件本身！</p><p>相對於單一分派，多重分派是指他會參考所有的參數型別及其組合來決定到底要呼叫哪一個方法。</p><p>所以我們也有了更細緻的選擇。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(foo::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(foo::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><p>當第一個參數型別是 <code>Foo</code> 時，就回傳字串，而當第一個參數型別是 <code>Bar</code> 時，就回傳整數。</p><p>我們可以去區別，當 <code>x</code> 已經是整數或是字串時就不用去處理它，直接回傳即可。若是有不同型別時，個別處理。</p><p>這邊我們並沒有使用到第一個型別的參數，在 Julia 裡可以省略變數本身，只寫型別。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><h2 id="多重分派的自由與限制">多重分派的自由與限制</h2><p>使用多重分派可以讓語言有更細緻的定義，也有更高的自由度。</p><p>我們可以看看以下的例子，這邊使用了常常被使用的 null pattern：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push!(ls::List, obj::NullObject) = ls</span><br><span class="line"></span><br><span class="line">psuh!(ls::List, obj::Object) = push!(ls.array, obj)</span><br></pre></td></tr></table></figure><p>當我要去表示一類物件，我們會實作 <code>Object</code>，但往往我們會想要表示一個為空的物件，這時候我們就會有一個 <code>NullObject</code> 來表達這件事。</p><p>當我們想要將一個 <code>Object</code> 放到 <code>List</code> 中的時候，我們會實作 <code>push!</code>，然而當一個 <code>NullObject</code> 被放入 <code>List</code> 的時候，我們並不需要真的做什麼樣的動作。實作就會如同上面的程式碼。</p><p>相對在 python 或是一般物件導向語言當中，我們就會看到以下的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> type(obj) == NullObject:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">elif</span> type(obj) == Object:</span><br><span class="line">            self.array.append(obj)</span><br></pre></td></tr></table></figure><p>我們需要自己去判斷接收進來的參數型別，然後進一步做處理。這樣的話會讓我們的程式碼充滿 if-else，當條件一多時，會變得相當難以閱讀及修改。</p><p>使用多重分派並不是只有優點，他也有缺點。多重分派會引入模糊性（ambiguity）。</p><p>考慮以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b) = a</span><br><span class="line">foo(a, b::B) = b</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br></pre></td></tr></table></figure><p>請問 <code>foo(a, b)</code> 該呼叫哪一個方法呢？</p><p>這樣的呼叫在 Julia 會產生錯誤，也就是編譯器不知道該呼叫哪一個方法。</p><p>這時候編譯器會建議修改的方式，就是定義一個更明確的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b::B)</span><br></pre></td></tr></table></figure><h2 id="應用情境">應用情境</h2><p>我們來寫個簡單的剪刀石頭布遊戲！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Paper <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Scissor <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Stone <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們分別有三個型別分別代表剪刀石頭布。</p><p>接下來我們定義運算，先定義贏的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">play(::Paper, ::Stone) = <span class="number">1</span></span><br><span class="line">play(::Scissor, ::Paper) = <span class="number">1</span></span><br><span class="line">play(::Stone, ::Scissor) = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>當雙方是相同時就平手：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(::T, ::T) <span class="keyword">where</span> &#123;T&#125; = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>這邊我們利用了 Julia 的參數化方法，當兩個有相同的型別時，就回傳 0。</p><p>最後，是輸的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(a, b) = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>也就是，如果沒有符合以上的狀況的方法呼叫，就會落到這個狀況來，所以這邊我們允許最廣義的 <code>Any</code> 型別。</p><p>希望大家可以經由這個簡單的例子來理解 Julia 的多重分派有多好用，甚至是搭配上參數化方法根本是逆天阿！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天來談談 Julia 的多重分派（multiple dispatch）。&lt;/p&gt;
&lt;p&gt;很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。&lt;/p&gt;
&lt;p&gt;在現今的物件導向程式設計當中，我們會將函式歸納
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia v1.4 釋出</title>
    <link href="https://yuehhua.github.io/2020/03/24/julia-v1-4-release/"/>
    <id>https://yuehhua.github.io/2020/03/24/julia-v1-4-release/</id>
    <published>2020-03-24T04:02:05.000Z</published>
    <updated>2020-08-07T03:14:28.835Z</updated>
    
    <content type="html"><![CDATA[<p>Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。<br>底下新功能後面會有括弧，附註相關的實作程式碼。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><h3 id="使用者功能">使用者功能</h3><ul><li><code>import</code> 允許符號，例如 <code>import Base.:+</code>。(#33158)</li><li>允許使用 <code>a[begin]</code> 來存取 <code>a</code> 的首位元素。首位元素的索引是由 <code>firstindex(a)</code> 計算得出。(#33946)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; x[<span class="keyword">begin</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>值可以藉由 <code>$</code> 內插到 <code>@async</code> 及 <code>@spawn</code> 中，它會將值直接複製一份到閉包（closure）中。(#33119)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>結構 <code>struct</code> 當中，所有位元（isbits）或是位元聯集（isbitsunion）的欄位（fields）都會儲存為陣列的元素。(#32448)</li></ul><p>以前在 Julia 的結構當中，只有所有欄位都有相同的型別，而且型別都是原始型別時，Julia 底層會將他們封裝到一個陣列中，如此可以加速。在 v1.4 版後放寬了這樣的限制，讓有所有位元欄位都儲存為陣列。</p><h2 id="新功能">新功能</h2><ul><li>Iterators 模組中有 <code>accumulate</code> 實作。(#34033)</li></ul><p>Jeff 頗驚訝，之前怎麼沒有這個功能XD</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; iter = Iterators.accumulate(+, x)</span><br><span class="line">Base.Iterators.Accumulate&#123;typeof(+),<span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;&#125;(+, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; foreach(println, iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>功能與 <code>Base.accumulate</code> 雷同，但是屬於 lazy evaluation。</p><ul><li><code>evalpoly</code> 可以用來計算多項式函數，例如 <code>evalpoly(x, (p1, p2, p3))</code>。(#32753)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; evalpoly(<span class="number">5</span>, (<span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>相當於計算 $p(5) = 10 + 3\times5 + 1\times5^2$。</p><ul><li>允許複合函數（function composition）<code>∘(f, g, h) = f ∘ g ∘ h</code>，以及解開 <code>∘(fs...)</code>，當中 <code>fs</code> 可以是 Iterable 的函數集合。(#33568)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; f(x) = x + <span class="number">1</span></span><br><span class="line">f (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; g(x) = <span class="number">2</span>x</span><br><span class="line">g (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; F = f∘g</span><br><span class="line"><span class="comment">#64 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; F(<span class="number">5</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="新支援">新支援</h2><ul><li><code>gcd</code>、<code>lcm</code> 及 <code>gcdx</code> 支援 <code>Rational</code> 型別的參數。(#33910)</li><li><code>splitpath</code> 支援任何 <code>AbstractString</code> 型別，然而以前只支援 <code>String</code> 的路徑。(#33012)</li><li><code>filter</code> 可以作用在 <code>Tuple</code> 上。(#32968)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。&lt;br&gt;
底下新功能後面會有括弧，附註相關的實作程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>從 iterator 及 generator 到 iterable</title>
    <link href="https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/"/>
    <id>https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/</id>
    <published>2020-03-01T06:31:49.000Z</published>
    <updated>2020-03-05T16:32:51.101Z</updated>
    
    <content type="html"><![CDATA[<p>今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 <code>in</code> 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？</p><a id="more"></a><p>很基本的作法是去實作一個設計模式（design pattern）中的 iterator，假設我們要迭代一個陣列裡的元素，iterator 有別於陣列本身，是另外一個物件。Iterator 可以提供你一個介面，例如 <code>next()</code>，讓你可以取得陣列裡的下一個元素。</p><p>像這樣的方式很常見也很簡單可以實作，在 Julia 裡就像這樣：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> ArrayIterator</span><br><span class="line">    array::<span class="built_in">Array</span></span><br><span class="line">    index::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">    ArrayIterator(array::<span class="built_in">Array</span>) = new(array, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">has_next(iter::ArrayIterator) = (iter.index &lt; length(iter.array))</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> next(iter::ArrayIterator)</span><br><span class="line">    x = iter.array[iter.index]</span><br><span class="line">    iter.index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">2</span>:<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; iter = ArrayIterator(v);</span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>各位可以看到 iterator 一般都會實作 <code>has_next()</code> 及 <code>next()</code> 函式，是用來確認是否有下一個元素存在及取得下一個元素。Iterator 中會包含陣列本身，也就是想要迭代的集合本身，還有一個 <code>index</code> 會指向目前的元素，並在取得元素之後移往下一個。</p><p>Iterator 是一個物件，它需要一個已經存在的集合來作為它迭代的集合。這代表這個集合必須事先存在，如果這個集合很大，那就會佔去不少記憶體空間。有沒有什麼方法可以不需要集合就可以迭代的呢？Generator 是一個方式。</p><p>Generator，顧名思義，它會在你取得下一個元素的時候產生出來，並不會事先計算，所以集合也不會存在。Julia 的 generator 很好撰寫，如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (i^<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這就是一個會產生 1 到 10 數字的 generator。Generator 也可以被放到 for 迴圈裡被迭代，但唯一不同的是，它並不佔記憶體空間，只需要即時的計算即可。</p><p>Julia 目前提供的方式稱為 Iterable，只要有實作 <code>iterate()</code> 這個 API 的就稱為 Iterable。像以下例子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Character</span><br><span class="line">    start::<span class="built_in">Char</span></span><br><span class="line">    length::<span class="built_in">Int</span></span><br><span class="line">    Character() = new(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(char::Character, (el, i)=(char.start, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> i &lt; char.length</span><br><span class="line">        <span class="keyword">return</span> (el, (el+<span class="number">1</span>, i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.length(char::Character) = char.length</span><br><span class="line">Base.eltype(::Character) = <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p><code>iterate()</code> 的輸入是「狀態」，輸出是下一個狀態，而狀態包含兩個物件：要迭代的元素以及順序。因此，會看起來像是這個樣子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(el1, (el2, i+<span class="number">1</span>)) = iterate(iter, (el1, i))</span><br></pre></td></tr></table></figure><p>特別要說明的是，在輸出的狀態中，需要帶有目前元素的資訊 <code>(el1, (el2, i+1))</code>。如果要結束迴圈，那就回傳 <code>nothing</code>。我們就可以來世試看這個可以迭代輸出 ASCII 碼的 Iterable。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; c = Character()</span><br><span class="line">Character(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c, (<span class="string">'B'</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="string">'C'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> c</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br><span class="line">F</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣可以有 generator 的好處，而且本身也是一個 iterator。它不需要是一個物件，只要有實作 <code>iterate()</code> 這個 API 的物件就可以使用，所以我們還可以拿來這樣用。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> IterableNumber</span><br><span class="line">    start::<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.iterate(iter::IterableNumber, (el, i)=(iter.start, <span class="number">0</span>)) = i &lt; <span class="literal">Inf</span> ? (el, (el+<span class="number">1</span>, i+<span class="number">1</span>)) : <span class="literal">nothing</span></span><br></pre></td></tr></table></figure><p>這是一個可以自定義起點的可迭代數字，數字可以持續到無限大。你得手動把它停下來！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; iter = IterableNumber(<span class="number">0</span>)</span><br><span class="line">IterableNumber(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> i <span class="keyword">in</span> iter</span><br><span class="line">           println(i)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或是你想做個 sliding window：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SlidingWindow</span><br><span class="line">    vec::<span class="built_in">Vector</span></span><br><span class="line">    n::<span class="built_in">Int</span></span><br><span class="line">    start::<span class="built_in">SubArray</span></span><br><span class="line"></span><br><span class="line">    SlidingWindow(vec::<span class="built_in">Vector</span>, n) = new(vec, n, view(vec, <span class="number">1</span>:n))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(iter::SlidingWindow, (el, i)=(iter.start, <span class="number">1</span>))</span><br><span class="line">    <span class="literal">e</span> = i + iter.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">e</span> &lt;= length(iter.vec)</span><br><span class="line">        <span class="keyword">return</span> (el, (view(iter.vec, i:<span class="literal">e</span>), i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊用 <code>view(iter.vec, i:e)</code> 做取值的方式，比起用 <code>iter.vec[i:e]</code> 取值來的快很多。<code>iter.vec[i:e]</code> 這種方式會造出一個新的陣列，而 view 不會。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; sw = SlidingWindow(v, <span class="number">5</span>)</span><br><span class="line">SlidingWindow([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>  …  <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>], <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> sw</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這邊介紹了三種迭代的方法，而 iterable 則是目前由 Julia 官方支援的主流方式。除了可以迭代數字以外還可以有其他用途，甚至可以迭代直到無限大的數字。Sliding window 這樣的東西在計算上或是深度學習上是很實用的結構！是不是覺得 Julia 越來越像 functional language 了XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 &lt;code&gt;in&lt;/code&gt; 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>One-way ANOVA and sum of squares</title>
    <link href="https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/"/>
    <id>https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/</id>
    <published>2020-02-09T16:01:59.000Z</published>
    <updated>2020-03-09T17:07:49.402Z</updated>
    
    <content type="html"><![CDATA[<p><strong>An</strong>alysis <strong>o</strong>f <strong>va</strong>riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms <strong>explained variance</strong> (or <strong>between-group variance</strong> in categorical factor) and <strong>unexplained variance</strong> (or <strong>within-group variance</strong> in categorical factor).</p><a id="more"></a><h2 id="Sum-of-squares">Sum of squares</h2><p>Sum of squares come from the concept of calculating the (squared Euclidean) distance among data. Let’s consider the total sum of squares $SS_{total}$.</p><p>$$<br>SS_{total} = \sum_i (y_i - \bar{y})^2<br>$$</p><p>$y_i$ represents the true data value, $\bar{y}$ represents the mean of data $y_i$. We can get variance from $SS_{total}$ by dividing the <strong>degree of freedom</strong> ($df$).</p><p>$$<br>\begin{align}<br>Var[Y] &amp;= \frac{SS_{total}}{df} \\<br>&amp;= \frac{1}{n-1} \sum_i (y_i - \bar{y})^2<br>\end{align}<br>$$</p><p>The equation above shows the relation between sum of square and variance.</p><p>We always attempt to model the phonomena from data. Constructing the hypothesis or model and validate our hypothesis by testing their siginificant. If our model is true, then model must catch some variance and extract information from data for us. If the model is not true, model catch less variance just as the noise does.</p><p>So, we defined two kinds of sum of squares to measure how much variance is caught by model or not. We usually use a regression to model our data, so we have regression sum of square $SS_{reg}$, which represents the amount of sum of square explained by model. Sum of square other than regression sum of square is left as residual sum of square $SS_{res}$, which represents the amount of sum of square unexplained by model.</p><p>$$<br>SS_{reg} = \sum_i (\hat{y}_i - \bar{y})^2<br>$$</p><p>$\hat{y}_i$ represents the prediction value given by the model. If the sum of square is modeled, then the distance between the mean and the model prediction is explained by model.</p><p>$$<br>SS_{res} = \sum_i (y_i - \hat{y}_i)^2<br>$$</p><p>If the sum of square is not modeled, then the distance between the data and the model prediction is left unexplained as noise.</p><p>There is a relationship amoung them. We are going to proof it. However, the tools are not enough to prove it. We need the following two equations:</p><p>$$<br>\sum_i e_i = \sum_i (y_i - \hat{y}_i) = 0<br>$$</p><p>$$<br>\sum_i \hat{y}_i e_i = 0<br>$$</p><p>We start from $SS_{total}$.</p><p>$$<br>\begin{align}<br>SS_{total} &amp;= \sum_i (y_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i + \hat{y}_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + (\hat{y}_i - \bar{y})^2 + 2(y_i - \hat{y}_i)(\hat{y}_i - \bar{y}) \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + \sum_i (\hat{y}_i - \bar{y})^2 + 2 \sum_i \hat{y}_i(y_i - \hat{y}_i) - 2\bar{y} \sum_i (y_i - \hat{y}_i) \\<br>\end{align}<br>$$</p><p>Now you may see $SS_{reg}$ and $SS_{res}$ in the formula.</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res} + 2 \sum_i \hat{y}_i e_i - 2\bar{y} \sum_i e_i<br>$$</p><p>Due to the fact that the last two summation terms are zero. So we have:</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res}<br>$$</p><p>So now we have it! If we face a dataset, assuming that we know nothing about the data, we could only measure the mean and variance about the data.</p><p>Mean tells us the “location” about the data. If I told you the average height of whole people in the class, you prabably could have a idea or even guess <em>where data locate</em>.</p><p>Variance tell us the “range”, or formally “dispersion”, about the dataset. If the variance is large, we have high uncertainty about the data. Sometimes, we even know the mean, we still cannot guess the answer accurately, because we have no idea about <em>what is the scale of data</em>. In some sense, variance is associated with sum of squares(, and it truely is).</p><p>If we know the model in advance, we know the inner structure of phenomena and how the data is generated. That’s why we usually want to model things. If we introduce a model, it can help us extracting the inner structure (or information) from uncertainty. It reduce the uncertainty and give us information.</p><p>The total sum of squares act as the total uncertainty we face, and it can further be decoupled into two parts. If we have a model to help us, model extracts information and represents as regression sum of squares. The rest of uncertainty remains as <strong>residuals</strong>.</p><h2 id="One-way-ANOVA">One-way ANOVA</h2><p>ANOVA is a way to decouple sum of squares so that we can quantify how well the model is.</p><p>We can further make the ANOVA table as follow:</p><p>$$<br>\begin{array}{l c c c}<br>\ &amp; SS &amp; df &amp; MS &amp; F \\<br>\hline<br>model &amp; SS_{reg} &amp; k-1 &amp; MS_{reg} &amp; \frac{MS_{reg}}{MS_{res}} \\<br>error &amp; SS_{res} &amp; n-k &amp; MS_{res} &amp; \\<br>\hline<br>total &amp; SS_{total} &amp; n-1 &amp; MS_{total} &amp; \\<br>\end{array}<br>$$</p><p>Fill in the corresponding cell. Degree of freedom is about how many parameters you used to estimate your model. However, it is not always the case, you may want to read statistics textbook for some theoretical reasons. $k$ is the random variables you used in your model.</p><p>$$<br>MS_{reg} = \frac{SS_{reg}}{k-1} \\<br>MS_{res} = \frac{SS_{res}}{n-k}<br>$$</p><p>$MS$ means <em>mean of squares</em>, which it $SS$ divided by $df$. Moreover, we can calculate the F statistics for F test and the F test itself is so called <strong>one-way ANOVA</strong>.</p><p>$$<br>F = \frac{\text{explained variance}}{\text{unexplained variance}}<br>$$</p><p>F-value has its own meaning. It measures <em>how much variance is caught by our model</em> (or $MS_{reg}$), and it is a relative measurement, so it is divided by <em>the variance not caught by our model</em> (or $MS_{res}$). In aonother way, the model can <strong>explained</strong> part of variance, and the rest is left <strong>unexplained</strong>.</p><p>If the model we used is not something like linear regression, rather, we separate data into different categories. We used the following formula:</p><p>$$<br>F = \frac{\text{between-group variance}}{\text{within-group variance}}<br>$$</p><p>We could further test if the F-value is significant or not.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;An&lt;/strong&gt;alysis &lt;strong&gt;o&lt;/strong&gt;f &lt;strong&gt;va&lt;/strong&gt;riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms &lt;strong&gt;explained variance&lt;/strong&gt; (or &lt;strong&gt;between-group variance&lt;/strong&gt; in categorical factor) and &lt;strong&gt;unexplained variance&lt;/strong&gt; (or &lt;strong&gt;within-group variance&lt;/strong&gt; in categorical factor).&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>Relationship between variance and pairwise distance</title>
    <link href="https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/"/>
    <id>https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/</id>
    <published>2020-02-09T14:28:52.000Z</published>
    <updated>2020-03-06T07:55:43.094Z</updated>
    
    <content type="html"><![CDATA[<p>Random variable $X$, we have the variance</p><p>$$<br>\begin{align}<br>Var[X] &amp;= \mathbb{E}[(X - \mu)^2] \\<br>&amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2<br>\end{align}<br>$$</p><a id="more"></a><p>Pairwise (squared Euclidean) distance will be<br>Andrew Gerrand<br>$$<br>\begin{align}<br>\sum_{i \ne j} d(x_i, x_j) &amp;= \sum_{i=1}^n \sum_{j=i+1}^n (x_i - x_j)^2 \\<br>&amp;= \sum_{i=1}^n \sum_{j=i+1}^n ((x_i - \mu) - (x_j - \mu))^2 \\<br>&amp;= n \sum_{i=1}^n (x_i - \mu)^2 \\<br>&amp;= n^2 \mathbb{E}[(X - \mu)^2] \\<br>&amp;= n^2 Var[X]<br>\end{align}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Random variable $X$, we have the variance&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;
\begin{align}&lt;br&gt;
Var[X] &amp;amp;= \mathbb{E}[(X - \mu)^2] \\&lt;br&gt;
&amp;amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2&lt;br&gt;
\end{align}&lt;br&gt;
$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>程式設計師勝任程度</title>
    <link href="https://yuehhua.github.io/2019/12/11/programmer-competency/"/>
    <id>https://yuehhua.github.io/2019/12/11/programmer-competency/</id>
    <published>2019-12-11T07:08:58.000Z</published>
    <updated>2019-12-11T07:08:58.297Z</updated>
    
    <content type="html"><![CDATA[<p>先前看到了 <a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a>，所以就自己幫自己評比一下。</p><ul><li>Computer Science<ul><li>data structures: level 3</li><li>algorithms: level 3</li><li>systems programming: level 2</li></ul></li><li>Software Engineering<ul><li>source code version control: level 3</li><li>build automation: level 2</li><li>automated testing: level 2</li></ul></li><li>Programming<ul><li>problem decomposition: level 3</li><li>systems decomposition: level 2</li><li>communication: level 3</li><li>code organization within a file: level 2</li><li>code organization across files: level 2</li><li>source tree organization: level 3</li><li>code readability: level 3</li><li>defensive coding: level 2</li><li>error handling: level 1</li><li>IDE: level 2</li><li>API: level 1</li><li>frameworks: level 3</li><li>requirements: level 2</li><li>scripting: level 2</li><li>database: level 2</li></ul></li><li>Experience<ul><li>languages with professional experience: level 1~2 (familiar with OO language with functional patterns)</li><li>platforms with professional experience: level 2</li><li>years of professional experience: level 2</li><li>domain knowledge: level 2</li></ul></li><li>Knowledge<ul><li>tool knowledge: level 2</li><li>languages exposed to: level 2~3 (used Prolog before)</li><li>codebase knowledge: level 3 (I started a project before)</li><li>knowledge of upcoming technologies: level 2</li><li>platform internals: level 1~2 (not sure)</li><li>books: level 2 (actually used and read books)</li><li>blogs: level 3 (but not regularly update blog posts)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先前看到了 &lt;a href=&quot;http://sijinjoseph.com/programmer-competency-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programmer Competency Matrix&lt;/a&gt;，所以就自
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Name binding 與 dispatch</title>
    <link href="https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/"/>
    <id>https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/</id>
    <published>2019-12-01T02:49:40.000Z</published>
    <updated>2019-12-01T02:49:40.195Z</updated>
    
    <content type="html"><![CDATA[<p>Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。</p><p>Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。</p><a id="more"></a><p>一般而言，當物件被去除綁定，那物件將會被垃圾回收（garbage collection）機制給處理掉。</p><p>Name binding 依據時間分為：</p><ul><li>Static binding (or early binding)：在編譯時期（compile time）進行綁定</li><li>Dynamic binding (or late binding)：在執行時期（runtime）進行綁定</li></ul><p>Static binding 的一個經典例子是 C 的函式呼叫，它在編譯時期就將函式內容綁定到識別符上，而無法在執行時期變更。</p><p>Dynamic binding 的一個相對應的例子則是 C++ 的虛擬方法呼叫，由於多型的機制，物件的型別無法在編譯時期得知，所以綁定會在執行時期處理。</p><p>在執行時期，如果識別符變更參考到其他的物件，我們稱為重新綁定（rebinding）。如果是變更識別符指向的物件本身，那麼我們稱為突變（mutation）。</p><p>在這邊提到多型的機制，就不得不去提 dispatch 的機制。一般在物件導向語言中以 dynamic dispatch 為主，表示在多型機制下，方法的選定是由第一個參數的型別來決定。</p><p>Dispatch 是個選擇的問題，而 binding 是個綁定的問題。選擇一定要發生在綁定後。</p><p>Dynamic dispatch 可以是 static binding 也可以是 dynamic binding，但是 dynamic binding 就只能在執行時間做 dispatch 了。</p><p>Dynamic dispatch 一般指 single dispatch，也就是由第一個參數的型別來決定要呼叫哪一個方法。相對也有 multiple dispatch，就會利用所有的參數型的排列組合來決定要呼叫哪一個方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。&lt;/p&gt;
&lt;p&gt;Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Compiler" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Compiler/"/>
    
    
  </entry>
  
  <entry>
    <title>魔術數字</title>
    <link href="https://yuehhua.github.io/2019/09/06/magic-numbers/"/>
    <id>https://yuehhua.github.io/2019/09/06/magic-numbers/</id>
    <published>2019-09-06T06:35:26.000Z</published>
    <updated>2019-09-06T06:35:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>很多人在寫程式的時候會有些壞習慣，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X &#x3D; rand(3, 4)</span><br><span class="line">for i &#x3D; 1:3</span><br><span class="line">    for j &#x3D; 1:4</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可能多數人看以上這段程式碼並沒有什麼特別的感覺，但是如果要維護的時候就會發現你突然不太理解這段程式碼。</p><p>有人知道這邊的 <code>3</code> 是什麼意思嗎？嗯…或許可以從上下文猜出來是陣列的列數的意思。</p><p>一旦要更改陣列的大小的時候勢必就要更改這些數字，甚至這些數字散落在程式碼的各個角落就會更加頭痛。</p><p>這些數字稱為魔術數字（magic numbers），因為沒有人知道他的意義是什麼！</p><h2 id="解法一：使用常數">解法一：使用常數</h2><p>如果這些數字很常被使用到，而且不會在程式中被變更，請使用常數，像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ROWS &#x3D; 3</span><br><span class="line">const COLUMNS &#x3D; 4</span><br><span class="line">X &#x3D; rand(ROWS, COLUMNS)</span><br><span class="line">for i &#x3D; 1:ROW</span><br><span class="line">    for j &#x3D; 1:COLUMNS</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如此，以後要更改陣列大小只需要更改常數即可，也讓程式碼的可讀性上升。</p><p>如果你的程式會更改到這些數字，那麼就用變數。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rows &#x3D; 3</span><br><span class="line">columns &#x3D; 4</span><br><span class="line">X &#x3D; rand(rows, columns)</span><br><span class="line">for i &#x3D; 1:rows</span><br><span class="line">    for j &#x3D; 1:columns</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="解法二：動態">解法二：動態</h2><p>如果陣列的大小不是事先知道的，或是需要動態取得，那麼可以用 <code>size</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1:size(X, 1)</span><br><span class="line">    for j &#x3D; 1:size(X, 2)</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如此可以用在未知大小的陣列上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多人在寫程式的時候會有些壞習慣，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 的 inbounds</title>
    <link href="https://yuehhua.github.io/2019/09/06/inbounds-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inbounds-in-julia/</id>
    <published>2019-09-06T03:17:13.000Z</published>
    <updated>2019-09-06T03:17:13.549Z</updated>
    
    <content type="html"><![CDATA[<p>有在做套件開發的開發者們應該不陌生 <code>@inbounds</code> 這個 macro，在很多現代程式語言中也有。</p><p>在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。</p><p>邊界檢查會檢查所存取的索引值是否在陣列的範圍內，但是這樣的檢查會有些微的效能損耗，尤其在迴圈內的情況更有可能被累積而放大，關於 Julia 的 邊界檢查可以參考官方文件 <a href="https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html" target="_blank" rel="noopener">Bounds checking</a>。</p><p>如果可以確定所存取的索引值一定在範圍內，我們就可以把邊界檢查給移除，以加速陣列的存取。如以下範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; rand(3, 4)</span><br><span class="line">@inbounds for i &#x3D; 1:size(A, 1)</span><br><span class="line">    println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>或是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; rand(3, 4)</span><br><span class="line">for i &#x3D; 1:size(A, 1)</span><br><span class="line">    @inbounds println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>@inbounds</code> 會將程式碼區塊中的邊界檢查給移除，可以參考 <code>@inbounds</code> 的<a href="https://docs.julialang.org/en/latest/base/base/#Base.@inbounds" target="_blank" rel="noopener">官方文件</a>。使用時必須注意存取的索引值，否則小則存取的值錯誤，大則可能導致程式崩潰。</p><p>先養成好的索引習慣，再考慮將效能提升，加入 <code>@inbounds</code>。相關的資訊也紀錄在官方的<a href="https://docs.julialang.org/en/latest/manual/performance-tips/#man-performance-annotations-1" target="_blank" rel="noopener">效能建議</a>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有在做套件開發的開發者們應該不陌生 &lt;code&gt;@inbounds&lt;/code&gt; 這個 macro，在很多現代程式語言中也有。&lt;/p&gt;
&lt;p&gt;在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。&lt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 中的行內函式（inline functions）</title>
    <link href="https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/</id>
    <published>2019-09-06T02:34:58.000Z</published>
    <updated>2019-09-06T03:16:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>剛好看到一些跟編譯器相關的議題，所以來紀錄一下。</p><p>在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。</p><p>最知名應該是 C 跟 C++ 的 <code>inline</code>。</p><p>Inline function 會在編譯時期直接將函式內容展開到程式碼中，不過展開與否是由編譯器決定的，<code>inline</code> 的標記只是告訴編譯器這個函式可以成為 inline function。</p><p><a href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank" rel="noopener">Inline expansion</a> 就是編譯時期會由編譯器執行的一個動作，看起來與 macro expansion 相似，但不同的是 macro expansion 是在前處理（preprocessing）時期做的，會直接展開在原始碼裡頭，而 inline expansion 則是在編譯時期做的，會在呼叫位點（call site）直接展開。</p><p>展開後編譯器便可以進行最佳化，執行時，就不需要做函式呼叫，也不會在 function stack 上多配置空間。一般使用在短小的函式上會有好處，在巨大的函式上使用不一定會有好處。然而過多的 inline function 反而可能造成過多的指令快取的消耗，造成反效果。</p><p>在 Julia 中，編譯器會自動偵測哪些函式可以被展開，會自動做 inline expansion。一般短小的函式會自動被編譯器判定要 inline，不過也可以由程式設計師自己指定哪些巨大函式可以 inline，可以參考[文件]](<a href="https://docs.julialang.org/en/v1.2/base/base/#Base.@inline" target="_blank" rel="noopener">https://docs.julialang.org/en/v1.2/base/base/#Base.@inline</a>)。</p><p>除了 <code>@inline</code> 以外，還有 <code>@noinline</code>。為了避免過多的 inline 反而傷害效能，也可以標記一些短小的函式不要 inline。</p><p>範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@inline function bigfunc(x)</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>相關技術：<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">Inline caching</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;剛好看到一些跟編譯器相關的議題，所以來紀錄一下。&lt;/p&gt;
&lt;p&gt;在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。&lt;/p&gt;
&lt;p&gt;最知名應該是 C 跟 C++ 的 &lt;code&gt;inline&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Inl
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>一次開源專案貢獻經驗</title>
    <link href="https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/"/>
    <id>https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/</id>
    <published>2019-07-08T14:08:04.000Z</published>
    <updated>2019-09-06T03:19:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。</p><p>我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。</p><a id="more"></a><p>起初，我只想用最簡單、直接的方式可以相容於原本的 API，並且達到我想要的功能。</p><p>後來專案的審查者希望我將較為底層的功能一起做調整，在不是很情願的情形下，我提出了我認為比較好的修改方案。畢竟動下去等於是整個架構要重新改掉了。</p><p>幾次的來回討論以及確認目標後，我確實需要把這部份的功能全部打掉重做。</p><p>其中包含審查者注意到 Julia 是個 column-major 的語言，原本的 row-major 的計算方式要改掉，以讓效能最大化。要如何處理 API 的更動，無非是加入 deprecation warning，然後還得考慮預設值的問題，在這邊審查者一直無法決定預設值該是什麼。</p><p>再來是，由 API 將資料收進來之後，該如何有效率而優雅地處理資料是個問題。有效率代表程式碼不能有多餘的動作，包含多餘的記憶體耗用、轉置與否。優雅代表 API 底下設計的函式之間的轉換跟呼叫也需要保持簡潔跟可讀性，如函數式程式設計般簡潔，如物件導向般可讀性，不能有重複的程式碼（Don’t repeat yourself, DRY）。像是在 API 下層還要繼續設計 API 一般，直到最底層演算法都要保持這樣的原則，你不會有機會做骯髒的手腳。</p><p>來來回回在 PR 上的討論，一則都會有十行以上的文字。想必工程師最討厭的就是需要不斷地跟別人溝通想法，會不斷有想法拋出去，也不斷地被否決，理由通常都是這麼做不夠簡潔、不夠有可讀性、不夠有效率。</p><p>不過我想我們的目標是一致的，希望貢獻開源專案，無非是將好的東西貢獻到專案上。種種的批評跟新想法都是促進彼此的成長，有時候是我的方法不夠有效率，有時候是審查者的想法無法通過自動測試，這時候他會為他的想法道歉。我也曾經誤解了他的英文，讓他需要再重新解釋一遍。</p><p>很多時候會遇到一些挫折，像是我覺得他這樣做超級蠢，或是我辛辛苦苦改完一個版本上傳，但是對方卻隔了一個禮拜沒有來看。我想除了技術以外，如何跟別人溝通就在這裡展現出重要性。我講講我自己的心法：</p><ol><li><p>開源專案是大家一起討論出來的結果，沒有辦法說是誰的 idea，除非你真的貢獻超級多或是是專案的擁有者。</p></li><li><p>溝通的時候先溝通目的，將目的說明清楚，別讓別人摸不著頭緒或是不斷猜測浪費時間。</p></li><li><p>溝通時請儘量客觀而表達明確，有必要的話，直接寫一個小的例子。</p></li><li><p>不斷來回的議題通常會產生一些負面情緒，請耐著性子跟對方解釋清楚。在做的好的地方不吝給個稱讚或是表情符號。</p></li><li><p>你認為是對的事情就該明確講出來，將事情說明清楚就好，不需要過於強烈的用字。</p></li></ol><p>到目前為止，PR 都還沒 merge，卻已經歷時了兩個月，累積了 93 次的對話，產生了 15 次的 commit。增加了 339 行程式碼，刪除了 112 程式碼，diff 100%，意味著所有程式碼都被我修改過了。不過我想這不會是最後一次，不過會是一次蠻特別的經驗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。&lt;/p&gt;
&lt;p&gt;我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
    
  </entry>
  
  <entry>
    <title>運算 Julia 參數型別上的值</title>
    <link href="https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/</id>
    <published>2019-05-06T05:56:52.000Z</published>
    <updated>2019-09-06T03:19:59.125Z</updated>
    
    <content type="html"><![CDATA[<p>之前介紹過將值放在參數型別上。</p><p>今天來介紹一下如何可以做到類似運算的效果。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a1 = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">a2 = A&#123;<span class="number">3</span>&#125;()</span><br></pre></td></tr></table></figure><p>在一些應用場景上會希望將參數欄位上的值做運算，例如加總。</p><p>這時候我們可以這樣做：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Base:+</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> +(::A&#123;T&#125;, ::A&#123;S&#125;) <span class="keyword">where</span> &#123;T, S&#125;</span><br><span class="line">x = T + S</span><br><span class="line"><span class="keyword">return</span> A&#123;x&#125;()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以簡單搞定囉！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(a1 + a2)</span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">8</span>&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前介紹過將值放在參數型別上。&lt;/p&gt;
&lt;p&gt;今天來介紹一下如何可以做到類似運算的效果。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>彰化行</title>
    <link href="https://yuehhua.github.io/2019/03/11/changhua-with-ning/"/>
    <id>https://yuehhua.github.io/2019/03/11/changhua-with-ning/</id>
    <published>2019-03-10T17:19:06.000Z</published>
    <updated>2019-09-11T12:50:34.574Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Enter password to read the article</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="3815e404e28251f2aa216d376639685ed9a8f54150c59eba8f8390c7ce4d096c">999302eb3da7ba0830f0d4430dd24ff4e338e2068524d9e60b85b93fd82eb6496ac5b6e68e9e454804fe0df94e0eec66f38528b520d44e36d91ae62b8c8517268ba45789e4a5831ab98cbd2c8bab4eb3772a0d4f59d8888e75380e3d1a667ba69eb22f0f7c4c328da923eea82afe8cdba2f114a8d409b6d8d709fb555d8fed0b74129534d47165114470049deeaf37ad377430daf9514f69ddb5102a535953b7bff718c5a3a516aa32b10354df91745a234bb6a0b227f13dd085e115f42c735a0dd4773aeabe28c4d2878cc1d8ea89af548368e7723b95eb1ad15ace513cd28a63748c2e4d0bc6d368069ecdbe38ddadb500d0010a1012bdfa174d1b18f103827c8d75a87b8d2004f9c5df1776ecf2efbdfa7d77e9a4ae2ee825f917026ae9bfb185e593e62d7ae895d93e5cf16422499532ddcd28436bc91551d6e5a6779cfb7ef6ad202dccd3b13ddf30e5cece6597e5157646b9b7ae44520d426285fa9d2ae0112d31c4af83dcbfeaf86da38bde7376e9d3a0421913db00a526c1872b7a51a1162b40698189e5af252984244b0ae0a49ba566787c4c29f7a7f8dc3d9e4aca4234ee1abae5fdc0fe51e59f17ba2cf44952fd35537b22bb1bd7e6480ff781672c2f5a53cd515c7e8caac3dfae67f78840ee6961a174519d854a3ab2ea61d1fb4a9986d46f2d7ca8902a2cd5e2b78a70c86973fdcdbc07b99fc7728ecc6780c34b400f4231a3342add16f7ef6453d2fca047f1caffd13b66df4417892f8fa8385c6ac8de32c2028f4fb84ba5cff3dfe46a5f6defe2fe48e832af84d3ae5b0d914c1e0ef3f32e1e0fc1d58f28abbdc00df6b72c7effc376ac9a9fb6eb81d91070f77d7b961a13f125f08c7f2bf671f44660d40cd7784e2e54bf9d1500b0f88c46be209b1c3d774c3e02451092dc3b67be05664cd45ae271fa6f4124074a18a51da797428fca161213e8fe5be6879574b3c7117d318d08ea1845cb600857b61a59727b76b63a114e845e507a929440fa222c27c1f95fd0acac5171a642d2571d044102e4f4c597e8965163e4a13670816b1244686d936521aae807020f6074a4d01893c9441f168e7a8030ff8b232329a28c7cddf3597425832b333cd362829407c8259ab7e09a93a517b45256cdd5a90fdeba31ec8b0b5ece3ead908784a14384170b25fb93e86eabc0b241d5db33282fd1ec1afe3b5c15f83813bb0f3ea1a3338e24fcf28a784c3b71798761ee7ace4fcb4b58fdf918c87c2ff6fe88f1a497a9676229735c88b864b875d5566b5457ec50891630e16af3ad2a6d124dd08b0fa721147a495a52cb57728bfcba558ef7ca3fa1a8e31005a561eddbc607f1adb05826575996a205b2363b0c9307f66e7805acdfdb07937212824b5d3314b370e8e878bf024efe01e1b18a9435ae61dcf756ff7d41683a9c20e0ebec26f051e3a9f7a90315c60d3043211520eeae02036a86eef2d52f50c23db32015fd276f6147686362b08756f02752f2de9d807d053a00aa795509272e20b67642704d1d67904967ed8561e7eaf63bdd07ff4bdddd49e24933b9626509e8b4a676d5452e461a1bef1aa06a190eeb8c3c1a8041140c98ff1227e89d53095774ecabe752c93b194a3be93db8a2695abbc57a5687d3fa4bd90275bf3146667fb248287cbd8297077015b9ba6ddbdb7ec1cbeabc04e8c983fc5a39e5659b45537558a088691ef24d404fe498aeb7d80aeb7495df582527d62a3757658515c05dccf5485ed8f8e0136f5bccd02419a012a4605918ed13efb1976c3bb502eb8ce8e06c4755cad0c358517612cd8c00486cc88d8d57b983151e379859570ee6d86bdec1bcc3ec580d97b4f1ebcaeb1d78ed51913e1a88f242aea91144d02f4b4b58c2d3dca37cf767474a21cb133605eb9366b3c2787aea01afacd8c7d099cf0f46dc39be5b38bc64cff9ef520e33ee0edbd1274b912b3773720848a08aa0f095b6b84d6c5f7c79339ab1395704f7a3d82e376a24f99435eb32d178da743a1fab1bf62fc03843b415c64b8c876dea4fabfbddf13618ce934705af2e58d0e94749c62ce5dfb52c5a7a94a6117638ecee53fbbd5fcf68ea400565966826b60330857ecceeeba4a7e7b86705b572acc1f76764a5fcef4bbf4e7c3bda3e04726cbfccaa268ecfb12ea497fc04a8588bd17d857ef6486890ff20cb4f0e911546aa6b9d1c2ed1bfd31459a53e967e400bc723088a67181c8584fe703700dfeaf08e7c8f07a08096f8ef3fbf26f855a0035744fe7c71ca18b6cb82c79cbc1f5870d132a8fc3631e0716c20e615d512b6f10b5ea44eae5c7c0e1daba48a8d778492dfa25d0122a96865999ec0df3c98a3af82d7b7ae942b6da80a158d74500f1981648e6f921de3d771aa83bb8ac9ff173b007bd6285b1460e41e061b5ecc3ae388a1855459498cc1e80606993904e85f165d4e67382b6b968cb65f6d45d0371c3211791902475c5d4aba5dae375a56b9766d2e0b669f08436fdbe4e4d21810bf9df82add67fd1e6538e912026cbe3308c2853b425ee41fe9e3952d4fdcb99013ac4232273735eec0faa8cdee9f4a330302aee85332ee687df4a05bd0f6f0b1fd903336b7e48b3d3c125e65ff8caa128d57cc54f8a12dc7364b75078ba9348f5a8fefccfa8d9502ae67aaa8ce3cd3537b9450a4016e702b71289f72076141317597dd665a6cd27c898543bd23bac8b860b1f1eff4f8a88c9e006aa521904915557de61b3247e898156eeb5c477ba97db23e3e6f3e3e46c0fc7370a54a006ed3c014d3b26c2d4dd78feb12c1703901874f8c84f2dc148e797e1e0faf2d4a727ad5d477cd7d96a68c5bc861be829352841780a7386e8d50cf424b8f9d3b170bcbc6db98b7da66a041c54b98949a21f746e6bd7016899b55e0977941d49d49969acdc00f7f5240094eb05d2d3f190d05d5f1713d3c6b83951508eb4de23c02d856a66c64ccc71c4d23b348102650c86c66908f20d690d4ccf5a9f9f17689993e11243bb8d1e85427cfa2b7dc7d8c4d7e7509b6c92cacf604994974bdf587d1a3356414196742050cc9c79a983094336b6e3b20e7ed74bf769699416b459eca57d6c069868b1c61c70035a1009ed80c0917f4484c4e0f72ee16af24302e13230665e571366e1aca3b5cc57a997d5951eb3bebefaa971f1fe878aab143ead2329a1bfd65d2f2332864dfebfed2b778311667b527df6497ebd0cf261b08cc8090076d4a758a536d6d3ba2c68b89b77c61d300fd5f7bd22b3b6f7a3f8c1b87c7db796957804cf0ba805cf7b1aac1ddde96c194b76e51bd3e4e77f5589e3b0c9a0229f17f64f914f3219d8c822f72f018205f62222c489d045a5e6c7c0c7cd5fd9821a129a5a0025742ba9c965c1fbbeaedf4d346a671cf259af8debd94e6dd309b4a22bec1b4a4e54b1c71a343d6643b531ff1930d7b52183488aea4ba81bd118435d4f8a02f8cd416877ec662d0973421c9f533d8e265f0c045edc5cfd0c94aa8426370b88ff028058c18bfff30d23f46ee272d4a53da19c20a0ec78fd2aeb7f7e1eb5e01f10b01d1a87b3d70f7dc57029d0844b116f6fc77009bbd8b1ff7b124e0d870f2037acb0f87cdc00f15aa1cc671814bcec30dbbe93aa82401718804772b2e0fab79511c92c26826fc2fca2d96afaf5a31ec8138e9798e3633dff8e802e528d432eb562ad3ea01646c878932b02da36a177854e68d86c8d6ae482248ac55ced934c799278b8561429b9e457901e4fa52eb97fe85180ac386c533bab26dddd5b148cab522dfce77e5c85b21dfbc56b446563671aa7602c1e200e84eceaeb58b9982c20eb8b4d6f5bc8f4ab754a9135bfc55959c6d9ad77f7fadd10e2eb5fc7327074dc891dda751d05dd58f4c5da3fb2c0024400ad5929a4eda88e5e498cebcee9872d8efd01c6f1f95ffa2d69d68d3cbf09ab741652df9559b8ff66774efb16de887470b31947ab18ee20524555fc34e663756766d71aa3d31f45970406fa40ce86e57c86c6504384597334dd3a4fe097cdcf3b6f51cfd7fe043af898361980e7e89e4802ac281eed5c9e13e4b18f2246708c5832d40845cb00d95d830a6d743adffec2248b28fd646c2bffb28f0f1a1c91339d8b8238503a88a65583ed8e2b8f608e85779a5277600a496ae130395d6a6d5e964af1e5c8ebee0daae2e3c7c29be9f368e95e0f8457cd9df85e94056881ccd2d8bcd9ff7e8fd576a8ed14f3d7a42a1f76f5bcc57c426905b8fcce12034edb6f486115b156584dcc004484bf9e2e9dbea3edfae955163a95c1cafbe0a664d760fd5f67804386ed5031278b3b96414ae2240f7b44df5e59537725c97c214997d3c842b781e14cbe16f2fda55b1acb2834b2fd15be5a446f9f211ee039aeaf53591d95a9e7459970dde5f74b2b920b514981ba5ae56213bfb39234a2ebf0baf74693d88bf6dea699bbd44e41a58d36fafde72e46f628b1b34034432053cedbf5c50208618b02ca449312493e4e0866e4c18c21f2495b80cdad58545ca12073d45880369022738eb01cf59db539e48be9554e3596718362b0e8df8296c4fc83a8866e2ea2f4d4f6f0aa530da0bbc1cb2668bcf1d1d598692df869e12f7a354cea568096fe732e5ed6361c62ebc1cb578ad1c31a67d95235596012e68f94f22a6b17b0fd2b11940d5f980351bbe7d4c44971a46ab0066d50d734ffdf5ee6bd6c99cd7e95129dfe3414c32787bb46d3e20b2dcf2b16b1388afe4127da3a11d46d908fb976269c1efda70dddefe9c014da408535fed7efb9f0cfed3386daac91d5f9851391caa6efbc35da868ef1efe304e18f86a3c5bcfe5ff14e5a752b00fdd749c5f4f495d8e987fcb1ead3aa6c0d69dd106eef8439353f6faa0e2af7e295a96fb9b57404f3ef87984411a2a717688a7bd58b657115c3b758f42498eda37601329c974ce537f1b027003b0c54bc43016322ba19bf08c5d661d5e74a57b4f93a7a8e00bcc3bf3ffb4af9b037e009650a56adc87cabeef4f7f809eb00888e091ac65725117a4d83b7cb4a586db62846e47c3b5f188aac65d773090c59f8ebc70242df738c1cdd858606346d7bfa77df0a01b41d01aea497396cda6e5468ef8632db399a31b7b52e730dad45178ef1c7946d4faee311a5a11383490120c58553df4c6a6ff7601aabdcd5a28346ef83fcf7d24b38bd640b521628e9d0483b03f295ee1e0c110db8298c76bf1563f84c3756b80aa212cb3e74b2840e802b790eb20ec571e22e57d480b67df443fbfbe449b2cacbf598b2cc1567229497a329c82fd88dbe4b3fb53127ff227e1167ae8b696daf6f58f99d8ae6b38ff3d23efd6ebc478724cd4896cecad71607d6936641388abe802852eaa32da359becff255d9623b1e176a97ac500a9e1571cef23e9</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Private post
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Friends" scheme="https://yuehhua.github.io/categories/My-Style/Friends/"/>
    
    
  </entry>
  
  <entry>
    <title>金錢是最廉價的表達</title>
    <link href="https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/"/>
    <id>https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/</id>
    <published>2019-03-01T04:20:45.000Z</published>
    <updated>2019-05-06T05:59:11.172Z</updated>
    
    <content type="html"><![CDATA[<p>人們常常對自己的親人朋友表達情感。</p><p>很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。</p><a id="more"></a><p>我認為利用金錢來表達這些情感非常的廉價。</p><p>金錢並不包含一個人想表達的情感跟意志。</p><p>除了金錢以外，還有什麼是更珍貴更值得付出，更能表達誠意的。</p><p>是時間，你花時間寫的文字比罐頭簡訊或是七彩的卡片溫暖，花時間做的料理或是點心更能彰顯你對另一半的關愛。</p><p>那些以金錢買來的禮品、請客，比不上更真誠的陪伴跟暢談。</p><p>對我而言，我不會讓摯友跟親人以金錢取代真摯的情感。而那些會接受以金錢表達的，多半是泛泛之交。</p><p>相較起時間的付出，金錢真的非常廉價。我始終不認為金錢可以買到友誼、愛情或是親情。如果有人買到了，那一定無比虛假。不過或許可以用金錢買到專業跟努力。</p><p>現代人生活節奏很快，時間更是珍貴，所以願意付出時間的人才是重視對方的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人們常常對自己的親人朋友表達情感。&lt;/p&gt;
&lt;p&gt;很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
</feed>
