<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Maker</title>
  
  <subtitle>Love Math, Science, Biology, Computer science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuehhua.github.io/"/>
  <updated>2020-10-12T03:52:42.354Z</updated>
  <id>https://yuehhua.github.io/</id>
  
  <author>
    <name>Yueh-Hua Tu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 Julia 對設定物件欄位增加檢查 - setproperty 與 setfield</title>
    <link href="https://yuehhua.github.io/2020/10/12/julia-setproperty-setfield/"/>
    <id>https://yuehhua.github.io/2020/10/12/julia-setproperty-setfield/</id>
    <published>2020-10-12T03:50:07.000Z</published>
    <updated>2020-10-12T03:52:42.354Z</updated>
    
    <content type="html"><![CDATA[<p>在 Julia 中存取物件的欄位的時候，設計者會想要對於存取的過程中加上一些檢查，這個想法是來自於傳統物件導向 getter/setter 的概念。</p><p>例如，在自己設計的物件當中有兩個矩陣，這兩個矩陣可以讓使用者隨意更新，但是需要保證這兩個矩陣的維度是一致的。這個時候就需要在使用者更新矩陣的時候加入檢查，以確保兩個矩陣之間的維度是一致的，如果檢查不通過，可能會跳例外或者是不讓矩陣被更新。</p><a id="more"></a><p>那如果要在 Julia 中，存取物件時加入檢查的程式碼，要怎麼辦呢？</p><p>Julia 提供了兩個 setter 來提供設定物件的欄位：<code>setproperty!</code> 跟 <code>setfield!</code></p><p><code>setfield!</code> 是屬於內部的 API，這個不能覆寫，所以我們要用的是 <code>setproperty!</code>。</p><p><code>setproperty!</code> 的 API 可以藉由查詢文件得知：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setproperty!(value, name::<span class="built_in">Symbol</span>, x)</span><br></pre></td></tr></table></figure><p>也就是當你在呼叫 <code>a.b = c</code> 其實就會去呼叫 <code>setproperty!(a, :b, c)</code>。</p><p>依據上述的例子，我們可以示範以下程式碼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mutable struct Foo</span><br><span class="line">    A::Matrix</span><br><span class="line">    B::Matrix</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function setproperty!(obj::Foo, name::Symbol, x)</span><br><span class="line">    if name &#x3D;&#x3D; :A</span><br><span class="line">        if size(obj.B) &#x3D;&#x3D; size(x)</span><br><span class="line">            setfield!(obj, name, x)</span><br><span class="line">        else</span><br><span class="line">            throw(DimensionMismatch())</span><br><span class="line">        end</span><br><span class="line">    elseif name &#x3D;&#x3D; :B</span><br><span class="line">        if size(obj.A) &#x3D;&#x3D; size(x)</span><br><span class="line">            setfield!(obj, name, x)</span><br><span class="line">        else</span><br><span class="line">            throw(DimensionMismatch())</span><br><span class="line">        end</span><br><span class="line">    else</span><br><span class="line">        setfield!(obj, name, x)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>這邊有幾點需要特別注意，第一是語言中的 <code>setproperty!</code> 第一個參數是 <code>Any</code> 型別，所以第一個參數一定要指定自己的型別是什麼，不然會跟語言本身的衝突。</p><p>第二個參數吃進來的是 <code>Symbol</code> 型別，這個也要指定，不然會發生 ambiguous 的狀況。</p><p>第三個參數為了廣義，所以是 <code>Any</code> 型別。</p><p>函式裡頭要區分開不同的欄位，這邊用 if-else 處理。想要用多重分派的機制處理的也是可以，但會比較麻煩，而且用到 <code>Val()</code> 會有效能降低的現象。</p><p>通過檢查後，要真正設定物件欄位，這邊用 <code>setfield!(obj, name, x)</code> 是比較好的作法。如果呼叫 <code>obj.A = x</code>，則會去呼叫 <code>setproperty!(obj, :A, x)</code>，就會變成無限遞迴呼叫了，所以 <code>=</code> 跟 <code>setproperty!</code> 在這邊都沒辦法用。</p><p>最後，我們把要檢查的欄位都處理好之後，我們不想要動到其他的欄位設定的行為，那就讓其他的欄位都用 <code>setfield!(obj, name, x)</code> 處理掉吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Julia 中存取物件的欄位的時候，設計者會想要對於存取的過程中加上一些檢查，這個想法是來自於傳統物件導向 getter/setter 的概念。&lt;/p&gt;
&lt;p&gt;例如，在自己設計的物件當中有兩個矩陣，這兩個矩陣可以讓使用者隨意更新，但是需要保證這兩個矩陣的維度是一致的。這個時候就需要在使用者更新矩陣的時候加入檢查，以確保兩個矩陣之間的維度是一致的，如果檢查不通過，可能會跳例外或者是不讓矩陣被更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Linear Regression with Maximum Likelihood Estimation</title>
    <link href="https://yuehhua.github.io/2020/10/12/linear-regression-with-mle/"/>
    <id>https://yuehhua.github.io/2020/10/12/linear-regression-with-mle/</id>
    <published>2020-10-11T17:20:57.000Z</published>
    <updated>2020-10-12T08:39:03.657Z</updated>
    
    <content type="html"><![CDATA[<p>Maximum likelihood estimation is an essential approach to estimate parameters in statistics. It requires statistical assumptions on error pattern. I will introduce this technique with really simple statistical model - linear regression.</p><a id="more"></a><p>We usually want to infer the relationship between input and output. They can be cause and effect of a physical phenomena or some indirect relationship in social science. We always want to realize the truth about our interest. Statistical tools are the tools to help you. The relationship between input and output are formulated as a mathematical function as follow:</p><p>$$<br>y = f(x)<br>$$</p><p>A linear model is assumed in linear regression. The relationship between $x$ and $y$ is assumed to be linear and $w$ and $b$ are introduced as unknown parameters into the model. $w$ denotes the extent of $x$ contributing to $y$ while $b$ denotes an inherent bias in $y$.</p><p>$$<br>y = wx + b<br>$$</p><p>On the other side, data are collected in pair of $(x^i, y^i)$. The superscript $n$ denotes the index for each sample.</p><p>$$<br>\mathcal{D} = {(x^1, y^1), (x^2, y^2), \cdots, (x^n, y^n)}<br>$$</p><p>The maximum likelihood estimation starts from the likelihood function. A likelihood function quantified the likelihood of data generation from the model we specified. That is, how likely the sample $(x_i, y_i)$ are generated from the model. All parameters are reduced into $\theta$. Precisely, $\mathcal{L}(\theta \mid \mathcal{D})$ represents the likelihood of model with parameter $\theta$ given data $\mathcal{D}$. Notably, data is fixed here. Thus, we want the most likely model that fits our samples. The model with maximum likelihood is estimated.</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= f(\mathcal{D} \mid \theta) \\<br>&amp;= p((x^1, y^1), (x^2, y^2), \cdots, (x^n, y^n) \mid \theta)<br>\end{aligned}<br>$$</p><p>A probability distribution is used to estimate the likelihood of model $\theta$. The interpretation here is the probability of data generation from the model $\theta$.</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= p((x^1, y^1), (x^2, y^2), \cdots, (x^n, y^n) \mid \theta) \\<br>&amp;= p((x^1, y^1) \mid \theta) \cdot p((x^2, y^2) \mid \theta) \cdots p((x^n, y^n) \mid \theta)<br>\end{aligned}<br>$$</p><p>It is formed from the joint probability distributions. A critical statistical assumption is introduced here. Samples $(x^i, y^i)$ are generated <em>independently</em> such that the joint probability can be split into multiplication of probabilities. Further, samples are generated from the same population/model $\theta$. So, we call that data are <em>independently, identically distributed</em>, or <em>iid</em>, generated from some model.</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= p((x^1, y^1) \mid \theta) \cdot p((x^2, y^2) \mid \theta) \cdots p((x^n, y^n) \mid \theta) \\<br>&amp;= \prod_{i=1}^n p((x^i, y^i) \mid \theta)<br>\end{aligned}<br>$$</p><p>Normal distribution is used as error pattern in linear regression model. A linear regression model always infers the mean value of $y$ given $x$. The uncertainty of $y$ can be described by normal distribution. We add an error term after the linear regression model.</p><p>$$<br>y = wx + b + \epsilon<br>$$</p><p>$$<br>\epsilon = y - wx - b = \mathcal{N}(z \mid \mu = 0, \sigma^2)<br>$$</p><p>Or we can rewrite it into</p><p>$$<br>\epsilon = \mathcal{N}(y - wx - b \mid \mu = 0, \sigma^2)<br>$$</p><p>where $\mathcal{N}(x \mid \mu, \sigma^2) = \frac{1}{\sigma \sqrt{2 \pi}} exp(-\frac{1}{2} (\frac{x-\mu}{\sigma})^2)$.</p><p>Likelihood function would be</p><p>$$<br>\begin{aligned}<br>\mathcal{L}(\theta \mid \mathcal{D}) &amp;= \prod_{i=1}^n p((x^i, y^i) \mid \theta) \\<br>&amp;= \prod_{i=1}^n \mathcal{N}(y^i - wx^i - b \mid \mu = 0, \sigma^2)<br>\end{aligned}<br>$$.</p><p>Negative log likelihood would be</p><p>$$<br>\begin{aligned}<br>\mathcal{l}(\theta \mid \mathcal{D}) &amp;= - ln \mathcal{L}(\theta \mid \mathcal{D}) \\<br>&amp;= - ln \prod_{i=1}^n \mathcal{N}(y^i - wx^i - b \mid \mu = 0, \sigma^2) \\<br>&amp;= - \sum_{i=1}^n ln \mathcal{N}(y^i - wx^i - b \mid \mu = 0, \sigma^2) \\<br>&amp;= - \sum_{i=1}^n - \frac{1}{2} (\frac{y^i - wx^i - b - 0}{\sigma})^2 - ln(\sigma \sqrt{2 \pi}) \\<br>&amp;= \sum_{i=1}^n \frac{1}{2} (\frac{y^i - wx^i - b}{\sigma})^2 + ln(\sigma) + ln(\sqrt{2 \pi})<br>\end{aligned}<br>$$</p><p>The primal goal is to maximize likelihood function $\arg\max_{\theta} \mathcal{L}(\theta \mid \mathcal{D})$, while we have to minimize the negative log likelihood (NLL) function</p><p>$$<br>\arg\min_{\theta} \mathcal{l}(\theta \mid \mathcal{D})<br>$$.</p><p>To solve this problem, we need to calculate the first-order derivative of NLL. The minimum value happens while $\frac{\partial \mathcal{l}}{\partial w} = 0$ and $\frac{\partial \mathcal{l}}{\partial b} = 0$ are satisfied.</p><p>$$<br>\begin{aligned}<br>\frac{\partial \mathcal{l}}{\partial w} &amp;= \frac{\partial}{\partial w} \sum_{i=1}^n \frac{1}{2} (\frac{y^i - wx^i - b}{\sigma})^2 + ln(\sigma) + ln(\sqrt{2 \pi}) \\<br>&amp;= \sum_{i=1}^n \frac{y^i - wx^i - b}{\sigma} \cdot \frac{\partial}{\partial w} \frac{y^i - wx^i - b}{\sigma} \\<br>&amp;= \sum_{i=1}^n \frac{y^i - wx^i - b}{\sigma} \frac{-x^i}{\sigma} \\<br>&amp;= \frac{-1}{\sigma^2} \sum_{i=1}^n x^i (y^i - wx^i - b) \\<br>&amp;= 0<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>\frac{-1}{\sigma^2} \sum_{i=1}^n x^i (y^i - wx^i - b) &amp;= 0 \\<br>\sum_{i=1}^n x^i (y^i - wx^i - b) &amp;= 0 \\<br>\sum_{i=1}^n{x^i y^i} - w \sum_{i=1}^n{(x^i)^2} - b \sum_{i=1}^n{x^i} &amp;= 0<br>\end{aligned}<br>$$</p><p>The same way we can have</p><p>$$<br>\sum_{i=1}^n{y^i} - w \sum_{i=1}^n{x^i} - b = 0<br>$$</p><p>derived from $\frac{\partial \mathcal{l}}{\partial b} = 0$.</p><p>Finally, we can estimate the parameters from the following two equations:</p><p>$$<br>\begin{cases}<br>(\sum_{i=1}^n{(x^i)^2}) w + (\sum_{i=1}^n{x^i}) b = \sum_{i=1}^n{x^i y^i} \\<br>(\sum_{i=1}^n{x^i}) w + b = \sum_{i=1}^n{y^i}<br>\end{cases}<br>$$</p><p>$$<br>\begin{cases}<br>w = ? \\<br>b = ?<br>\end{cases}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maximum likelihood estimation is an essential approach to estimate parameters in statistics. It requires statistical assumptions on error pattern. I will introduce this technique with really simple statistical model - linear regression.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>從分享到建議</title>
    <link href="https://yuehhua.github.io/2020/10/12/from-sharing-to-suggestions/"/>
    <id>https://yuehhua.github.io/2020/10/12/from-sharing-to-suggestions/</id>
    <published>2020-10-11T16:29:36.000Z</published>
    <updated>2020-10-11T16:34:30.496Z</updated>
    
    <content type="html"><![CDATA[<p>這幾年，隨著接觸的東西變多，知道的東西變多，個性上也有點變化。</p><p>約莫四五年前，碩班時期接觸到一些很棒的網路技術文章，當時線上課程也非常熱門，很多優秀的大學紛紛把他們的上課內容做成教材釋出。也因為這樣，我自己其實從這些網路資源受惠非常多。當時也是自己在發展自學能力的輝煌時期。</p><a id="more"></a><p>也因為接觸開源文化，所以對於「分享」很有憧憬。覺得能夠分享自己的經驗的人很厲害，除了自己有些東西可以告訴別人，也有這個意願跟熱忱可以將自己所學回饋給社會的感覺。</p><p>後來畢業之後在研發替代役的過程中，一邊練習自己的溝通跟演講技術，一邊弄社群跟開一些小型的短期課程，還成為工研院的機器學習講師。過程當中也很開心可以真正可以把自己身上的東西跟大家分享，有的學員是私下來問我的看法或是建議。</p><p>漸漸地，隨著接觸的東西跟知道的東西變多，會開始知道有些作法或是想法上是有瑕疵或是問題的。一部份也是受到研替時的老闆的影響，老闆是個急性子，也不斷感受到壓力，久了之後心中也對有問題的方法莫名升起一種煩躁感。</p><p>煩躁感的出現，加上有能力表達，也有足夠的知識，變得開始會對身邊的人給建議。</p><p>有可能是談話中朋友表達他的某個想法，我會脫口而出這樣的想法背後可能會有什麼潛在的問題，抑或是我覺得這樣的想法好不好。話題範圍從我的專業領域到日常的電視廣告，只要是我有求證過或是我知道的，很多都會直接給出分析的結果。</p><p>目前正在博士的訓練路途上，博士的訓練是希望有獨立的分析跟研究能力，所以這樣能夠有批判性思考是很重要的能力。</p><p>這樣的分析似乎會困擾我身邊的人，畢竟不是每個人都需要「被建議」，他們或許覺得自己的作法很好，不然就是他就是想要這樣做。雖然我不太介意他是否會採納我的建議，但就是會講出口。有些時候講出口的剎那，對方會有種被否定或是攻擊的感覺，無論我的語氣是用「我覺得」或是「我建議」這種比較不強烈的。</p><p>大多數時候我是覺得我在發表自己的意見，對方也可以有自己的意見，我覺得這樣很公平。不過這些意見有時候是衝突，甚至相反的，有些人就會覺得被否定。的確，被否定的感覺很難受，意見被否定乃至於延伸到人格被否定，有些人是會失去自信的。</p><p>很多文章跟書本都告訴人不要主動給建議，建議只有當別人問的時候才給。或許該學著睜一隻眼閉一隻眼，即便是身邊再親的人也不要輕易給建議。</p><p>事情搞砸就是他的事，與我無關。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這幾年，隨著接觸的東西變多，知道的東西變多，個性上也有點變化。&lt;/p&gt;
&lt;p&gt;約莫四五年前，碩班時期接觸到一些很棒的網路技術文章，當時線上課程也非常熱門，很多優秀的大學紛紛把他們的上課內容做成教材釋出。也因為這樣，我自己其實從這些網路資源受惠非常多。當時也是自己在發展自學能力的輝煌時期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 怎麼用 async 跟 sync</title>
    <link href="https://yuehhua.github.io/2020/09/06/how-to-use-async-sync-in-julia/"/>
    <id>https://yuehhua.github.io/2020/09/06/how-to-use-async-sync-in-julia/</id>
    <published>2020-09-06T09:43:04.000Z</published>
    <updated>2020-10-11T16:36:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>這個問題在官方文件中並沒有詳細記載，所以覺得值得紀錄一下。</p><p>查閱 <code>@async</code> 的文件會講說，他會用一個 <code>Task</code> 把後面的表達式包裝起來，並且將他掛到排程器的佇列（queue）中。意思就是將表達式包裝成一個任務，並放到佇列中等待 CPU 核心的資源來執行他。</p><a id="more"></a><p>然而通常會搭配 <code>@sync</code> 來使用，<code>@sync</code> 的文件中提到，他會等到後面的 <code>@async</code>、<code>@spawn</code>、<code>@spawnat</code> 及 <code>@distributed</code> 都執行完畢。</p><p>使用情境比較像是（修改自<a href="https://stackoverflow.com/questions/37287020/how-and-when-to-use-async-and-sync-in-julia" target="_blank" rel="noopener">這篇 stackoverflow</a>）</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sync</span> <span class="keyword">for</span> (idx, pid) <span class="keyword">in</span> enumerate(workers())</span><br><span class="line">    <span class="meta">@async</span> a[idx] = remotecall_fetch(do_something, pid, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>@sync</code> 會等待這個 block 中的 <code>@async</code> 都執行結束才結束，<code>@async</code> 可以讓你指派一些非同步處理的任務，像是多執行緒或是多行程的平行運算。</p><p><code>@sync</code> 就比較像 python 當中的 <code>join()</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這個問題在官方文件中並沒有詳細記載，所以覺得值得紀錄一下。&lt;/p&gt;
&lt;p&gt;查閱 &lt;code&gt;@async&lt;/code&gt; 的文件會講說，他會用一個 &lt;code&gt;Task&lt;/code&gt; 把後面的表達式包裝起來，並且將他掛到排程器的佇列（queue）中。意思就是將表達式包裝成一個任務，並放到佇列中等待 CPU 核心的資源來執行他。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系統降噪</title>
    <link href="https://yuehhua.github.io/2020/09/06/linux-system-noise-cancellation/"/>
    <id>https://yuehhua.github.io/2020/09/06/linux-system-noise-cancellation/</id>
    <published>2020-09-06T09:22:33.000Z</published>
    <updated>2020-09-06T09:23:17.999Z</updated>
    
    <content type="html"><![CDATA[<p>之前在 Linux 上測試麥克風，發現錄製的時候總會把背景雜訊給錄進去，會在有人講話的同時聽到雜音。</p><p>我用的是 OBS 來做桌面錄製，所以自然想用 OBS 來做音訊的降噪。在 OBS 裡有噪音閥及噪音抑制，似乎噪音閥的效果比較明顯，但是講話聲音背後仍有雜音。</p><p>這時候在網路上找了一下，發現可以用系統 pulseaudio 的驅動來做降噪，只是要特別設定開啟，預設是不會開啟的。試了之後效果超好，在這邊紀錄一下。</p><h2 id="步驟">步驟</h2><p>首先，編輯以下檔案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;pulse&#x2F;default.pa</span><br></pre></td></tr></table></figure><p>把以下這行加到檔案中，建議可以加到有個 Echo Cancellation 的地方：</p><p>load-module module-echo-cancel</p><p>重載 PulseAudio (pulseaudio -k) 就可以囉！</p><p>Ref: <a href="https://askubuntu.com/questions/18958/realtime-noise-removal-with-pulseaudio" target="_blank" rel="noopener">https://askubuntu.com/questions/18958/realtime-noise-removal-with-pulseaudio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在 Linux 上測試麥克風，發現錄製的時候總會把背景雜訊給錄進去，會在有人講話的同時聽到雜音。&lt;/p&gt;
&lt;p&gt;我用的是 OBS 來做桌面錄製，所以自然想用 OBS 來做音訊的降噪。在 OBS 裡有噪音閥及噪音抑制，似乎噪音閥的效果比較明顯，但是講話聲音背後仍有雜音。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Julia 中的表達問題（Expression problem in Julia）</title>
    <link href="https://yuehhua.github.io/2020/09/06/expression-problem-in-julia/"/>
    <id>https://yuehhua.github.io/2020/09/06/expression-problem-in-julia/</id>
    <published>2020-09-06T09:19:52.000Z</published>
    <updated>2020-10-11T16:36:31.074Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是啟發自 <a href="https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions" target="_blank" rel="noopener">The Expression Problem and its solutions</a>，當中談論的是在撰寫程式的過程中，所採用的程式典範不同，會在程式表達上遇到不同程度的困難，稱之為表達問題（expression problem）。</p><a id="more"></a><h2 id="物件導向語言中的表達問題">物件導向語言中的表達問題</h2><p>以原文中的例子，作者想以物件導向語言來撰寫一個簡單的 expression evaluator。基本上採用直譯器模式（<a href="https://en.wikipedia.org/wiki/Interpreter_pattern" target="_blank" rel="noopener">interpreter pattern</a>），這邊我把程式碼以 python 重寫。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostring</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constant</span><span class="params">(Expr)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__value = value</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostring</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.__value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryPlus</span><span class="params">(Expr)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lhs, rhs)</span>:</span></span><br><span class="line">        self.__lhs = lhs</span><br><span class="line">        self.__rhs = rhs</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tostring</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__lhs.tostring() + <span class="string">" + "</span> + self.__rhs.tostring()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__lhs.eval() + self.__rhs.eval()</span><br></pre></td></tr></table></figure><p>我們先定義了一個 <code>Expr</code>，我們希望提供 <code>tostring</code> 及 <code>eval</code> 兩種操作。我們後續定義了常數 <code>Constant</code>，也讓常數實作這兩種操作。</p><p>如果我們想要擴充 <code>Expr</code> 或是 <code>Constant</code> 的時候該怎麼做呢？更精確地說，如果我們想要新增新的操作到既有的類別上，我們該怎麼做？一般情況下可能就是直接在原有的類別上加上新的方法。不過這樣其實違反了軟體工程原則，開放封閉原則（open-closed principle），我們應該要對舊有的類別、方法、介面等等程式碼修改保持<em>封閉</em>，也就是不能去修改既有程式碼，我們應該對新增程式碼保持<em>開放</em>，也就是允許新增程式碼。</p><p>我們可以發現在物件導向語言當中，新增類別是容易的，但是新增方法是困難的。這是在物件導向語言中所遇到的表達問題。</p><h2 id="函數式語言中的表達問題">函數式語言中的表達問題</h2><p>以 Haskell 為例，撰寫以上的程式（這邊直接引用原文）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data Expr &#x3D; Constant Double</span><br><span class="line">          | BinaryPlus Expr Expr</span><br><span class="line"></span><br><span class="line">stringify :: Expr -&gt; String</span><br><span class="line">stringify(Constant c) &#x3D; show c</span><br><span class="line">stringify(BinaryPlus lhs rhs) &#x3D; stringify lhs</span><br><span class="line">                                ++ &quot; + &quot;</span><br><span class="line">                                ++ stringify rhs</span><br><span class="line"></span><br><span class="line">evaluate :: Expr -&gt; Double</span><br><span class="line">evaluate(Constant c) &#x3D; c</span><br><span class="line">evaluate(BinaryPlus lhs rhs) &#x3D; evaluate lhs + evaluate rhs</span><br></pre></td></tr></table></figure><p>在 Haskell 中，要新增方法是容易的，但是如果要新增型別的話，就得動到 <code>data</code> 的定義。在函數式語言中，新增型別是困難的。這是在函數式語言中所遇到的表達問題。</p><h2 id="Julia-語言中的表達問題？">Julia 語言中的表達問題？</h2><p>文章中有提到 Clojure 採用的是 multi-methods，他可以對應到 Julia 的多重分派（multiple dispatch）。多重分派可以好好地處理表達問題，讓新增型別及方法都是簡單的。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract type</span> <span class="built_in">Expr</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tostring(::<span class="built_in">Expr</span>) = <span class="number">0</span></span><br><span class="line">eval(::<span class="built_in">Expr</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Constant&#123;T&#125;</span><br><span class="line">    value::T</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tostring(::Constant) = <span class="built_in">String</span>(c.value)</span><br><span class="line">eval(c::Constant) = c.value</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BinaryPlus</span><br><span class="line">    lhs::<span class="built_in">Expr</span></span><br><span class="line">    rhs::<span class="built_in">Expr</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tostring(b::BinaryPlus) = tostring(b.lhs) * <span class="string">" + "</span> * tostring(b.rhs)</span><br><span class="line">eval(b::BinaryPlus) = eval(b.lhs) + eval(b.rhs)</span><br></pre></td></tr></table></figure><p>不過他文末也有提到一個關鍵是 open method，也就是將方法定義在類別之外，如此一來，新增方法就會是簡單的。所以真正解決表達問題的並不是多重分派的機制，而是 open method 的設計。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是啟發自 &lt;a href=&quot;https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Expression Problem and its solutions&lt;/a&gt;，當中談論的是在撰寫程式的過程中，所採用的程式典範不同，會在程式表達上遇到不同程度的困難，稱之為表達問題（expression problem）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在 Julia 中如何合併集合容器</title>
    <link href="https://yuehhua.github.io/2020/08/28/merge-collections-in-julia/"/>
    <id>https://yuehhua.github.io/2020/08/28/merge-collections-in-julia/</id>
    <published>2020-08-28T14:37:43.000Z</published>
    <updated>2020-08-28T14:37:43.527Z</updated>
    
    <content type="html"><![CDATA[<p>我們都知道要將兩個 <code>Array</code> 接起來要用 <code>append!</code>，要將兩個 <code>Set</code> 合併起來要用 <code>union!</code>，但要將 <code>Dict</code> 合併起來要用什麼呢？</p><p>答案是 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.merge" target="_blank" rel="noopener">merge</a>！</p><h2 id="merge">merge</h2><p>廢話不多說，我們看範例：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = <span class="built_in">Dict</span>(:a =&gt; <span class="string">"A"</span>, :b =&gt; <span class="string">"B"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">julia&gt; b = <span class="built_in">Dict</span>(:c =&gt; <span class="string">"C"</span>, :d =&gt; <span class="string">"D"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line">  :c =&gt; <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">julia&gt; merge(a, b)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">4</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"B"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line">  :c =&gt; <span class="string">"C"</span></span><br></pre></td></tr></table></figure><p><code>merge</code> 可以將兩個 <code>Dict</code> 合併起來，並且產生一個新的 <code>Dict</code>。</p><p>有另一個函式 <code>merge!</code> 可以支援 in-place 版本的合併。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">julia&gt; merge!(a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line">julia&gt; a</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br></pre></td></tr></table></figure><h3 id="重複的鍵（key）">重複的鍵（key）</h3><p>如果要合併的兩個字典當中有重複的鍵出現的話，會發生什麼事呢？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; c = <span class="built_in">Dict</span>(:b =&gt; <span class="string">"C"</span>, :d =&gt; <span class="string">"D"</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line">julia&gt; merge(a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">String</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="string">"A"</span></span><br><span class="line">  :b =&gt; <span class="string">"C"</span></span><br><span class="line">  :d =&gt; <span class="string">"D"</span></span><br></pre></td></tr></table></figure><p>答案是會被後者蓋掉。</p><h3 id="NamedTuple">NamedTuple</h3><p><code>merge</code> 也可以用在 NamedTuple 上。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = (a=<span class="string">"A"</span>, b=<span class="string">"B"</span>)</span><br><span class="line">(a = <span class="string">"A"</span>, b = <span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; b = (c=<span class="string">"C"</span>, d=<span class="string">"D"</span>)</span><br><span class="line">(c = <span class="string">"C"</span>, d = <span class="string">"D"</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; merge(a, b)</span><br><span class="line">(a = <span class="string">"A"</span>, b = <span class="string">"B"</span>, c = <span class="string">"C"</span>, d = <span class="string">"D"</span>)</span><br></pre></td></tr></table></figure><h2 id="mergewith-require-v1-5-and-above">mergewith (require v1.5 and above)</h2><p>接下來介紹一個更好用的函式 <a href="https://docs.julialang.org/en/v1/base/collections/#Base.mergewith" target="_blank" rel="noopener">mergewith</a>。</p><p>上面我們介紹的 <code>merge</code> 遇到相同的鍵，會把彼此蓋掉的行為，但有時候我們希望他們可以合併。</p><p>不囉唆，我們看範例：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; a = <span class="built_in">Dict</span>(:a =&gt; <span class="number">1</span>, :b =&gt; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :a =&gt; <span class="number">1</span></span><br><span class="line">  :b =&gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">julia&gt; c = <span class="built_in">Dict</span>(:b =&gt; <span class="number">3</span>, :d =&gt; <span class="number">4</span>)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">2</span> entries:</span><br><span class="line">  :b =&gt; <span class="number">3</span></span><br><span class="line">  :d =&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line">julia&gt; mergewith(+, a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="number">1</span></span><br><span class="line">  :b =&gt; <span class="number">5</span></span><br><span class="line">  :d =&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>我們可以指定一個 aggregate function，如果遇到相同的鍵時，就把他們的值相加起來。</p><p>這個 aggregate function 可以是其他的，如此就可以處理多樣的資料。</p><p><code>mergewith</code> 一樣有 in-place 版本 <code>mergewith!</code>。</p><h3 id="curry-function">curry function</h3><p>最神奇的是，<code>mergewith</code> 有類似 curry function 的行為。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; mergewith(+)(a, c)</span><br><span class="line"><span class="built_in">Dict</span>&#123;<span class="built_in">Symbol</span>,<span class="built_in">Int64</span>&#125; with <span class="number">3</span> entries:</span><br><span class="line">  :a =&gt; <span class="number">1</span></span><br><span class="line">  :b =&gt; <span class="number">5</span></span><br><span class="line">  :d =&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line">julia&gt; mergewith(+)</span><br><span class="line"><span class="comment">#140 (generic function with 1 method)</span></span><br></pre></td></tr></table></figure><p>你可以先給他一個 aggregate function，他會回傳一個匿名函式。</p><p>你可以拿這個匿名函式用在其他物件上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我們都知道要將兩個 &lt;code&gt;Array&lt;/code&gt; 接起來要用 &lt;code&gt;append!&lt;/code&gt;，要將兩個 &lt;code&gt;Set&lt;/code&gt; 合併起來要用 &lt;code&gt;union!&lt;/code&gt;，但要將 &lt;code&gt;Dict&lt;/code&gt; 合併起來要用什麼呢？
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia v1.5 釋出</title>
    <link href="https://yuehhua.github.io/2020/08/07/julia-v1-5-release/"/>
    <id>https://yuehhua.github.io/2020/08/07/julia-v1-5-release/</id>
    <published>2020-08-07T03:06:29.000Z</published>
    <updated>2020-08-07T03:14:34.552Z</updated>
    
    <content type="html"><![CDATA[<p>在新的 1.5 版是主要對記憶體的配置方式有改進，有最佳化記憶體布局（memory layout）。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><p>不可變型別（包含 tuples）現在可以被放到堆疊（stack）上，而且可以在陣列跟其他型別中被配置成 inline。(#33886)<br>有興趣的朋友可以查詢 inline allocation 相關關鍵字。如此一來就大幅降低了在堆積（heap）上配置的記憶體數量。<br>相對，任何需要是穩定定址（stable address）的物件就要必須是 <code>mutable struct</code>。(#34126)</p><h3 id="使用者功能">使用者功能</h3><ul><li>在互動式 REPL 環境提供了「軟性作用域」（soft scope）。像是在 <code>for</code> loop 的作用域中要指定值給全域變數，是可行的。如同在 IJulia 所提供的 Jupyter 環境一樣，但這只影響 REPL 環境，不影響腳本執行環境。(#28789, #33864)</li><li>如果在 REPL 外，例如腳本，執行以上行為會被視為模糊的（ambiguous），並且會發出 warning。</li><li>另外，有一個新的命令列選項是 <code>--warn-scope</code> 可以控制這個 warning。(#33864)</li><li>在三個雙引號所形成的字串中，空白移除（whitespace stripping）會優於跳脫字元執行。如此一來，以下例子會有不同的結果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">  a\n b&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>會產生 <code>&quot;a\n b&quot;</code> 的字串，而不是 <code>&quot; a\nb&quot;</code>，兩者差別在 <code>a</code> 之前有沒有空白。老舊的行為會被視為一種 bug。(#35001)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>現在可以在每個模組（module）中使用編譯器最佳化等級（compiler optimization level），是使用 <code>Base.Experimental.@optlevel n</code> 來設定。對於並不是那麼效能需求（performance-critical），可以設定成 0 或 1，可以提供相當的延遲改善（latency improvements）。(#34896)</li><li><code>@inline</code> 可以被用在短型的匿名函數。(#34953)</li><li>棄用警告（deprecation warnings）不再是預設顯示的，可以使用 <code>--depwarn=no</code> 來開啟。警告在執行測試 <code>Pkg.test()</code> 時是會顯示的。(#35362)</li><li>部份的多執行緒（multi-threading）API 被視為穩定。這包含了所有 <code>Base.Threads</code> 中被紀錄的 API，但除了 <code>atomic_</code> 操作。</li><li><code>@threads</code> 現在容許可選的排程參數（schedule argument）。用法像是 <code>@threads :static ...</code>。</li><li><code>@ccall</code> 現在被加入到 Base 中。這跟 <code>ccall</code> 很像，但多了類 Julia 語法。他也包裝了新的 <code>foreigncall</code> API，支援 varargs 中不同的型別，不過他缺乏呼叫指定 LLVM calling convention 的能力。(#32748)</li><li><code>@view</code> 及 <code>@views</code> 現在支援 <code>a[begin]</code> 語法。(#35289)</li></ul><h2 id="新功能">新功能</h2><ul><li><code>⨟</code> 現在是一個二元運算子，他是一個 composition operator，語意為 <code>f ⨟ g = g ∘ f</code>。在 REPL，可以使用 <code>\bbsemi</code> 加上 <kbd>TAB</kbd> 打出來。(#34722)</li><li>傳遞一個辨識子（identifier）<code>x</code> 作為關鍵字參數或是 named tuple，會等同於 <code>x=x</code>，會隱含地使用變數名稱本身作為關鍵字參數的名稱或 named tuple 的名稱。同樣地，傳遞 <code>a.b</code> 會使用 <code>b</code> 作為名稱。(#29333)</li><li>新增 <code>mergewith</code> 及 <code>mergewith!</code> 取代 <code>merge</code>、<code>merge!</code> 及參數 <code>combine</code> 的組合。(#34296)</li><li>新增 <code>isdisjoint</code> 來指示兩個集合容器是否為互斥。(#34427)</li><li>新增 <code>ismutable</code> 來取代 <code>isimmutable</code>，用來檢查某些東西是否為可變的。(#34652)</li><li>新增 <code>contains(haystack, needle)</code> 行為如同 <code>occursin(needle, haystack)</code>。(#35132)</li></ul><h2 id="新支援">新支援</h2><ul><li>使用 <code>open</code> 開檔時，多了 <code>lock</code> 關鍵字參數來控制檔案操作是否在多執行緒存取的狀況下需要鎖。當只有一個執行緒存取時，設定成 <code>false</code> 會有較好的性能。(#35426)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在新的 1.5 版是主要對記憶體的配置方式有改進，有最佳化記憶體布局（memory layout）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>真理</title>
    <link href="https://yuehhua.github.io/2020/05/23/the-truth/"/>
    <id>https://yuehhua.github.io/2020/05/23/the-truth/</id>
    <published>2020-05-23T04:55:01.000Z</published>
    <updated>2020-05-23T05:18:56.180Z</updated>
    
    <content type="html"><![CDATA[<p>今天意外看到一段話，出處應該是《不用數字的研究 ：質性研究的思辯脈絡》一書。</p><blockquote><p><strong>&quot;To achieve enlightenment, our political systems must relinquish their claims on truth, justice and freedom and have to replace them with the search for truth, justice, freedom and reason.&quot;</strong><br>– Immanuel Kant</p></blockquote><a id="more"></a><p><a href="https://commons.wikimedia.org/wiki/File:Kant_gemaelde_3.jpg#/media/File:Kant_gemaelde_3.jpg" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f2/Kant_gemaelde_3.jpg" alt="Kant gemaelde 3.jpg"></a><br>由 Johann Gottlieb Becker (1720-1782) - <a rel="nofollow noopener" class="external free" href="http://www.philosovieth.de/kant-bilder/bilddaten.html" target="_blank">http://www.philosovieth.de/kant-bilder/bilddaten.html</a>, 公有領域, <a href="https://commons.wikimedia.org/w/index.php?curid=32860677" target="_blank" rel="noopener">連結</a></p><p>康德是個歷史上重要的哲學家，他指出了面對真理的態度。</p><p>要得到開悟，我們的體系需要放棄他們對於真理、正義以及自由的定義。取而代之的是，對於真理、正義以及自由的追求與探索。</p><p>開悟的過程並不是去讀懂一些名人、大師的名言，也不是去崇尚大家所共識的真理。</p><p>真理、正義以及自由並不是由人定義出來的，而是經由追求與探索得到的。</p><p>這讓我想到科學不也是一個這樣的過程嗎？</p><p>科學並不是由教科書上所定義及構築出來的美好世界，科學本身是一種過程，科學是一種追求與探索真理的過程。</p><p>也就是說，一旦停滯了，不往前走，就不是科學了。在原地享用科學的成果也不是科學本身，科學必須前進，必須去拓展未知的領域。</p><h2 id="有限">有限</h2><p>然而大家目前看到的量子、人工智慧種種科技，並非科學本身，而是科學的產物。是有一群人秉持著這樣的想法不斷往前探索所得到的<strong>暫時的</strong>結論。</p><p>是的，所以在世的東西都是暫時的。知識會老去，會有新的知識產出。我們會證明舊的知識不再適用，有一套新的知識取而代之。</p><p>沒有什麼東西是永恆的。永恆只存在在當時間走到盡頭（$t \rightarrow \infty$），然而時間沒有盡頭。</p><p>當事物到了無限大的時候，永恆才存在，真理才存在，理論才存在。但在那之前都是暫時的，所有事物都有生死，是<strong>有限的</strong>。</p><p>人是有限的，但人常嚮往無限。</p><p>既然有限，當然也不會知道真理、正義以及自由的終極定義是什麼。</p><h2 id="往前">往前</h2><p>唯一能做的就是不斷地往前走，不斷地探索，不斷地尋找真理、正義以及自由。</p><p>企業不斷尋找市場，想知道最終市場會在哪裡，可惜的是它永遠是變動的，只能不斷追尋。</p><p>研究人員在尋找真理，尋找真理需要方法，可惜的是無法達到彼岸，只是不停地往前。</p><p>以科學的方式不斷地往前走及探索，才是科學本身。</p><h2 id="博士">博士</h2><p>念博士是個開悟的過程，從一個靜態的世界觀，走向一個動態的世界觀。</p><p>從一個有標準答案的世界，走向一個沒有標準答案的世界，甚至每個都有可能是答案。</p><p>從一個遵循定義，到可以隨處都是定義，或是所有定義都不存在。</p><h2 id="暫時的答案">暫時的答案</h2><p>很多研究結果是得到一個暫時的答案。</p><p>很多研究結果很快就被證明是錯的，或是可以做出同樣結論的人不多。</p><p>太快擁抱結果，或是擁抱單一的答案都是一種 overfitting，它失去對未來的適應性即可預測性。</p><p>但是如果不擁抱結果，你會一無所穫，事物都無法推進，裹足不前。</p><h2 id="方法">方法</h2><p>方法，就像搭橋，它連結了現在與未來，連結了有限與無限。</p><p>找到對的方法會讓你有比較穩固的方式連結現況與未來，錯誤的方法相對脆弱。</p><p>追求真理的過程其實大多都在尋找方法。</p><p>很多時候不是「XXX是錯誤的」，而是所用的方法不對而已，換個方法就是了。</p><h2 id="勇敢">勇敢</h2><p>既然達不到真理，那我們為什麼還要追求？</p><p>當然你也可以用現有的知識跟技術，就這樣生活下去。</p><p>很多的問題沒有好好地解決，環境問題、人權問題等等，我們仍舊可以依然固我地無視這些問題，繼續活在痛苦之中。</p><blockquote><p>「世界上只有一種真正的英雄主義，那就是在認清生活真相之後，依然熱愛生活。」——羅曼羅蘭</p></blockquote><p>我們認清什麼是真理，即便達不到真理，仍舊熱愛追求真理，稱之為英雄。</p><p>成為英雄，需要勇氣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天意外看到一段話，出處應該是《不用數字的研究 ：質性研究的思辯脈絡》一書。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;To achieve enlightenment, our political systems must relinquish their claims on truth, justice and freedom and have to replace them with the search for truth, justice, freedom and reason.&amp;quot;&lt;/strong&gt;&lt;br&gt;
– Immanuel Kant&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>可組合性（Composable）：Julia 語言的重要特性</title>
    <link href="https://yuehhua.github.io/2020/04/11/composable-the-key-feature-in-julia/"/>
    <id>https://yuehhua.github.io/2020/04/11/composable-the-key-feature-in-julia/</id>
    <published>2020-04-11T05:43:24.000Z</published>
    <updated>2020-04-11T14:42:46.670Z</updated>
    
    <content type="html"><![CDATA[<p>其實是受到 Julia 核心開發者之一 Lyndon White 的<a href="https://white.ucc.asn.au/2020/02/09/whycompositionaljulia.html" target="_blank" rel="noopener">文章</a>的啟發來撰寫本文的。</p><p>文章有 <a href="https://mp.weixin.qq.com/s/4_Sbi8q5EZDjHj6ouM1Ydg" target="_blank" rel="noopener">CSDNnews 簡中翻譯</a>。</p><p>本文並非以上文章的繁中版本，而是本人的一些心得及觀察。</p><h2 id="載入套件">載入套件</h2><p>比較深入了解 Julia 的朋友，會了解到這個語言的設計與其他語言的不同，像是 <code>using</code>。</p><p>當我們使用 <code>using</code> 來載入套件的時候，會發現有不少存在在 <code>Base</code> 中的函式是可以使用的。像是 <code>length</code> 可以用來取得陣列的長度，當你載入 DataStructures.jl 時，你同樣可以用 <code>length</code> 來取得 <code>Stack</code> 及 <code>Queue</code> 的長度。</p><p>或者是原文中的例子。使用者可以使用 <a href="https://github.com/invenia/NamedDims.jl" target="_blank" rel="noopener">NamedDims.jl</a> 來為你的陣列的維度命名，而你的陣列需要使用 <a href="https://github.com/JuliaGPU/CuArrays.jl" target="_blank" rel="noopener">CuArrays.jl</a> 送到 CUDA，這時候你不需要一個可以為 CUDA array 命名的套件來達成這件事。</p><p>你會發現在 Julia 語言中似乎不存在套件跟套件之間的差別，或是套件跟標準函式庫之間的區別。這是由於在 Julia 中對於命名空間（namespace）的概念較為薄弱，Julia 各模組之間仍然存在著命名空間，但是 Julia 在 <code>using</code> 時會將這些命名空間去除。這在工程上或許不是一個好的典範，因為會造成命名空間的汙染（namespace pollution）。反過來說，它促使人們相互溝通及協調，來提供更好的套件之間的可組合性。</p><p>在其他語言中，常常會告訴你，使用某個套件只需要載入你需要的部份，像是 <code>using Foo: bar, baz</code>，然而 Julia 並不去特別強調這點，<code>using Foo</code> 會載入套件開發者有導出的部份。如果有兩個套件都提供了 <code>predict</code> 來支援他們的模型，這邊借原文的例子再次說明：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Foo</span><br><span class="line"><span class="keyword">using</span> Bar</span><br><span class="line">training_data, test_data = ...</span><br><span class="line">mbar = BarModel(training_data)</span><br><span class="line">mfoo = FooModel(training_data)</span><br><span class="line">evaluate(predict(mbar), test_data)</span><br><span class="line">evaluate(predict(mfoo), test_data)</span><br></pre></td></tr></table></figure><p>這兩個 <code>predict</code> 分別來自雙方套件的各自定義及實作。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bar.predict(mbar)</span><br><span class="line">Foo.predict(mfoo)</span><br></pre></td></tr></table></figure><p>如此使用者便可以無縫地使用同樣一個介面 <code>predict</code>，而功能來自兩個不同的套件。</p><p>這樣的特性大概會有人聯想到介面（interface）。然而，Julia 並不明顯使用介面來規範開發者，Julia 隱含地使用鴨子定型（duck typing）。</p><p>在載入套件之後，Julia 允許使用者不冠上套件名稱來使用這些函式，像 <code>Bar.predict</code>，你可以自由地使用 <code>predict</code> 即可。總是會有套件之間的命名衝突，當衝突發生的時候，就是開發者需要負起責任彼此溝通及協調的時候。不過使用者仍然可以以 <code>Bar.predict</code> 的方式使用套件，只是每次載入套件的時候都會有警告。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> Plots</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">using</span> Gadfly</span><br><span class="line"></span><br><span class="line">julia&gt; plot</span><br><span class="line">WARNING: both Gadfly and Plots <span class="keyword">export</span> <span class="string">"plot"</span>; uses of it <span class="keyword">in</span> <span class="keyword">module</span> Main must be qualified</span><br><span class="line">ERROR: <span class="built_in">UndefVarError</span>: plot not defined</span><br></pre></td></tr></table></figure><h2 id="鴨子定型及多重分派">鴨子定型及多重分派</h2><p>在原文中提到鴨子定型及多重分派是成就 Julia 成為一個可組合（composable）語言的基石。我個人也認為可組合是 Julia 提供最重要的特性之一，但卻鮮少被人提及。多數人仍然熱衷於語言效能及開發便利性。</p><p>鴨子定型的一個很好的比喻是，當一個東西會呱呱叫的時候，那麼他就是鴨子。當一個 <code>bar(x)</code> 可以呼叫時，我不需要去檢查 <code>x</code> 的型別為何，我就直接使用就是了。這樣會構成一種隱性的介面。</p><p>當我需要提供一個矩陣相乘的功能時，我會寫以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> multiply(A, B)</span><br><span class="line">    C = zeros(size(A, <span class="number">1</span>), size(B, <span class="number">2</span>))</span><br><span class="line">    A = A'</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>:size(C, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>:size(C, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">for</span> k = <span class="number">1</span>:size(A, <span class="number">2</span>)</span><br><span class="line">                C[i, j] = sum(A[:, k] .* B[:, k])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這可以用在一般的矩陣，但如果今天我有自定義的一個新的矩陣呢？</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> NewArray</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上述的 <code>multiply</code> 中我只需要檢查 <code>NewArray</code> 是否提供相關的介面即可。像是裡頭用到了 <code>size</code>、<code>A[:, k]</code> 及 <code>sum</code>。我只需要支援這些介面的實作即可，如此，Julia 就可以以鴨子定型的方式，讓 <code>multiply</code> 接受 <code>NewArray</code> 了。</p><p>對於不同的型別需要有不同的行為，這在一般的物件導向語言中稱之為多型。多型在多數物件導向典範中使用的是單一分派（single dispatch），然而 Julia 也支援多型，但是以多重分派（multiple dispatch）的方式支援。因此，廣義而言，Julia 支援物件導向的方式是多重分派，卻不是典型的、語法上的封裝、繼承及（單一分派）多型。</p><p>多重分派，可以在需要更細緻行為定義時幫上忙。當 <code>NewArray</code> 支援 <code>sum</code>：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray) = ...</span><br></pre></td></tr></table></figure><p>這是單一分派的方式，也可以有多重分派的方式。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray, ::<span class="built_in">Array</span>) = ...</span><br></pre></td></tr></table></figure><p>不過這樣只支援 <code>Array</code> 這個特定型別。或是我們可以乾脆這樣做。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(::NewArray, ::<span class="built_in">AbstractArray</span>) = ...</span><br></pre></td></tr></table></figure><p>這樣只要是 <code>AbstractArray</code> 的子型別都可以接受。</p><h2 id="總結">總結</h2><p>以上種種的特性成為了可組合性的基石。一個具有可組合性的語言能夠成為各種東西。Julia 的個別的套件都不俱備所有的定義，需要依賴 Julia 語言及標準函式庫的介面及實作。</p><p>例如當 Julia 中載入了深度學習框架，那它，連同語言本身，就是一個完整支援深度學習功能的引擎。當同時載入了資料庫與深度學習相關套件，那它就成為了支援深度學習功能的 DBMS。當載入了科學計算及機器學習套件，那它就會變成一個強大的數值計算引擎。以 Julia 的可組合性出發，來打造各式各樣不同的引擎，就像一個單純的編輯器搭配有豐富的外掛（plug-in）一樣。這樣衍生出的生態帶來了各式各樣不同的可能性，也讓套件的 reusability 提升到最高的境界。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其實是受到 Julia 核心開發者之一 Lyndon White 的&lt;a href=&quot;https://white.ucc.asn.au/2020/02/09/whycompositionaljulia.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>讓 Julia 像 Python 一樣擁有物件 property</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-property/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-property/</id>
    <published>2020-04-10T02:56:41.000Z</published>
    <updated>2020-04-10T02:56:41.889Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 的物件都有屬性，但這需要寫在型別中事先定義。但如果要為沒有任何屬性的型別增加屬性要怎麼做？</p><p>Julia 的屬性存取是來自 <code>Base.getproperty</code> 及 <code>Base.setproperty!</code> 兩個方法。</p><a id="more"></a><p>如果我們這樣定義。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">struct</span> Foo <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">julia&gt; Base.getproperty(::Foo, x::<span class="built_in">Symbol</span>) = <span class="string">"<span class="variable">$x</span>"</span></span><br></pre></td></tr></table></figure><p>來測試不同的 property。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; foo = Foo()</span><br><span class="line">Foo()</span><br><span class="line"></span><br><span class="line">julia&gt; foo.a</span><br><span class="line"><span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.x</span><br><span class="line"><span class="string">"x"</span></span><br></pre></td></tr></table></figure><p>以及設定的部份。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.setproperty!(::Foo, x::<span class="built_in">Symbol</span>, v) = <span class="literal">nothing</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; foo.b = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>不過要注意的是，如果對本身就有屬性的型別增加 <code>Base.getproperty</code> 及 <code>Base.setproperty!</code> 兩個方法，會去更動到原先的屬性存取行為喔！這邊要注意一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 的物件都有屬性，但這需要寫在型別中事先定義。但如果要為沒有任何屬性的型別增加屬性要怎麼做？&lt;/p&gt;
&lt;p&gt;Julia 的屬性存取是來自 &lt;code&gt;Base.getproperty&lt;/code&gt; 及 &lt;code&gt;Base.setproperty!&lt;/code&gt; 兩個方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>設定 Julia 多執行緒</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-multithread-setup/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-multithread-setup/</id>
    <published>2020-04-10T02:19:55.000Z</published>
    <updated>2020-04-10T02:19:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 從 v1.3 起支援多執行緒（multithreading）。</p><p>這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。</p><a id="more"></a><p>一般要在 Julia 中使用多執行緒，可以在啟動 Julia 時，以環境變數的形式指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JULIA_NUM_THREADS&#x3D;4 julia</span><br></pre></td></tr></table></figure><p>但不想在每次啟動時都加入，這樣會很麻煩。</p><p>我們可以將這個寫到環境變數當中。像是在 Linux 環境中，可以將以下環境變數寫到 ~/.bashrc 或 ~/.bash_profile 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JULIA_NUM_THREADS&#x3D;4</span><br></pre></td></tr></table></figure><p>Ref: <a href="https://docs.julialang.org/en/v1/manual/environment-variables/index.html" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/environment-variables/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 從 v1.3 起支援多執行緒（multithreading）。&lt;/p&gt;
&lt;p&gt;這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>編譯 Julia 套件來避免過長的載入時間</title>
    <link href="https://yuehhua.github.io/2020/04/10/compile-julia-package/"/>
    <id>https://yuehhua.github.io/2020/04/10/compile-julia-package/</id>
    <published>2020-04-10T02:06:04.000Z</published>
    <updated>2020-06-01T17:12:08.617Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（<code>using</code>）過於冗長。</p><p>Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。</p><p>為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。</p><p>PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。</p><p>近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。</p><a id="more"></a><h2 id="動態語言編譯">動態語言編譯</h2><p>在動態語言中，編譯一直是一個大問題。編譯時，需要知道更多底層的細節，像是變數的型別。例如 <code>foo(a::Any, b::Any)</code> 這樣的函式在動態語言中非常常見。Julia 會在呼叫 <code>foo(3, 4)</code> 時，經由型別推斷（type inference）知道它需要編譯 <code>foo(a::Int64, b::Int64)</code> 這樣的方法出來。當下次呼叫 <code>foo(3., 4.)</code> 時，則需要編譯 <code>foo(a::Float64, b::Float64)</code>。然而，要完整的編譯 <code>foo</code> 這個函式，需要編譯多少種方法呢？在型別的排列組合上會造成組合爆炸的問題，讓需要編譯的方法多到難以處理。這一直以來是動態語言無法完整編譯的問題點。</p><p>那麼 Julia 怎麼做？PackageCompiler.jl 套件的編譯來自於 JIT，所以它直接將 Julia session 中已經編譯的函式儲存下來，以利後續使用。編譯的函式會以動態函式庫（.so）的形式儲存，就如同其他語言一樣。然而，Julia 仍然沒有完整編譯，Julia 只有部份編譯便存入動態函式庫。若是需要使用到未編譯的函式，就會在使用時 JIT 去處理。或許可以藉由套件的測試來增加編譯的函式數目，例如提高測試的覆蓋度來儘可能觸發各式各樣的方法進行編譯，然後儲存下來。</p><h2 id="編譯套件">編譯套件</h2><p>這邊我以編譯 Plots.jl 套件為例，繪圖相關套件的載入時間總是異常地久，所以我選擇 Plots.jl 套件來舉例。</p><p>請確定 Julia 中已經安裝 Plots.jl 套件。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> PackageCompiler</span><br><span class="line"></span><br><span class="line">julia&gt; create_sysimage(:Plots; sysimage_path=<span class="string">"Plots.so"</span>)</span><br><span class="line">[ Info: PackageCompiler: creating system image object file, this might take a <span class="keyword">while</span>...</span><br></pre></td></tr></table></figure><p><code>create_sysimage</code> 會編譯並產生 sysimage，這個 image 可以在 Julia 啟動時一併載入，它會以動態函式庫的形式儲存下來。第一個參數請指定需要編譯的套件名稱，可以同時編譯多個套件，例如 <code>[:Plots, :Gadfly]</code>。關鍵字參數 <code>sysimage_path=&quot;Plots.so&quot;</code> 需要指定 system image 的檔名。執行後需要一段時間進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ls</span><br><span class="line">Plots.so</span><br></pre></td></tr></table></figure><p>編譯完成後便可以在目前的資料夾下看到編譯完成的檔案 <a href="http://Plots.so" target="_blank" rel="noopener">Plots.so</a>。</p><p>在下次使用時使用的話，請在啟動 Julia 時加入參數 <code>-JPlots.so</code>。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; exit()</span><br><span class="line"></span><br><span class="line">$ julia -JPlots.so</span><br></pre></td></tr></table></figure><p>如此，我們就可以看到在啟動 Julia 之後載入的套件就有 Plots.jl 囉！Plots.jl 套件的載入時間被包含在 Julia 啟動時間中。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.loaded_modules</span><br><span class="line"><span class="built_in">Dict</span>&#123;Base.PkgId,<span class="built_in">Module</span>&#125; with <span class="number">72</span> entries:</span><br><span class="line">  <span class="built_in">Future</span> [<span class="number">9</span>fa8497b-<span class="number">333</span>b-<span class="number">5362</span>-<span class="number">9e8</span>d-<span class="number">4</span>d0656e87820]           =&gt; <span class="built_in">Future</span></span><br><span class="line">  Requires [ae029012-a4dd-<span class="number">5104</span>-<span class="number">9</span>daa-d747884805df]         =&gt; Requires</span><br><span class="line">  RecipesBase [<span class="number">3</span>cdcf5f2-<span class="number">1</span>ef4-<span class="number">517</span>c-<span class="number">9805</span>-<span class="number">6587</span>b60abb01]      =&gt; RecipesBase</span><br><span class="line">  InteractiveUtils [b77e0a4c-d291-<span class="number">57</span>a0-<span class="number">90e8</span>-<span class="number">8</span>db25a27a240] =&gt; InteractiveUtils</span><br><span class="line">  Pkg [<span class="number">44</span>cfe95a-<span class="number">1</span>eb2-<span class="number">52</span>ea-b672-e2afdf69b78f]              =&gt; Pkg</span><br><span class="line">  Printf [de0858da-<span class="number">6303</span>-<span class="number">5e67</span>-<span class="number">8744</span>-<span class="number">51</span>eddeeeb8d7]           =&gt; Printf</span><br><span class="line">  Base64 [<span class="number">2</span>a0f44e3-<span class="number">6</span>c83-<span class="number">55</span>bd-<span class="number">87e4</span>-b1978d98bd5f]           =&gt; Base64</span><br><span class="line">  Test [<span class="number">8</span>dfed614-e22c-<span class="number">5e08</span>-<span class="number">85e1</span>-<span class="number">65</span>c5234f0b40]             =&gt; Test</span><br><span class="line">  Reexport [<span class="number">189</span>a3867-<span class="number">3050</span>-<span class="number">52</span>da-a836-e630ba90ab69]         =&gt; Reexport</span><br><span class="line">  Dates [ade2ca70-<span class="number">3891</span>-<span class="number">5945</span>-<span class="number">98</span>fb-dc099432e06a]            =&gt; Dates</span><br><span class="line">  DelimitedFiles [<span class="number">8</span>bb1440f-<span class="number">4735</span>-<span class="number">579</span>b-a4ab-<span class="number">409</span>b98df4dab]   =&gt; DelimitedFiles</span><br><span class="line">  LAME_jll [c1c5ebd0-<span class="number">6772</span>-<span class="number">5130</span>-a774-d5fcae4a789d]         =&gt; LAME_jll</span><br><span class="line">  Missings [e1d29d7a-bbdc-<span class="number">5</span>cf2-<span class="number">9</span>ac0-f12de2c33e28]         =&gt; Missings</span><br><span class="line">  __PackagePrecompilationStatementModule [top-level]      =&gt; __PackagePrecompilationStatementModule</span><br><span class="line">  Opus_jll [<span class="number">91</span>d4177d-<span class="number">7536</span>-<span class="number">5919</span>-b921-<span class="number">800302f37372</span>]         =&gt; Opus_jll</span><br><span class="line">  StatsBase [<span class="number">2913</span>bbd2-ae8a-<span class="number">5f71</span>-<span class="number">8</span>c99-<span class="number">4</span>fb6c76f3a91]        =&gt; StatsBase</span><br><span class="line">  libfdk_aac_jll [f638f0a6-<span class="number">7</span>fb0-<span class="number">5443</span>-<span class="number">88</span>ba-<span class="number">1</span>cc74229b280]   =&gt; libfdk_aac_jll</span><br><span class="line">  libvorbis_jll [f27f6e37-<span class="number">5</span>d2b-<span class="number">51</span>aa-<span class="number">960</span>f-b287f2bc3b7a]    =&gt; libvorbis_jll</span><br><span class="line">  REPL [<span class="number">3</span>fa0cd96-eef1-<span class="number">5676</span>-<span class="number">8</span>a61-b3b8758bbffb]             =&gt; REPL</span><br><span class="line">  x265_jll [dfaa095f-<span class="number">4041</span>-<span class="number">5</span>dcd-<span class="number">9319</span>-<span class="number">2</span>fabd8486b76]         =&gt; x265_jll</span><br><span class="line">  LibGit2 [<span class="number">76f85450</span>-<span class="number">5226</span>-<span class="number">5</span>b5a-<span class="number">8</span>eaa-<span class="number">529</span>ad045b433]          =&gt; LibGit2</span><br><span class="line">  Distributed [<span class="number">8</span>ba89e20-<span class="number">285</span>c-<span class="number">5</span>b6f-<span class="number">9357</span>-<span class="number">94700520</span>ee1b]      =&gt; Distributed</span><br><span class="line">  Plots [<span class="number">91</span>a5bcdd-<span class="number">55</span>d7-<span class="number">5</span>caf-<span class="number">9e0</span>b-<span class="number">520</span>d859cae80]            =&gt; Plots</span><br><span class="line">  LinearAlgebra [<span class="number">37e2</span>e46d-f89d-<span class="number">539</span>d-b4ee-<span class="number">838</span>fcccc9c8e]    =&gt; LinearAlgebra</span><br><span class="line">  ⋮                                                       =&gt; ⋮</span><br><span class="line"></span><br><span class="line">julia&gt; Plots.plot</span><br><span class="line">plot (generic <span class="keyword">function</span> with <span class="number">3</span> methods)</span><br></pre></td></tr></table></figure><h2 id="編譯到預設位置">編譯到預設位置</h2><p>Julia 在系統中有 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它預設會在 Julia 啟動時載入，我們可以利用預先編譯好的函式庫來取代它，就可以不用參數的情況下自動載入。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_sysimage([:Debugger, :OhMyREPL]; replace_default=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>將 <code>sysimage_path</code> 換成 <code>replace_default=true</code>，來將編譯的函式庫取代 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它會將原本的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 備份到 sys.so.backup，並將編譯好的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 寫入。</p><h2 id="增量編譯（incremental-compilation）">增量編譯（incremental compilation）</h2><p>sysimage 可以進行增量編譯。增量編譯是指既有的函式並不會重新編譯，只會編譯那些新加入的函式。如果已經有 sysimage，那麼下次呼叫 <code>create_sysimage</code> 時，只會編譯新加入的部份，並且用新的函式庫檔案取代舊的。</p><p>如果你想要關閉這個功能，那需要加入 <code>incremental=false</code> 來關閉增量編譯，這樣就會編譯一個全新的函式庫。</p><h2 id="利用套件的測試程式碼做編譯">利用套件的測試程式碼做編譯</h2><p>一般而言，在動態語言中，我們無法編譯所有可能的方法，取而代之的是，我們可以<strong>儘可能</strong>編譯更多方法。編譯更多方法越可能可以避免 Julia 啟動 JIT 在執行時期去編譯新的方法。這時候我們可以利用套件中的測試程式碼，當套件中自帶的測試程式碼，如果覆蓋率夠高，那麼就可以有越完善的編譯。這時候我們可以在編譯之前執行測試來促使 JIT 編譯各種方法。</p><p>我們可以利用以下程式碼來執行測試，並促使 JIT 進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Plots</span><br><span class="line">include(joinpath(pkgdir(Plots), <span class="string">"test"</span>, <span class="string">"runtests.jl"</span>))</span><br></pre></td></tr></table></figure><p>套件的測試期間常常會有其他的相依套件，缺乏相依套件都會使測試失敗。需要不斷執行測試，並且檢查及安裝缺失的相依套件。</p><p>等測試都執行完成了，就可以進行套件編譯了。</p><h2 id="編譯被使用的方法">編譯被使用的方法</h2><p>如果需要編譯被使用的方法，例如在特定腳本被使用到，這時候我們需要更細緻的編譯方式。我們需要知道哪些方法在腳本當中被使用到，這時候我們可以在啟動 Julia 時加入 <code>--trace-compile=precompile.jl</code>。<code>--trace-compile</code> 會讓 Julia 紀錄下哪些方法有被編譯過，並且輸出在 precompile.jl 檔案中紀錄下來。</p><p><code>--trace-compile</code> 會紀錄哪些方法需要預編譯（precompilation）。例如執行 <code>julia --trace-compile=precompile.jl -e '1+1'</code> 會得到一個 precompile.jl 檔案，其中測試了 <code>1+1</code> 的預編譯，並且紀錄下來。因此，會在 precompile.jl 檔案中看到以下內容：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.similar), <span class="built_in">Array</span>&#123;Base.Grisu.Bignums.Bignum, <span class="number">1</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.length), <span class="built_in">Array</span>&#123;Base.Grisu.Bignums.Bignum, <span class="number">1</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.deepcopy_internal), <span class="built_in">Any</span>, Base.IdDict&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;&#125;)</span><br><span class="line">precompile(<span class="built_in">Tuple</span>&#123;typeof(Base.deepcopy_internal), <span class="built_in">Array</span>&#123;<span class="built_in">UInt32</span>, <span class="number">1</span>&#125;, Base.IdDict&#123;<span class="built_in">Any</span>, <span class="built_in">Any</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>這就是 <code>--trace-compile</code> 將需要預編譯的方法輸出的結果。</p><p>我們可以將這些結果放到 <code>create_sysimage</code> 中。可以在 <code>create_sysimage</code> 加入關鍵字參數 <code>precompile_statements_file=&quot;precompile.jl&quot;</code>，並且指定剛剛輸出的預編譯紀錄檔 precompile.jl。它會讓 Julia 根據紀錄檔中所需要使用到的方法進行編譯。如此就可以編譯在腳本當中被使用到的方法了！</p><p>Ref: <a href="https://julialang.github.io/PackageCompiler.jl/dev/sysimages/" target="_blank" rel="noopener">https://julialang.github.io/PackageCompiler.jl/dev/sysimages/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（&lt;code&gt;using&lt;/code&gt;）過於冗長。&lt;/p&gt;
&lt;p&gt;Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。&lt;/p&gt;
&lt;p&gt;為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。&lt;/p&gt;
&lt;p&gt;PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。&lt;/p&gt;
&lt;p&gt;近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia 的多重分派</title>
    <link href="https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/"/>
    <id>https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/</id>
    <published>2020-04-01T15:27:42.000Z</published>
    <updated>2020-04-01T15:27:42.500Z</updated>
    
    <content type="html"><![CDATA[<p>今天來談談 Julia 的多重分派（multiple dispatch）。</p><p>很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。</p><p>在現今的物件導向程式設計當中，我們會將函式歸納到某個類別底下成為其類別的方法，而這個方法就屬於這個類別。</p><h2 id="多重分派-v-s-單一分派">多重分派 v.s. 單一分派</h2><p>這樣的觀點就是單一分派的精神，單一分派是指一個方法的呼叫，要如何決定呼叫的是哪一個方法實作呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(x)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure><p>像以上的 python 程式碼，<code>foo.abc(x)</code> 就是去呼叫 <code>Foo</code> 的方法，而 <code>bar.abc(x)</code> 則是去呼叫 <code>Bar</code> 的方法。</p><p>也就是說，方法的呼叫是由第一個參數所決定的，這邊要注意的是第一個參數並不是 <code>x</code>，而是 <code>self</code> 喔！也就是物件本身！</p><p>相對於單一分派，多重分派是指他會參考所有的參數型別及其組合來決定到底要呼叫哪一個方法。</p><p>所以我們也有了更細緻的選擇。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(foo::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(foo::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><p>當第一個參數型別是 <code>Foo</code> 時，就回傳字串，而當第一個參數型別是 <code>Bar</code> 時，就回傳整數。</p><p>我們可以去區別，當 <code>x</code> 已經是整數或是字串時就不用去處理它，直接回傳即可。若是有不同型別時，個別處理。</p><p>這邊我們並沒有使用到第一個型別的參數，在 Julia 裡可以省略變數本身，只寫型別。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><h2 id="多重分派的自由與限制">多重分派的自由與限制</h2><p>使用多重分派可以讓語言有更細緻的定義，也有更高的自由度。</p><p>我們可以看看以下的例子，這邊使用了常常被使用的 null pattern：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push!(ls::List, obj::NullObject) = ls</span><br><span class="line"></span><br><span class="line">psuh!(ls::List, obj::Object) = push!(ls.array, obj)</span><br></pre></td></tr></table></figure><p>當我要去表示一類物件，我們會實作 <code>Object</code>，但往往我們會想要表示一個為空的物件，這時候我們就會有一個 <code>NullObject</code> 來表達這件事。</p><p>當我們想要將一個 <code>Object</code> 放到 <code>List</code> 中的時候，我們會實作 <code>push!</code>，然而當一個 <code>NullObject</code> 被放入 <code>List</code> 的時候，我們並不需要真的做什麼樣的動作。實作就會如同上面的程式碼。</p><p>相對在 python 或是一般物件導向語言當中，我們就會看到以下的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> type(obj) == NullObject:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">elif</span> type(obj) == Object:</span><br><span class="line">            self.array.append(obj)</span><br></pre></td></tr></table></figure><p>我們需要自己去判斷接收進來的參數型別，然後進一步做處理。這樣的話會讓我們的程式碼充滿 if-else，當條件一多時，會變得相當難以閱讀及修改。</p><p>使用多重分派並不是只有優點，他也有缺點。多重分派會引入模糊性（ambiguity）。</p><p>考慮以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b) = a</span><br><span class="line">foo(a, b::B) = b</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br></pre></td></tr></table></figure><p>請問 <code>foo(a, b)</code> 該呼叫哪一個方法呢？</p><p>這樣的呼叫在 Julia 會產生錯誤，也就是編譯器不知道該呼叫哪一個方法。</p><p>這時候編譯器會建議修改的方式，就是定義一個更明確的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b::B)</span><br></pre></td></tr></table></figure><h2 id="應用情境">應用情境</h2><p>我們來寫個簡單的剪刀石頭布遊戲！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Paper <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Scissor <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Stone <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們分別有三個型別分別代表剪刀石頭布。</p><p>接下來我們定義運算，先定義贏的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">play(::Paper, ::Stone) = <span class="number">1</span></span><br><span class="line">play(::Scissor, ::Paper) = <span class="number">1</span></span><br><span class="line">play(::Stone, ::Scissor) = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>當雙方是相同時就平手：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(::T, ::T) <span class="keyword">where</span> &#123;T&#125; = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>這邊我們利用了 Julia 的參數化方法，當兩個有相同的型別時，就回傳 0。</p><p>最後，是輸的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(a, b) = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>也就是，如果沒有符合以上的狀況的方法呼叫，就會落到這個狀況來，所以這邊我們允許最廣義的 <code>Any</code> 型別。</p><p>希望大家可以經由這個簡單的例子來理解 Julia 的多重分派有多好用，甚至是搭配上參數化方法根本是逆天阿！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天來談談 Julia 的多重分派（multiple dispatch）。&lt;/p&gt;
&lt;p&gt;很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。&lt;/p&gt;
&lt;p&gt;在現今的物件導向程式設計當中，我們會將函式歸納
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia v1.4 釋出</title>
    <link href="https://yuehhua.github.io/2020/03/24/julia-v1-4-release/"/>
    <id>https://yuehhua.github.io/2020/03/24/julia-v1-4-release/</id>
    <published>2020-03-24T04:02:05.000Z</published>
    <updated>2020-08-07T03:14:28.835Z</updated>
    
    <content type="html"><![CDATA[<p>Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。<br>底下新功能後面會有括弧，附註相關的實作程式碼。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><h3 id="使用者功能">使用者功能</h3><ul><li><code>import</code> 允許符號，例如 <code>import Base.:+</code>。(#33158)</li><li>允許使用 <code>a[begin]</code> 來存取 <code>a</code> 的首位元素。首位元素的索引是由 <code>firstindex(a)</code> 計算得出。(#33946)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; x[<span class="keyword">begin</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>值可以藉由 <code>$</code> 內插到 <code>@async</code> 及 <code>@spawn</code> 中，它會將值直接複製一份到閉包（closure）中。(#33119)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>結構 <code>struct</code> 當中，所有位元（isbits）或是位元聯集（isbitsunion）的欄位（fields）都會儲存為陣列的元素。(#32448)</li></ul><p>以前在 Julia 的結構當中，只有所有欄位都有相同的型別，而且型別都是原始型別時，Julia 底層會將他們封裝到一個陣列中，如此可以加速。在 v1.4 版後放寬了這樣的限制，讓有所有位元欄位都儲存為陣列。</p><h2 id="新功能">新功能</h2><ul><li>Iterators 模組中有 <code>accumulate</code> 實作。(#34033)</li></ul><p>Jeff 頗驚訝，之前怎麼沒有這個功能XD</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; iter = Iterators.accumulate(+, x)</span><br><span class="line">Base.Iterators.Accumulate&#123;typeof(+),<span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;&#125;(+, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; foreach(println, iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>功能與 <code>Base.accumulate</code> 雷同，但是屬於 lazy evaluation。</p><ul><li><code>evalpoly</code> 可以用來計算多項式函數，例如 <code>evalpoly(x, (p1, p2, p3))</code>。(#32753)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; evalpoly(<span class="number">5</span>, (<span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>相當於計算 $p(5) = 10 + 3\times5 + 1\times5^2$。</p><ul><li>允許複合函數（function composition）<code>∘(f, g, h) = f ∘ g ∘ h</code>，以及解開 <code>∘(fs...)</code>，當中 <code>fs</code> 可以是 Iterable 的函數集合。(#33568)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; f(x) = x + <span class="number">1</span></span><br><span class="line">f (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; g(x) = <span class="number">2</span>x</span><br><span class="line">g (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; F = f∘g</span><br><span class="line"><span class="comment">#64 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; F(<span class="number">5</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="新支援">新支援</h2><ul><li><code>gcd</code>、<code>lcm</code> 及 <code>gcdx</code> 支援 <code>Rational</code> 型別的參數。(#33910)</li><li><code>splitpath</code> 支援任何 <code>AbstractString</code> 型別，然而以前只支援 <code>String</code> 的路徑。(#33012)</li><li><code>filter</code> 可以作用在 <code>Tuple</code> 上。(#32968)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。&lt;br&gt;
底下新功能後面會有括弧，附註相關的實作程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>從 iterator 及 generator 到 iterable</title>
    <link href="https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/"/>
    <id>https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/</id>
    <published>2020-03-01T06:31:49.000Z</published>
    <updated>2020-03-05T16:32:51.101Z</updated>
    
    <content type="html"><![CDATA[<p>今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 <code>in</code> 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？</p><a id="more"></a><p>很基本的作法是去實作一個設計模式（design pattern）中的 iterator，假設我們要迭代一個陣列裡的元素，iterator 有別於陣列本身，是另外一個物件。Iterator 可以提供你一個介面，例如 <code>next()</code>，讓你可以取得陣列裡的下一個元素。</p><p>像這樣的方式很常見也很簡單可以實作，在 Julia 裡就像這樣：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> ArrayIterator</span><br><span class="line">    array::<span class="built_in">Array</span></span><br><span class="line">    index::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">    ArrayIterator(array::<span class="built_in">Array</span>) = new(array, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">has_next(iter::ArrayIterator) = (iter.index &lt; length(iter.array))</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> next(iter::ArrayIterator)</span><br><span class="line">    x = iter.array[iter.index]</span><br><span class="line">    iter.index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">2</span>:<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; iter = ArrayIterator(v);</span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>各位可以看到 iterator 一般都會實作 <code>has_next()</code> 及 <code>next()</code> 函式，是用來確認是否有下一個元素存在及取得下一個元素。Iterator 中會包含陣列本身，也就是想要迭代的集合本身，還有一個 <code>index</code> 會指向目前的元素，並在取得元素之後移往下一個。</p><p>Iterator 是一個物件，它需要一個已經存在的集合來作為它迭代的集合。這代表這個集合必須事先存在，如果這個集合很大，那就會佔去不少記憶體空間。有沒有什麼方法可以不需要集合就可以迭代的呢？Generator 是一個方式。</p><p>Generator，顧名思義，它會在你取得下一個元素的時候產生出來，並不會事先計算，所以集合也不會存在。Julia 的 generator 很好撰寫，如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (i^<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這就是一個會產生 1 到 10 數字的 generator。Generator 也可以被放到 for 迴圈裡被迭代，但唯一不同的是，它並不佔記憶體空間，只需要即時的計算即可。</p><p>Julia 目前提供的方式稱為 Iterable，只要有實作 <code>iterate()</code> 這個 API 的就稱為 Iterable。像以下例子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Character</span><br><span class="line">    start::<span class="built_in">Char</span></span><br><span class="line">    length::<span class="built_in">Int</span></span><br><span class="line">    Character() = new(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(char::Character, (el, i)=(char.start, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> i &lt; char.length</span><br><span class="line">        <span class="keyword">return</span> (el, (el+<span class="number">1</span>, i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.length(char::Character) = char.length</span><br><span class="line">Base.eltype(::Character) = <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p><code>iterate()</code> 的輸入是「狀態」，輸出是下一個狀態，而狀態包含兩個物件：要迭代的元素以及順序。因此，會看起來像是這個樣子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(el1, (el2, i+<span class="number">1</span>)) = iterate(iter, (el1, i))</span><br></pre></td></tr></table></figure><p>特別要說明的是，在輸出的狀態中，需要帶有目前元素的資訊 <code>(el1, (el2, i+1))</code>。如果要結束迴圈，那就回傳 <code>nothing</code>。我們就可以來世試看這個可以迭代輸出 ASCII 碼的 Iterable。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; c = Character()</span><br><span class="line">Character(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c, (<span class="string">'B'</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="string">'C'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> c</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br><span class="line">F</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣可以有 generator 的好處，而且本身也是一個 iterator。它不需要是一個物件，只要有實作 <code>iterate()</code> 這個 API 的物件就可以使用，所以我們還可以拿來這樣用。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> IterableNumber</span><br><span class="line">    start::<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.iterate(iter::IterableNumber, (el, i)=(iter.start, <span class="number">0</span>)) = i &lt; <span class="literal">Inf</span> ? (el, (el+<span class="number">1</span>, i+<span class="number">1</span>)) : <span class="literal">nothing</span></span><br></pre></td></tr></table></figure><p>這是一個可以自定義起點的可迭代數字，數字可以持續到無限大。你得手動把它停下來！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; iter = IterableNumber(<span class="number">0</span>)</span><br><span class="line">IterableNumber(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> i <span class="keyword">in</span> iter</span><br><span class="line">           println(i)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或是你想做個 sliding window：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SlidingWindow</span><br><span class="line">    vec::<span class="built_in">Vector</span></span><br><span class="line">    n::<span class="built_in">Int</span></span><br><span class="line">    start::<span class="built_in">SubArray</span></span><br><span class="line"></span><br><span class="line">    SlidingWindow(vec::<span class="built_in">Vector</span>, n) = new(vec, n, view(vec, <span class="number">1</span>:n))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(iter::SlidingWindow, (el, i)=(iter.start, <span class="number">1</span>))</span><br><span class="line">    <span class="literal">e</span> = i + iter.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">e</span> &lt;= length(iter.vec)</span><br><span class="line">        <span class="keyword">return</span> (el, (view(iter.vec, i:<span class="literal">e</span>), i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊用 <code>view(iter.vec, i:e)</code> 做取值的方式，比起用 <code>iter.vec[i:e]</code> 取值來的快很多。<code>iter.vec[i:e]</code> 這種方式會造出一個新的陣列，而 view 不會。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; sw = SlidingWindow(v, <span class="number">5</span>)</span><br><span class="line">SlidingWindow([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>  …  <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>], <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> sw</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這邊介紹了三種迭代的方法，而 iterable 則是目前由 Julia 官方支援的主流方式。除了可以迭代數字以外還可以有其他用途，甚至可以迭代直到無限大的數字。Sliding window 這樣的東西在計算上或是深度學習上是很實用的結構！是不是覺得 Julia 越來越像 functional language 了XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 &lt;code&gt;in&lt;/code&gt; 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>One-way ANOVA and sum of squares</title>
    <link href="https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/"/>
    <id>https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/</id>
    <published>2020-02-09T16:01:59.000Z</published>
    <updated>2020-03-09T17:07:49.402Z</updated>
    
    <content type="html"><![CDATA[<p><strong>An</strong>alysis <strong>o</strong>f <strong>va</strong>riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms <strong>explained variance</strong> (or <strong>between-group variance</strong> in categorical factor) and <strong>unexplained variance</strong> (or <strong>within-group variance</strong> in categorical factor).</p><a id="more"></a><h2 id="Sum-of-squares">Sum of squares</h2><p>Sum of squares come from the concept of calculating the (squared Euclidean) distance among data. Let’s consider the total sum of squares $SS_{total}$.</p><p>$$<br>SS_{total} = \sum_i (y_i - \bar{y})^2<br>$$</p><p>$y_i$ represents the true data value, $\bar{y}$ represents the mean of data $y_i$. We can get variance from $SS_{total}$ by dividing the <strong>degree of freedom</strong> ($df$).</p><p>$$<br>\begin{align}<br>Var[Y] &amp;= \frac{SS_{total}}{df} \\<br>&amp;= \frac{1}{n-1} \sum_i (y_i - \bar{y})^2<br>\end{align}<br>$$</p><p>The equation above shows the relation between sum of square and variance.</p><p>We always attempt to model the phonomena from data. Constructing the hypothesis or model and validate our hypothesis by testing their siginificant. If our model is true, then model must catch some variance and extract information from data for us. If the model is not true, model catch less variance just as the noise does.</p><p>So, we defined two kinds of sum of squares to measure how much variance is caught by model or not. We usually use a regression to model our data, so we have regression sum of square $SS_{reg}$, which represents the amount of sum of square explained by model. Sum of square other than regression sum of square is left as residual sum of square $SS_{res}$, which represents the amount of sum of square unexplained by model.</p><p>$$<br>SS_{reg} = \sum_i (\hat{y}_i - \bar{y})^2<br>$$</p><p>$\hat{y}_i$ represents the prediction value given by the model. If the sum of square is modeled, then the distance between the mean and the model prediction is explained by model.</p><p>$$<br>SS_{res} = \sum_i (y_i - \hat{y}_i)^2<br>$$</p><p>If the sum of square is not modeled, then the distance between the data and the model prediction is left unexplained as noise.</p><p>There is a relationship amoung them. We are going to proof it. However, the tools are not enough to prove it. We need the following two equations:</p><p>$$<br>\sum_i e_i = \sum_i (y_i - \hat{y}_i) = 0<br>$$</p><p>$$<br>\sum_i \hat{y}_i e_i = 0<br>$$</p><p>We start from $SS_{total}$.</p><p>$$<br>\begin{align}<br>SS_{total} &amp;= \sum_i (y_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i + \hat{y}_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + (\hat{y}_i - \bar{y})^2 + 2(y_i - \hat{y}_i)(\hat{y}_i - \bar{y}) \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + \sum_i (\hat{y}_i - \bar{y})^2 + 2 \sum_i \hat{y}_i(y_i - \hat{y}_i) - 2\bar{y} \sum_i (y_i - \hat{y}_i) \\<br>\end{align}<br>$$</p><p>Now you may see $SS_{reg}$ and $SS_{res}$ in the formula.</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res} + 2 \sum_i \hat{y}_i e_i - 2\bar{y} \sum_i e_i<br>$$</p><p>Due to the fact that the last two summation terms are zero. So we have:</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res}<br>$$</p><p>So now we have it! If we face a dataset, assuming that we know nothing about the data, we could only measure the mean and variance about the data.</p><p>Mean tells us the “location” about the data. If I told you the average height of whole people in the class, you prabably could have a idea or even guess <em>where data locate</em>.</p><p>Variance tell us the “range”, or formally “dispersion”, about the dataset. If the variance is large, we have high uncertainty about the data. Sometimes, we even know the mean, we still cannot guess the answer accurately, because we have no idea about <em>what is the scale of data</em>. In some sense, variance is associated with sum of squares(, and it truely is).</p><p>If we know the model in advance, we know the inner structure of phenomena and how the data is generated. That’s why we usually want to model things. If we introduce a model, it can help us extracting the inner structure (or information) from uncertainty. It reduce the uncertainty and give us information.</p><p>The total sum of squares act as the total uncertainty we face, and it can further be decoupled into two parts. If we have a model to help us, model extracts information and represents as regression sum of squares. The rest of uncertainty remains as <strong>residuals</strong>.</p><h2 id="One-way-ANOVA">One-way ANOVA</h2><p>ANOVA is a way to decouple sum of squares so that we can quantify how well the model is.</p><p>We can further make the ANOVA table as follow:</p><p>$$<br>\begin{array}{l c c c}<br>\ &amp; SS &amp; df &amp; MS &amp; F \\<br>\hline<br>model &amp; SS_{reg} &amp; k-1 &amp; MS_{reg} &amp; \frac{MS_{reg}}{MS_{res}} \\<br>error &amp; SS_{res} &amp; n-k &amp; MS_{res} &amp; \\<br>\hline<br>total &amp; SS_{total} &amp; n-1 &amp; MS_{total} &amp; \\<br>\end{array}<br>$$</p><p>Fill in the corresponding cell. Degree of freedom is about how many parameters you used to estimate your model. However, it is not always the case, you may want to read statistics textbook for some theoretical reasons. $k$ is the random variables you used in your model.</p><p>$$<br>MS_{reg} = \frac{SS_{reg}}{k-1} \\<br>MS_{res} = \frac{SS_{res}}{n-k}<br>$$</p><p>$MS$ means <em>mean of squares</em>, which it $SS$ divided by $df$. Moreover, we can calculate the F statistics for F test and the F test itself is so called <strong>one-way ANOVA</strong>.</p><p>$$<br>F = \frac{\text{explained variance}}{\text{unexplained variance}}<br>$$</p><p>F-value has its own meaning. It measures <em>how much variance is caught by our model</em> (or $MS_{reg}$), and it is a relative measurement, so it is divided by <em>the variance not caught by our model</em> (or $MS_{res}$). In aonother way, the model can <strong>explained</strong> part of variance, and the rest is left <strong>unexplained</strong>.</p><p>If the model we used is not something like linear regression, rather, we separate data into different categories. We used the following formula:</p><p>$$<br>F = \frac{\text{between-group variance}}{\text{within-group variance}}<br>$$</p><p>We could further test if the F-value is significant or not.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;An&lt;/strong&gt;alysis &lt;strong&gt;o&lt;/strong&gt;f &lt;strong&gt;va&lt;/strong&gt;riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms &lt;strong&gt;explained variance&lt;/strong&gt; (or &lt;strong&gt;between-group variance&lt;/strong&gt; in categorical factor) and &lt;strong&gt;unexplained variance&lt;/strong&gt; (or &lt;strong&gt;within-group variance&lt;/strong&gt; in categorical factor).&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>Relationship between variance and pairwise distance</title>
    <link href="https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/"/>
    <id>https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/</id>
    <published>2020-02-09T14:28:52.000Z</published>
    <updated>2020-03-06T07:55:43.094Z</updated>
    
    <content type="html"><![CDATA[<p>Random variable $X$, we have the variance</p><p>$$<br>\begin{align}<br>Var[X] &amp;= \mathbb{E}[(X - \mu)^2] \\<br>&amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2<br>\end{align}<br>$$</p><a id="more"></a><p>Pairwise (squared Euclidean) distance will be<br>Andrew Gerrand<br>$$<br>\begin{align}<br>\sum_{i \ne j} d(x_i, x_j) &amp;= \sum_{i=1}^n \sum_{j=i+1}^n (x_i - x_j)^2 \\<br>&amp;= \sum_{i=1}^n \sum_{j=i+1}^n ((x_i - \mu) - (x_j - \mu))^2 \\<br>&amp;= n \sum_{i=1}^n (x_i - \mu)^2 \\<br>&amp;= n^2 \mathbb{E}[(X - \mu)^2] \\<br>&amp;= n^2 Var[X]<br>\end{align}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Random variable $X$, we have the variance&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;
\begin{align}&lt;br&gt;
Var[X] &amp;amp;= \mathbb{E}[(X - \mu)^2] \\&lt;br&gt;
&amp;amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2&lt;br&gt;
\end{align}&lt;br&gt;
$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>程式設計師勝任程度</title>
    <link href="https://yuehhua.github.io/2019/12/11/programmer-competency/"/>
    <id>https://yuehhua.github.io/2019/12/11/programmer-competency/</id>
    <published>2019-12-11T07:08:58.000Z</published>
    <updated>2019-12-11T07:08:58.297Z</updated>
    
    <content type="html"><![CDATA[<p>先前看到了 <a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a>，所以就自己幫自己評比一下。</p><ul><li>Computer Science<ul><li>data structures: level 3</li><li>algorithms: level 3</li><li>systems programming: level 2</li></ul></li><li>Software Engineering<ul><li>source code version control: level 3</li><li>build automation: level 2</li><li>automated testing: level 2</li></ul></li><li>Programming<ul><li>problem decomposition: level 3</li><li>systems decomposition: level 2</li><li>communication: level 3</li><li>code organization within a file: level 2</li><li>code organization across files: level 2</li><li>source tree organization: level 3</li><li>code readability: level 3</li><li>defensive coding: level 2</li><li>error handling: level 1</li><li>IDE: level 2</li><li>API: level 1</li><li>frameworks: level 3</li><li>requirements: level 2</li><li>scripting: level 2</li><li>database: level 2</li></ul></li><li>Experience<ul><li>languages with professional experience: level 1~2 (familiar with OO language with functional patterns)</li><li>platforms with professional experience: level 2</li><li>years of professional experience: level 2</li><li>domain knowledge: level 2</li></ul></li><li>Knowledge<ul><li>tool knowledge: level 2</li><li>languages exposed to: level 2~3 (used Prolog before)</li><li>codebase knowledge: level 3 (I started a project before)</li><li>knowledge of upcoming technologies: level 2</li><li>platform internals: level 1~2 (not sure)</li><li>books: level 2 (actually used and read books)</li><li>blogs: level 3 (but not regularly update blog posts)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先前看到了 &lt;a href=&quot;http://sijinjoseph.com/programmer-competency-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programmer Competency Matrix&lt;/a&gt;，所以就自
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Name binding 與 dispatch</title>
    <link href="https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/"/>
    <id>https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/</id>
    <published>2019-12-01T02:49:40.000Z</published>
    <updated>2019-12-01T02:49:40.195Z</updated>
    
    <content type="html"><![CDATA[<p>Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。</p><p>Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。</p><a id="more"></a><p>一般而言，當物件被去除綁定，那物件將會被垃圾回收（garbage collection）機制給處理掉。</p><p>Name binding 依據時間分為：</p><ul><li>Static binding (or early binding)：在編譯時期（compile time）進行綁定</li><li>Dynamic binding (or late binding)：在執行時期（runtime）進行綁定</li></ul><p>Static binding 的一個經典例子是 C 的函式呼叫，它在編譯時期就將函式內容綁定到識別符上，而無法在執行時期變更。</p><p>Dynamic binding 的一個相對應的例子則是 C++ 的虛擬方法呼叫，由於多型的機制，物件的型別無法在編譯時期得知，所以綁定會在執行時期處理。</p><p>在執行時期，如果識別符變更參考到其他的物件，我們稱為重新綁定（rebinding）。如果是變更識別符指向的物件本身，那麼我們稱為突變（mutation）。</p><p>在這邊提到多型的機制，就不得不去提 dispatch 的機制。一般在物件導向語言中以 dynamic dispatch 為主，表示在多型機制下，方法的選定是由第一個參數的型別來決定。</p><p>Dispatch 是個選擇的問題，而 binding 是個綁定的問題。選擇一定要發生在綁定後。</p><p>Dynamic dispatch 可以是 static binding 也可以是 dynamic binding，但是 dynamic binding 就只能在執行時間做 dispatch 了。</p><p>Dynamic dispatch 一般指 single dispatch，也就是由第一個參數的型別來決定要呼叫哪一個方法。相對也有 multiple dispatch，就會利用所有的參數型的排列組合來決定要呼叫哪一個方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。&lt;/p&gt;
&lt;p&gt;Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Compiler" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Compiler/"/>
    
    
  </entry>
  
</feed>
