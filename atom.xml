<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Maker</title>
  
  <subtitle>Love Math, Science, Biology, Computer science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuehhua.github.io/"/>
  <updated>2020-04-10T02:19:55.814Z</updated>
  <id>https://yuehhua.github.io/</id>
  
  <author>
    <name>Yueh-Hua Tu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>設定 Julia 多執行緒</title>
    <link href="https://yuehhua.github.io/2020/04/10/julia-multithread-setup/"/>
    <id>https://yuehhua.github.io/2020/04/10/julia-multithread-setup/</id>
    <published>2020-04-10T02:19:55.000Z</published>
    <updated>2020-04-10T02:19:55.814Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 從 v1.3 起支援多執行緒（multithreading）。</p><p>這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。</p><a id="more"></a><p>一般要在 Julia 中使用多執行緒，可以在啟動 Julia 時，以環境變數的形式指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ JULIA_NUM_THREADS&#x3D;4 julia</span><br></pre></td></tr></table></figure><p>但不想在每次啟動時都加入，這樣會很麻煩。</p><p>我們可以將這個寫到環境變數當中。像是在 Linux 環境中，可以將以下環境變數寫到 ~/.bashrc 或 ~/.bash_profile 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JULIA_NUM_THREADS&#x3D;4</span><br></pre></td></tr></table></figure><p>Ref: <a href="https://docs.julialang.org/en/v1/manual/environment-variables/index.html" target="_blank" rel="noopener">https://docs.julialang.org/en/v1/manual/environment-variables/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 從 v1.3 起支援多執行緒（multithreading）。&lt;/p&gt;
&lt;p&gt;這邊文章要來教大家如何在 Julia 啟動時，自動配置多執行緒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>編譯 Julia 套件來避免過長的載入時間</title>
    <link href="https://yuehhua.github.io/2020/04/10/compile-julia-package/"/>
    <id>https://yuehhua.github.io/2020/04/10/compile-julia-package/</id>
    <published>2020-04-10T02:06:04.000Z</published>
    <updated>2020-04-10T02:11:39.723Z</updated>
    
    <content type="html"><![CDATA[<p>Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（<code>using</code>）過於冗長。</p><p>Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。</p><p>為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。</p><p>PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。</p><p>近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。</p><a id="more"></a><h2 id="動態語言編譯">動態語言編譯</h2><p>在動態語言中，編譯一直是一個大問題。編譯時，需要知道更多底層的細節，像是變數的型別。例如 <code>foo(a::Any, b::Any)</code> 這樣的函式在動態語言中非常常見。Julia 會在呼叫 <code>foo(3, 4)</code> 時，經由型別推斷（type inference）知道它需要編譯 <code>foo(a::Int64, b::Int64)</code> 這樣的方法出來。當下次呼叫 <code>foo(3., 4.)</code> 時，則需要編譯 <code>foo(a::Float64, b::Float64)</code>。然而，要完整的編譯 <code>foo</code> 這個函式，需要編譯多少種方法呢？在型別的排列組合上會造成組合爆炸的問題，讓需要編譯的方法多到難以處理。這一直以來是動態語言無法完整編譯的問題點。</p><p>那麼 Julia 怎麼做？PackageCompiler.jl 套件的編譯來自於 JIT，所以它直接將 Julia session 中已經編譯的函式儲存下來，以利後續使用。編譯的函式會以動態函式庫（.so）的形式儲存，就如同其他語言一樣。然而，Julia 仍然沒有完整編譯，Julia 只有部份編譯便存入動態函式庫。若是需要使用到未編譯的函式，就會在使用時 JIT 去處理。或許可以藉由套件的測試來增加編譯的函式數目，例如提高測試的覆蓋度來儘可能觸發各式各樣的方法進行編譯，然後儲存下來。</p><h2 id="編譯套件">編譯套件</h2><p>這邊我以編譯 Plots.jl 套件為例，繪圖相關套件的載入時間總是異常地久，所以我選擇 Plots.jl 套件來舉例。</p><p>請確定 Julia 中已經安裝 Plots.jl 套件。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; <span class="keyword">using</span> PackageCompiler</span><br><span class="line"></span><br><span class="line">julia&gt; create_sysimage(:Plots; sysimage_path=<span class="string">"Plots.so"</span>)</span><br><span class="line">[ Info: PackageCompiler: creating system image object file, this might take a <span class="keyword">while</span>...</span><br></pre></td></tr></table></figure><p><code>create_sysimage</code> 會編譯並產生 sysimage，這個 image 可以在 Julia 啟動時一併載入，它會以動態函式庫的形式儲存下來。第一個參數請指定需要編譯的套件名稱，可以同時編譯多個套件，例如 <code>[:Plots, :Gadfly]</code>。關鍵字參數 <code>sysimage_path=&quot;Plots.so&quot;</code> 需要指定 system image 的檔名。執行後需要一段時間進行編譯。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ls</span><br><span class="line">Plots.so</span><br></pre></td></tr></table></figure><p>編譯完成後便可以在目前的資料夾下看到編譯完成的檔案 <a href="http://Plots.so" target="_blank" rel="noopener">Plots.so</a>。</p><p>在下次使用時使用的話，請在啟動 Julia 時加入參數 <code>-JPlots.so</code>。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; exit()</span><br><span class="line"></span><br><span class="line">$ julia -JPlots.so</span><br></pre></td></tr></table></figure><p>如此，我們就可以看到在啟動 Julia 之後載入的套件就有 Plots.jl 囉！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; Base.loaded_modules</span><br><span class="line"><span class="built_in">Dict</span>&#123;Base.PkgId,<span class="built_in">Module</span>&#125; with <span class="number">72</span> entries:</span><br><span class="line">  <span class="built_in">Future</span> [<span class="number">9</span>fa8497b-<span class="number">333</span>b-<span class="number">5362</span>-<span class="number">9e8</span>d-<span class="number">4</span>d0656e87820]           =&gt; <span class="built_in">Future</span></span><br><span class="line">  Requires [ae029012-a4dd-<span class="number">5104</span>-<span class="number">9</span>daa-d747884805df]         =&gt; Requires</span><br><span class="line">  RecipesBase [<span class="number">3</span>cdcf5f2-<span class="number">1</span>ef4-<span class="number">517</span>c-<span class="number">9805</span>-<span class="number">6587</span>b60abb01]      =&gt; RecipesBase</span><br><span class="line">  InteractiveUtils [b77e0a4c-d291-<span class="number">57</span>a0-<span class="number">90e8</span>-<span class="number">8</span>db25a27a240] =&gt; InteractiveUtils</span><br><span class="line">  Pkg [<span class="number">44</span>cfe95a-<span class="number">1</span>eb2-<span class="number">52</span>ea-b672-e2afdf69b78f]              =&gt; Pkg</span><br><span class="line">  Printf [de0858da-<span class="number">6303</span>-<span class="number">5e67</span>-<span class="number">8744</span>-<span class="number">51</span>eddeeeb8d7]           =&gt; Printf</span><br><span class="line">  Base64 [<span class="number">2</span>a0f44e3-<span class="number">6</span>c83-<span class="number">55</span>bd-<span class="number">87e4</span>-b1978d98bd5f]           =&gt; Base64</span><br><span class="line">  Test [<span class="number">8</span>dfed614-e22c-<span class="number">5e08</span>-<span class="number">85e1</span>-<span class="number">65</span>c5234f0b40]             =&gt; Test</span><br><span class="line">  Reexport [<span class="number">189</span>a3867-<span class="number">3050</span>-<span class="number">52</span>da-a836-e630ba90ab69]         =&gt; Reexport</span><br><span class="line">  Dates [ade2ca70-<span class="number">3891</span>-<span class="number">5945</span>-<span class="number">98</span>fb-dc099432e06a]            =&gt; Dates</span><br><span class="line">  DelimitedFiles [<span class="number">8</span>bb1440f-<span class="number">4735</span>-<span class="number">579</span>b-a4ab-<span class="number">409</span>b98df4dab]   =&gt; DelimitedFiles</span><br><span class="line">  LAME_jll [c1c5ebd0-<span class="number">6772</span>-<span class="number">5130</span>-a774-d5fcae4a789d]         =&gt; LAME_jll</span><br><span class="line">  Missings [e1d29d7a-bbdc-<span class="number">5</span>cf2-<span class="number">9</span>ac0-f12de2c33e28]         =&gt; Missings</span><br><span class="line">  __PackagePrecompilationStatementModule [top-level]      =&gt; __PackagePrecompilationStatementModule</span><br><span class="line">  Opus_jll [<span class="number">91</span>d4177d-<span class="number">7536</span>-<span class="number">5919</span>-b921-<span class="number">800302f37372</span>]         =&gt; Opus_jll</span><br><span class="line">  StatsBase [<span class="number">2913</span>bbd2-ae8a-<span class="number">5f71</span>-<span class="number">8</span>c99-<span class="number">4</span>fb6c76f3a91]        =&gt; StatsBase</span><br><span class="line">  libfdk_aac_jll [f638f0a6-<span class="number">7</span>fb0-<span class="number">5443</span>-<span class="number">88</span>ba-<span class="number">1</span>cc74229b280]   =&gt; libfdk_aac_jll</span><br><span class="line">  libvorbis_jll [f27f6e37-<span class="number">5</span>d2b-<span class="number">51</span>aa-<span class="number">960</span>f-b287f2bc3b7a]    =&gt; libvorbis_jll</span><br><span class="line">  REPL [<span class="number">3</span>fa0cd96-eef1-<span class="number">5676</span>-<span class="number">8</span>a61-b3b8758bbffb]             =&gt; REPL</span><br><span class="line">  x265_jll [dfaa095f-<span class="number">4041</span>-<span class="number">5</span>dcd-<span class="number">9319</span>-<span class="number">2</span>fabd8486b76]         =&gt; x265_jll</span><br><span class="line">  LibGit2 [<span class="number">76f85450</span>-<span class="number">5226</span>-<span class="number">5</span>b5a-<span class="number">8</span>eaa-<span class="number">529</span>ad045b433]          =&gt; LibGit2</span><br><span class="line">  Distributed [<span class="number">8</span>ba89e20-<span class="number">285</span>c-<span class="number">5</span>b6f-<span class="number">9357</span>-<span class="number">94700520</span>ee1b]      =&gt; Distributed</span><br><span class="line">  Plots [<span class="number">91</span>a5bcdd-<span class="number">55</span>d7-<span class="number">5</span>caf-<span class="number">9e0</span>b-<span class="number">520</span>d859cae80]            =&gt; Plots</span><br><span class="line">  LinearAlgebra [<span class="number">37e2</span>e46d-f89d-<span class="number">539</span>d-b4ee-<span class="number">838</span>fcccc9c8e]    =&gt; LinearAlgebra</span><br><span class="line">  ⋮                                                       =&gt; ⋮</span><br><span class="line"></span><br><span class="line">julia&gt; Plots.plot</span><br><span class="line">plot (generic <span class="keyword">function</span> with <span class="number">3</span> methods)</span><br></pre></td></tr></table></figure><h2 id="編譯到預設位置">編譯到預設位置</h2><p>Julia 在系統中有 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它預設會在 Julia 啟動時載入，我們可以利用預先編譯好的函式庫來取代它，就可以不用參數的情況下自動載入。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_sysimage([:Debugger, :OhMyREPL]; replace_default=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>將 <code>sysimage_path</code> 換成 <code>replace_default=true</code>，來將編譯的函式庫取代 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a>，它會將原本的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 備份到 sys.so.backup，並將編譯好的 <a href="http://sys.so" target="_blank" rel="noopener">sys.so</a> 寫入。</p><h2 id="增量編譯（incremental-compilation）">增量編譯（incremental compilation）</h2><p>sysimage 可以進行增量編譯。增量編譯是指既有的函式並不會重新編譯，只會編譯那些新加入的函式。如果已經有 sysimage，那麼下次呼叫 <code>create_sysimage</code> 時，只會編譯新加入的部份，並且用新的函式庫檔案取代舊的。</p><p>如果你想要關閉這個功能，那需要加入 <code>incremental=false</code> 來關閉增量編譯，這樣就會編譯一個全新的函式庫。</p><p>Ref: <a href="https://julialang.github.io/PackageCompiler.jl/dev/sysimages/" target="_blank" rel="noopener">https://julialang.github.io/PackageCompiler.jl/dev/sysimages/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia 有優異的效能，但是它的 JIT 讓套件的載入時間（&lt;code&gt;using&lt;/code&gt;）過於冗長。&lt;/p&gt;
&lt;p&gt;Julia JIT 會在套件載入時期以及第一次使用函式時期進行編譯，若是有編譯完成的版本，便可以直接使用，避免編譯時間。儘管 Julia 將程式碼進行編譯，得到了絕佳的執行時間，但是套件載入的第一次編譯時間成為了大家的痛點。&lt;/p&gt;
&lt;p&gt;為了解決這樣的痛點，開發者社群做了不少努力，主要是 PackageCompiler.jl 套件，讓套件可以預先進行編譯，而後來也補充了不少 binary package 來支援套件編譯。&lt;/p&gt;
&lt;p&gt;PackageCompiler.jl 套件可以將 Julia 程式碼編譯成可執行檔以及動態函式庫（.so），支援套件編譯成動態函式庫，以及增量編譯（incremental compilation）。&lt;/p&gt;
&lt;p&gt;近期 PackageCompiler.jl 套件正式發佈 v1.0，正式成熟可以使用了！本文將會介紹如何將套件編譯成動態函式庫，並且在啟動時載入，來避免過長的載入及編譯時間。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Julia 的多重分派</title>
    <link href="https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/"/>
    <id>https://yuehhua.github.io/2020/04/01/julia-multiple-dispatch/</id>
    <published>2020-04-01T15:27:42.000Z</published>
    <updated>2020-04-01T15:27:42.500Z</updated>
    
    <content type="html"><![CDATA[<p>今天來談談 Julia 的多重分派（multiple dispatch）。</p><p>很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。</p><p>在現今的物件導向程式設計當中，我們會將函式歸納到某個類別底下成為其類別的方法，而這個方法就屬於這個類別。</p><h2 id="多重分派-v-s-單一分派">多重分派 v.s. 單一分派</h2><p>這樣的觀點就是單一分派的精神，單一分派是指一個方法的呼叫，要如何決定呼叫的是哪一個方法實作呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int(x)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure><p>像以上的 python 程式碼，<code>foo.abc(x)</code> 就是去呼叫 <code>Foo</code> 的方法，而 <code>bar.abc(x)</code> 則是去呼叫 <code>Bar</code> 的方法。</p><p>也就是說，方法的呼叫是由第一個參數所決定的，這邊要注意的是第一個參數並不是 <code>x</code>，而是 <code>self</code> 喔！也就是物件本身！</p><p>相對於單一分派，多重分派是指他會參考所有的參數型別及其組合來決定到底要呼叫哪一個方法。</p><p>所以我們也有了更細緻的選擇。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(foo::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(foo::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(bar::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><p>當第一個參數型別是 <code>Foo</code> 時，就回傳字串，而當第一個參數型別是 <code>Bar</code> 時，就回傳整數。</p><p>我們可以去區別，當 <code>x</code> 已經是整數或是字串時就不用去處理它，直接回傳即可。若是有不同型別時，個別處理。</p><p>這邊我們並沒有使用到第一個型別的參數，在 Julia 裡可以省略變數本身，只寫型別。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc(::Foo, x::<span class="built_in">String</span>) = x</span><br><span class="line">abc(::Foo, x::<span class="built_in">Int64</span>) = <span class="built_in">String</span>(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">String</span>) = Meta.parse(x)</span><br><span class="line">abc(::Bar, x::<span class="built_in">Int64</span>) = x</span><br></pre></td></tr></table></figure><h2 id="多重分派的自由與限制">多重分派的自由與限制</h2><p>使用多重分派可以讓語言有更細緻的定義，也有更高的自由度。</p><p>我們可以看看以下的例子，這邊使用了常常被使用的 null pattern：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push!(ls::List, obj::NullObject) = ls</span><br><span class="line"></span><br><span class="line">psuh!(ls::List, obj::Object) = push!(ls.array, obj)</span><br></pre></td></tr></table></figure><p>當我要去表示一類物件，我們會實作 <code>Object</code>，但往往我們會想要表示一個為空的物件，這時候我們就會有一個 <code>NullObject</code> 來表達這件事。</p><p>當我們想要將一個 <code>Object</code> 放到 <code>List</code> 中的時候，我們會實作 <code>push!</code>，然而當一個 <code>NullObject</code> 被放入 <code>List</code> 的時候，我們並不需要真的做什麼樣的動作。實作就會如同上面的程式碼。</p><p>相對在 python 或是一般物件導向語言當中，我們就會看到以下的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> type(obj) == NullObject:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">elif</span> type(obj) == Object:</span><br><span class="line">            self.array.append(obj)</span><br></pre></td></tr></table></figure><p>我們需要自己去判斷接收進來的參數型別，然後進一步做處理。這樣的話會讓我們的程式碼充滿 if-else，當條件一多時，會變得相當難以閱讀及修改。</p><p>使用多重分派並不是只有優點，他也有缺點。多重分派會引入模糊性（ambiguity）。</p><p>考慮以下程式碼：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b) = a</span><br><span class="line">foo(a, b::B) = b</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = B()</span><br></pre></td></tr></table></figure><p>請問 <code>foo(a, b)</code> 該呼叫哪一個方法呢？</p><p>這樣的呼叫在 Julia 會產生錯誤，也就是編譯器不知道該呼叫哪一個方法。</p><p>這時候編譯器會建議修改的方式，就是定義一個更明確的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(a::A, b::B)</span><br></pre></td></tr></table></figure><h2 id="應用情境">應用情境</h2><p>我們來寫個簡單的剪刀石頭布遊戲！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Paper <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Scissor <span class="keyword">end</span></span><br><span class="line"><span class="keyword">struct</span> Stone <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我們分別有三個型別分別代表剪刀石頭布。</p><p>接下來我們定義運算，先定義贏的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">play(::Paper, ::Stone) = <span class="number">1</span></span><br><span class="line">play(::Scissor, ::Paper) = <span class="number">1</span></span><br><span class="line">play(::Stone, ::Scissor) = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>當雙方是相同時就平手：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(::T, ::T) <span class="keyword">where</span> &#123;T&#125; = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>這邊我們利用了 Julia 的參數化方法，當兩個有相同的型別時，就回傳 0。</p><p>最後，是輸的狀況：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">play(a, b) = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>也就是，如果沒有符合以上的狀況的方法呼叫，就會落到這個狀況來，所以這邊我們允許最廣義的 <code>Any</code> 型別。</p><p>希望大家可以經由這個簡單的例子來理解 Julia 的多重分派有多好用，甚至是搭配上參數化方法根本是逆天阿！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天來談談 Julia 的多重分派（multiple dispatch）。&lt;/p&gt;
&lt;p&gt;很顯然地，多重分派有別於單一分派（single dispatch），而單一分派是在現今主流的物件導向程式設計中常見的方式。&lt;/p&gt;
&lt;p&gt;在現今的物件導向程式設計當中，我們會將函式歸納
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>julia v1.4 釋出</title>
    <link href="https://yuehhua.github.io/2020/03/24/julia-v1-4-release/"/>
    <id>https://yuehhua.github.io/2020/03/24/julia-v1-4-release/</id>
    <published>2020-03-24T04:02:05.000Z</published>
    <updated>2020-03-24T04:02:05.904Z</updated>
    
    <content type="html"><![CDATA[<p>Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。<br>底下新功能後面會有括弧，附註相關的實作程式碼。</p><a id="more"></a><h2 id="重要功能">重要功能</h2><h3 id="使用者功能">使用者功能</h3><ul><li><code>import</code> 允許符號，例如 <code>import Base.:+</code>。(#33158)</li><li>允許使用 <code>a[begin]</code> 來存取 <code>a</code> 的首位元素。首位元素的索引是由 <code>firstindex(a)</code> 計算得出。(#33946)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; x[<span class="keyword">begin</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>值可以藉由 <code>$</code> 內插到 <code>@async</code> 及 <code>@spawn</code> 中，它會將值直接複製一份到閉包（closure）中。(#33119)</li></ul><h3 id="開發者功能">開發者功能</h3><ul><li>結構 <code>struct</code> 當中，所有位元（isbits）或是位元聯集（isbitsunion）的欄位（fields）都會儲存為陣列的元素。(#32448)</li></ul><p>以前在 Julia 的結構當中，只有所有欄位都有相同的型別，而且型別都是原始型別時，Julia 底層會將他們封裝到一個陣列中，如此可以加速。在 v1.4 版後放寬了這樣的限制，讓有所有位元欄位都儲存為陣列。</p><h2 id="新功能">新功能</h2><ul><li>Iterators 模組中有 <code>accumulate</code> 實作。(#34033)</li></ul><p>Jeff 頗驚訝，之前怎麼沒有這個功能XD</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>-element <span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;:</span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; iter = Iterators.accumulate(+, x)</span><br><span class="line">Base.Iterators.Accumulate&#123;typeof(+),<span class="built_in">Array</span>&#123;<span class="built_in">Int64</span>,<span class="number">1</span>&#125;&#125;(+, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; foreach(println, iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>功能與 <code>Base.accumulate</code> 雷同，但是屬於 lazy evaluation。</p><ul><li><code>evalpoly</code> 可以用來計算多項式函數，例如 <code>evalpoly(x, (p1, p2, p3))</code>。(#32753)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; evalpoly(<span class="number">5</span>, (<span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>相當於計算 $p(5) = 10 + 3\times5 + 1\times5^2$。</p><ul><li>允許複合函數（function composition）<code>∘(f, g, h) = f ∘ g ∘ h</code>，以及解開 <code>∘(fs...)</code>，當中 <code>fs</code> 可以是 Iterable 的函數集合。(#33568)</li></ul><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; f(x) = x + <span class="number">1</span></span><br><span class="line">f (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; g(x) = <span class="number">2</span>x</span><br><span class="line">g (generic <span class="keyword">function</span> with <span class="number">1</span> method)</span><br><span class="line"></span><br><span class="line">julia&gt; F = f∘g</span><br><span class="line"><span class="comment">#64 (generic function with 1 method)</span></span><br><span class="line"></span><br><span class="line">julia&gt; F(<span class="number">5</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="新支援">新支援</h2><ul><li><code>gcd</code>、<code>lcm</code> 及 <code>gcdx</code> 支援 <code>Rational</code> 型別的參數。(#33910)</li><li><code>splitpath</code> 支援任何 <code>AbstractString</code> 型別，然而以前只支援 <code>String</code> 的路徑。(#33012)</li><li><code>filter</code> 可以作用在 <code>Tuple</code> 上。(#32968)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Julia v1.4 已經釋出啦！這邊來跟大家介紹一些新功能。&lt;br&gt;
底下新功能後面會有括弧，附註相關的實作程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>從 iterator 及 generator 到 iterable</title>
    <link href="https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/"/>
    <id>https://yuehhua.github.io/2020/03/01/from-iterator-and-generator-to-iterable/</id>
    <published>2020-03-01T06:31:49.000Z</published>
    <updated>2020-03-05T16:32:51.101Z</updated>
    
    <content type="html"><![CDATA[<p>今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 <code>in</code> 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？</p><a id="more"></a><p>很基本的作法是去實作一個設計模式（design pattern）中的 iterator，假設我們要迭代一個陣列裡的元素，iterator 有別於陣列本身，是另外一個物件。Iterator 可以提供你一個介面，例如 <code>next()</code>，讓你可以取得陣列裡的下一個元素。</p><p>像這樣的方式很常見也很簡單可以實作，在 Julia 裡就像這樣：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable struct</span> ArrayIterator</span><br><span class="line">    array::<span class="built_in">Array</span></span><br><span class="line">    index::<span class="built_in">Int64</span></span><br><span class="line"></span><br><span class="line">    ArrayIterator(array::<span class="built_in">Array</span>) = new(array, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">has_next(iter::ArrayIterator) = (iter.index &lt; length(iter.array))</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> next(iter::ArrayIterator)</span><br><span class="line">    x = iter.array[iter.index]</span><br><span class="line">    iter.index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">2</span>:<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; iter = ArrayIterator(v);</span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">julia&gt; next(iter)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">julia&gt; has_next(iter)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>各位可以看到 iterator 一般都會實作 <code>has_next()</code> 及 <code>next()</code> 函式，是用來確認是否有下一個元素存在及取得下一個元素。Iterator 中會包含陣列本身，也就是想要迭代的集合本身，還有一個 <code>index</code> 會指向目前的元素，並在取得元素之後移往下一個。</p><p>Iterator 是一個物件，它需要一個已經存在的集合來作為它迭代的集合。這代表這個集合必須事先存在，如果這個集合很大，那就會佔去不少記憶體空間。有沒有什麼方法可以不需要集合就可以迭代的呢？Generator 是一個方式。</p><p>Generator，顧名思義，它會在你取得下一個元素的時候產生出來，並不會事先計算，所以集合也不會存在。Julia 的 generator 很好撰寫，如下：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (i^<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>這就是一個會產生 1 到 10 數字的 generator。Generator 也可以被放到 for 迴圈裡被迭代，但唯一不同的是，它並不佔記憶體空間，只需要即時的計算即可。</p><p>Julia 目前提供的方式稱為 Iterable，只要有實作 <code>iterate()</code> 這個 API 的就稱為 Iterable。像以下例子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Character</span><br><span class="line">    start::<span class="built_in">Char</span></span><br><span class="line">    length::<span class="built_in">Int</span></span><br><span class="line">    Character() = new(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(char::Character, (el, i)=(char.start, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> i &lt; char.length</span><br><span class="line">        <span class="keyword">return</span> (el, (el+<span class="number">1</span>, i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.length(char::Character) = char.length</span><br><span class="line">Base.eltype(::Character) = <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p><code>iterate()</code> 的輸入是「狀態」，輸出是下一個狀態，而狀態包含兩個物件：要迭代的元素以及順序。因此，會看起來像是這個樣子：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(el1, (el2, i+<span class="number">1</span>)) = iterate(iter, (el1, i))</span><br></pre></td></tr></table></figure><p>特別要說明的是，在輸出的狀態中，需要帶有目前元素的資訊 <code>(el1, (el2, i+1))</code>。如果要結束迴圈，那就回傳 <code>nothing</code>。我們就可以來世試看這個可以迭代輸出 ASCII 碼的 Iterable。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; c = Character()</span><br><span class="line">Character(<span class="string">'A'</span>, <span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; iterate(c, (<span class="string">'B'</span>, <span class="number">1</span>))</span><br><span class="line">(<span class="string">'C'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> c</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br><span class="line">F</span><br><span class="line">G</span><br><span class="line">H</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣可以有 generator 的好處，而且本身也是一個 iterator。它不需要是一個物件，只要有實作 <code>iterate()</code> 這個 API 的物件就可以使用，所以我們還可以拿來這樣用。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> IterableNumber</span><br><span class="line">    start::<span class="built_in">Int</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Base.iterate(iter::IterableNumber, (el, i)=(iter.start, <span class="number">0</span>)) = i &lt; <span class="literal">Inf</span> ? (el, (el+<span class="number">1</span>, i+<span class="number">1</span>)) : <span class="literal">nothing</span></span><br></pre></td></tr></table></figure><p>這是一個可以自定義起點的可迭代數字，數字可以持續到無限大。你得手動把它停下來！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; iter = IterableNumber(<span class="number">0</span>)</span><br><span class="line">IterableNumber(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> i <span class="keyword">in</span> iter</span><br><span class="line">           println(i)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或是你想做個 sliding window：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> SlidingWindow</span><br><span class="line">    vec::<span class="built_in">Vector</span></span><br><span class="line">    n::<span class="built_in">Int</span></span><br><span class="line">    start::<span class="built_in">SubArray</span></span><br><span class="line"></span><br><span class="line">    SlidingWindow(vec::<span class="built_in">Vector</span>, n) = new(vec, n, view(vec, <span class="number">1</span>:n))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Base.iterate(iter::SlidingWindow, (el, i)=(iter.start, <span class="number">1</span>))</span><br><span class="line">    <span class="literal">e</span> = i + iter.n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">e</span> &lt;= length(iter.vec)</span><br><span class="line">        <span class="keyword">return</span> (el, (view(iter.vec, i:<span class="literal">e</span>), i+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這邊用 <code>view(iter.vec, i:e)</code> 做取值的方式，比起用 <code>iter.vec[i:e]</code> 取值來的快很多。<code>iter.vec[i:e]</code> 這種方式會造出一個新的陣列，而 view 不會。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">julia&gt; v = collect(<span class="number">1</span>:<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">julia&gt; sw = SlidingWindow(v, <span class="number">5</span>)</span><br><span class="line">SlidingWindow([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>  …  <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>], <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">julia&gt; <span class="keyword">for</span> x <span class="keyword">in</span> sw</span><br><span class="line">           println(x)</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這邊介紹了三種迭代的方法，而 iterable 則是目前由 Julia 官方支援的主流方式。除了可以迭代數字以外還可以有其他用途，甚至可以迭代直到無限大的數字。Sliding window 這樣的東西在計算上或是深度學習上是很實用的結構！是不是覺得 Julia 越來越像 functional language 了XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天來跟大家介紹 iterator、generator 及 iterable 這三個東西。基本上，大家應該都有用過 for 迴圈，然而很多東西可以放在迴圈的 &lt;code&gt;in&lt;/code&gt; 後方，這樣就可以將裡頭的元素一個一個取出來。但是這是怎做到的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>One-way ANOVA and sum of squares</title>
    <link href="https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/"/>
    <id>https://yuehhua.github.io/2020/02/10/one-way-anova-and-sum-of-squares/</id>
    <published>2020-02-09T16:01:59.000Z</published>
    <updated>2020-03-09T17:07:49.402Z</updated>
    
    <content type="html"><![CDATA[<p><strong>An</strong>alysis <strong>o</strong>f <strong>va</strong>riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms <strong>explained variance</strong> (or <strong>between-group variance</strong> in categorical factor) and <strong>unexplained variance</strong> (or <strong>within-group variance</strong> in categorical factor).</p><a id="more"></a><h2 id="Sum-of-squares">Sum of squares</h2><p>Sum of squares come from the concept of calculating the (squared Euclidean) distance among data. Let’s consider the total sum of squares $SS_{total}$.</p><p>$$<br>SS_{total} = \sum_i (y_i - \bar{y})^2<br>$$</p><p>$y_i$ represents the true data value, $\bar{y}$ represents the mean of data $y_i$. We can get variance from $SS_{total}$ by dividing the <strong>degree of freedom</strong> ($df$).</p><p>$$<br>\begin{align}<br>Var[Y] &amp;= \frac{SS_{total}}{df} \\<br>&amp;= \frac{1}{n-1} \sum_i (y_i - \bar{y})^2<br>\end{align}<br>$$</p><p>The equation above shows the relation between sum of square and variance.</p><p>We always attempt to model the phonomena from data. Constructing the hypothesis or model and validate our hypothesis by testing their siginificant. If our model is true, then model must catch some variance and extract information from data for us. If the model is not true, model catch less variance just as the noise does.</p><p>So, we defined two kinds of sum of squares to measure how much variance is caught by model or not. We usually use a regression to model our data, so we have regression sum of square $SS_{reg}$, which represents the amount of sum of square explained by model. Sum of square other than regression sum of square is left as residual sum of square $SS_{res}$, which represents the amount of sum of square unexplained by model.</p><p>$$<br>SS_{reg} = \sum_i (\hat{y}_i - \bar{y})^2<br>$$</p><p>$\hat{y}_i$ represents the prediction value given by the model. If the sum of square is modeled, then the distance between the mean and the model prediction is explained by model.</p><p>$$<br>SS_{res} = \sum_i (y_i - \hat{y}_i)^2<br>$$</p><p>If the sum of square is not modeled, then the distance between the data and the model prediction is left unexplained as noise.</p><p>There is a relationship amoung them. We are going to proof it. However, the tools are not enough to prove it. We need the following two equations:</p><p>$$<br>\sum_i e_i = \sum_i (y_i - \hat{y}_i) = 0<br>$$</p><p>$$<br>\sum_i \hat{y}_i e_i = 0<br>$$</p><p>We start from $SS_{total}$.</p><p>$$<br>\begin{align}<br>SS_{total} &amp;= \sum_i (y_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i + \hat{y}_i - \bar{y})^2 \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + (\hat{y}_i - \bar{y})^2 + 2(y_i - \hat{y}_i)(\hat{y}_i - \bar{y}) \\<br>&amp;= \sum_i (y_i - \hat{y}_i)^2 + \sum_i (\hat{y}_i - \bar{y})^2 + 2 \sum_i \hat{y}_i(y_i - \hat{y}_i) - 2\bar{y} \sum_i (y_i - \hat{y}_i) \\<br>\end{align}<br>$$</p><p>Now you may see $SS_{reg}$ and $SS_{res}$ in the formula.</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res} + 2 \sum_i \hat{y}_i e_i - 2\bar{y} \sum_i e_i<br>$$</p><p>Due to the fact that the last two summation terms are zero. So we have:</p><p>$$<br>SS_{total} = SS_{reg} + SS_{res}<br>$$</p><p>So now we have it! If we face a dataset, assuming that we know nothing about the data, we could only measure the mean and variance about the data.</p><p>Mean tells us the “location” about the data. If I told you the average height of whole people in the class, you prabably could have a idea or even guess <em>where data locate</em>.</p><p>Variance tell us the “range”, or formally “dispersion”, about the dataset. If the variance is large, we have high uncertainty about the data. Sometimes, we even know the mean, we still cannot guess the answer accurately, because we have no idea about <em>what is the scale of data</em>. In some sense, variance is associated with sum of squares(, and it truely is).</p><p>If we know the model in advance, we know the inner structure of phenomena and how the data is generated. That’s why we usually want to model things. If we introduce a model, it can help us extracting the inner structure (or information) from uncertainty. It reduce the uncertainty and give us information.</p><p>The total sum of squares act as the total uncertainty we face, and it can further be decoupled into two parts. If we have a model to help us, model extracts information and represents as regression sum of squares. The rest of uncertainty remains as <strong>residuals</strong>.</p><h2 id="One-way-ANOVA">One-way ANOVA</h2><p>ANOVA is a way to decouple sum of squares so that we can quantify how well the model is.</p><p>We can further make the ANOVA table as follow:</p><p>$$<br>\begin{array}{l c c c}<br>\ &amp; SS &amp; df &amp; MS &amp; F \\<br>\hline<br>model &amp; SS_{reg} &amp; k-1 &amp; MS_{reg} &amp; \frac{MS_{reg}}{MS_{res}} \\<br>error &amp; SS_{res} &amp; n-k &amp; MS_{res} &amp; \\<br>\hline<br>total &amp; SS_{total} &amp; n-1 &amp; MS_{total} &amp; \\<br>\end{array}<br>$$</p><p>Fill in the corresponding cell. Degree of freedom is about how many parameters you used to estimate your model. However, it is not always the case, you may want to read statistics textbook for some theoretical reasons. $k$ is the random variables you used in your model.</p><p>$$<br>MS_{reg} = \frac{SS_{reg}}{k-1} \\<br>MS_{res} = \frac{SS_{res}}{n-k}<br>$$</p><p>$MS$ means <em>mean of squares</em>, which it $SS$ divided by $df$. Moreover, we can calculate the F statistics for F test and the F test itself is so called <strong>one-way ANOVA</strong>.</p><p>$$<br>F = \frac{\text{explained variance}}{\text{unexplained variance}}<br>$$</p><p>F-value has its own meaning. It measures <em>how much variance is caught by our model</em> (or $MS_{reg}$), and it is a relative measurement, so it is divided by <em>the variance not caught by our model</em> (or $MS_{res}$). In aonother way, the model can <strong>explained</strong> part of variance, and the rest is left <strong>unexplained</strong>.</p><p>If the model we used is not something like linear regression, rather, we separate data into different categories. We used the following formula:</p><p>$$<br>F = \frac{\text{between-group variance}}{\text{within-group variance}}<br>$$</p><p>We could further test if the F-value is significant or not.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;An&lt;/strong&gt;alysis &lt;strong&gt;o&lt;/strong&gt;f &lt;strong&gt;va&lt;/strong&gt;riance (ANOVA) starts from the analysis of variance which is caught by the model or not. If the variance is modeled, then the variance must be explained by the model, I mean of which is “caught” by the model. If it is not, variance is left unexplained as noises. These two concepts forms &lt;strong&gt;explained variance&lt;/strong&gt; (or &lt;strong&gt;between-group variance&lt;/strong&gt; in categorical factor) and &lt;strong&gt;unexplained variance&lt;/strong&gt; (or &lt;strong&gt;within-group variance&lt;/strong&gt; in categorical factor).&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>Relationship between variance and pairwise distance</title>
    <link href="https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/"/>
    <id>https://yuehhua.github.io/2020/02/09/relationship-between-variance-and-pairwise-distance/</id>
    <published>2020-02-09T14:28:52.000Z</published>
    <updated>2020-03-06T07:55:43.094Z</updated>
    
    <content type="html"><![CDATA[<p>Random variable $X$, we have the variance</p><p>$$<br>\begin{align}<br>Var[X] &amp;= \mathbb{E}[(X - \mu)^2] \\<br>&amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2<br>\end{align}<br>$$</p><a id="more"></a><p>Pairwise (squared Euclidean) distance will be<br>Andrew Gerrand<br>$$<br>\begin{align}<br>\sum_{i \ne j} d(x_i, x_j) &amp;= \sum_{i=1}^n \sum_{j=i+1}^n (x_i - x_j)^2 \\<br>&amp;= \sum_{i=1}^n \sum_{j=i+1}^n ((x_i - \mu) - (x_j - \mu))^2 \\<br>&amp;= n \sum_{i=1}^n (x_i - \mu)^2 \\<br>&amp;= n^2 \mathbb{E}[(X - \mu)^2] \\<br>&amp;= n^2 Var[X]<br>\end{align}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Random variable $X$, we have the variance&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;
\begin{align}&lt;br&gt;
Var[X] &amp;amp;= \mathbb{E}[(X - \mu)^2] \\&lt;br&gt;
&amp;amp;= \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2&lt;br&gt;
\end{align}&lt;br&gt;
$$&lt;/p&gt;
    
    </summary>
    
    
      <category term="Statistics" scheme="https://yuehhua.github.io/categories/Statistics/"/>
    
    
  </entry>
  
  <entry>
    <title>程式設計師勝任程度</title>
    <link href="https://yuehhua.github.io/2019/12/11/programmer-competency/"/>
    <id>https://yuehhua.github.io/2019/12/11/programmer-competency/</id>
    <published>2019-12-11T07:08:58.000Z</published>
    <updated>2019-12-11T07:08:58.297Z</updated>
    
    <content type="html"><![CDATA[<p>先前看到了 <a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="noopener">Programmer Competency Matrix</a>，所以就自己幫自己評比一下。</p><ul><li>Computer Science<ul><li>data structures: level 3</li><li>algorithms: level 3</li><li>systems programming: level 2</li></ul></li><li>Software Engineering<ul><li>source code version control: level 3</li><li>build automation: level 2</li><li>automated testing: level 2</li></ul></li><li>Programming<ul><li>problem decomposition: level 3</li><li>systems decomposition: level 2</li><li>communication: level 3</li><li>code organization within a file: level 2</li><li>code organization across files: level 2</li><li>source tree organization: level 3</li><li>code readability: level 3</li><li>defensive coding: level 2</li><li>error handling: level 1</li><li>IDE: level 2</li><li>API: level 1</li><li>frameworks: level 3</li><li>requirements: level 2</li><li>scripting: level 2</li><li>database: level 2</li></ul></li><li>Experience<ul><li>languages with professional experience: level 1~2 (familiar with OO language with functional patterns)</li><li>platforms with professional experience: level 2</li><li>years of professional experience: level 2</li><li>domain knowledge: level 2</li></ul></li><li>Knowledge<ul><li>tool knowledge: level 2</li><li>languages exposed to: level 2~3 (used Prolog before)</li><li>codebase knowledge: level 3 (I started a project before)</li><li>knowledge of upcoming technologies: level 2</li><li>platform internals: level 1~2 (not sure)</li><li>books: level 2 (actually used and read books)</li><li>blogs: level 3 (but not regularly update blog posts)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先前看到了 &lt;a href=&quot;http://sijinjoseph.com/programmer-competency-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programmer Competency Matrix&lt;/a&gt;，所以就自
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Name binding 與 dispatch</title>
    <link href="https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/"/>
    <id>https://yuehhua.github.io/2019/12/01/name-binding-and-dispatch/</id>
    <published>2019-12-01T02:49:40.000Z</published>
    <updated>2019-12-01T02:49:40.195Z</updated>
    
    <content type="html"><![CDATA[<p>Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。</p><p>Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。</p><a id="more"></a><p>一般而言，當物件被去除綁定，那物件將會被垃圾回收（garbage collection）機制給處理掉。</p><p>Name binding 依據時間分為：</p><ul><li>Static binding (or early binding)：在編譯時期（compile time）進行綁定</li><li>Dynamic binding (or late binding)：在執行時期（runtime）進行綁定</li></ul><p>Static binding 的一個經典例子是 C 的函式呼叫，它在編譯時期就將函式內容綁定到識別符上，而無法在執行時期變更。</p><p>Dynamic binding 的一個相對應的例子則是 C++ 的虛擬方法呼叫，由於多型的機制，物件的型別無法在編譯時期得知，所以綁定會在執行時期處理。</p><p>在執行時期，如果識別符變更參考到其他的物件，我們稱為重新綁定（rebinding）。如果是變更識別符指向的物件本身，那麼我們稱為突變（mutation）。</p><p>在這邊提到多型的機制，就不得不去提 dispatch 的機制。一般在物件導向語言中以 dynamic dispatch 為主，表示在多型機制下，方法的選定是由第一個參數的型別來決定。</p><p>Dispatch 是個選擇的問題，而 binding 是個綁定的問題。選擇一定要發生在綁定後。</p><p>Dynamic dispatch 可以是 static binding 也可以是 dynamic binding，但是 dynamic binding 就只能在執行時間做 dispatch 了。</p><p>Dynamic dispatch 一般指 single dispatch，也就是由第一個參數的型別來決定要呼叫哪一個方法。相對也有 multiple dispatch，就會利用所有的參數型的排列組合來決定要呼叫哪一個方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Name binding 是一個將資料或是程式碼綁定（binding）到識別符（identifiers）的一個過程。一個識別符綁定到一個物件代表這個識別符會參考（reference）某個物件。&lt;/p&gt;
&lt;p&gt;Name binding 在程式語言中式相當重要而複雜的一個議題，而它牽涉到作用域（scope）的問題，物件存在於程式碼的位置（語意）及物件的生命周期（時間）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Compiler" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Compiler/"/>
    
    
  </entry>
  
  <entry>
    <title>魔術數字</title>
    <link href="https://yuehhua.github.io/2019/09/06/magic-numbers/"/>
    <id>https://yuehhua.github.io/2019/09/06/magic-numbers/</id>
    <published>2019-09-06T06:35:26.000Z</published>
    <updated>2019-09-06T06:35:26.760Z</updated>
    
    <content type="html"><![CDATA[<p>很多人在寫程式的時候會有些壞習慣，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X &#x3D; rand(3, 4)</span><br><span class="line">for i &#x3D; 1:3</span><br><span class="line">    for j &#x3D; 1:4</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可能多數人看以上這段程式碼並沒有什麼特別的感覺，但是如果要維護的時候就會發現你突然不太理解這段程式碼。</p><p>有人知道這邊的 <code>3</code> 是什麼意思嗎？嗯…或許可以從上下文猜出來是陣列的列數的意思。</p><p>一旦要更改陣列的大小的時候勢必就要更改這些數字，甚至這些數字散落在程式碼的各個角落就會更加頭痛。</p><p>這些數字稱為魔術數字（magic numbers），因為沒有人知道他的意義是什麼！</p><h2 id="解法一：使用常數">解法一：使用常數</h2><p>如果這些數字很常被使用到，而且不會在程式中被變更，請使用常數，像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ROWS &#x3D; 3</span><br><span class="line">const COLUMNS &#x3D; 4</span><br><span class="line">X &#x3D; rand(ROWS, COLUMNS)</span><br><span class="line">for i &#x3D; 1:ROW</span><br><span class="line">    for j &#x3D; 1:COLUMNS</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如此，以後要更改陣列大小只需要更改常數即可，也讓程式碼的可讀性上升。</p><p>如果你的程式會更改到這些數字，那麼就用變數。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rows &#x3D; 3</span><br><span class="line">columns &#x3D; 4</span><br><span class="line">X &#x3D; rand(rows, columns)</span><br><span class="line">for i &#x3D; 1:rows</span><br><span class="line">    for j &#x3D; 1:columns</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="解法二：動態">解法二：動態</h2><p>如果陣列的大小不是事先知道的，或是需要動態取得，那麼可以用 <code>size</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1:size(X, 1)</span><br><span class="line">    for j &#x3D; 1:size(X, 2)</span><br><span class="line">        X[i, j]</span><br><span class="line">        ...</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如此可以用在未知大小的陣列上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多人在寫程式的時候會有些壞習慣，如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 的 inbounds</title>
    <link href="https://yuehhua.github.io/2019/09/06/inbounds-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inbounds-in-julia/</id>
    <published>2019-09-06T03:17:13.000Z</published>
    <updated>2019-09-06T03:17:13.549Z</updated>
    
    <content type="html"><![CDATA[<p>有在做套件開發的開發者們應該不陌生 <code>@inbounds</code> 這個 macro，在很多現代程式語言中也有。</p><p>在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。</p><p>邊界檢查會檢查所存取的索引值是否在陣列的範圍內，但是這樣的檢查會有些微的效能損耗，尤其在迴圈內的情況更有可能被累積而放大，關於 Julia 的 邊界檢查可以參考官方文件 <a href="https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html" target="_blank" rel="noopener">Bounds checking</a>。</p><p>如果可以確定所存取的索引值一定在範圍內，我們就可以把邊界檢查給移除，以加速陣列的存取。如以下範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; rand(3, 4)</span><br><span class="line">@inbounds for i &#x3D; 1:size(A, 1)</span><br><span class="line">    println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>或是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; rand(3, 4)</span><br><span class="line">for i &#x3D; 1:size(A, 1)</span><br><span class="line">    @inbounds println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>@inbounds</code> 會將程式碼區塊中的邊界檢查給移除，可以參考 <code>@inbounds</code> 的<a href="https://docs.julialang.org/en/latest/base/base/#Base.@inbounds" target="_blank" rel="noopener">官方文件</a>。使用時必須注意存取的索引值，否則小則存取的值錯誤，大則可能導致程式崩潰。</p><p>先養成好的索引習慣，再考慮將效能提升，加入 <code>@inbounds</code>。相關的資訊也紀錄在官方的<a href="https://docs.julialang.org/en/latest/manual/performance-tips/#man-performance-annotations-1" target="_blank" rel="noopener">效能建議</a>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有在做套件開發的開發者們應該不陌生 &lt;code&gt;@inbounds&lt;/code&gt; 這個 macro，在很多現代程式語言中也有。&lt;/p&gt;
&lt;p&gt;在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。&lt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 中的行內函式（inline functions）</title>
    <link href="https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/</id>
    <published>2019-09-06T02:34:58.000Z</published>
    <updated>2019-09-06T03:16:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>剛好看到一些跟編譯器相關的議題，所以來紀錄一下。</p><p>在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。</p><p>最知名應該是 C 跟 C++ 的 <code>inline</code>。</p><p>Inline function 會在編譯時期直接將函式內容展開到程式碼中，不過展開與否是由編譯器決定的，<code>inline</code> 的標記只是告訴編譯器這個函式可以成為 inline function。</p><p><a href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank" rel="noopener">Inline expansion</a> 就是編譯時期會由編譯器執行的一個動作，看起來與 macro expansion 相似，但不同的是 macro expansion 是在前處理（preprocessing）時期做的，會直接展開在原始碼裡頭，而 inline expansion 則是在編譯時期做的，會在呼叫位點（call site）直接展開。</p><p>展開後編譯器便可以進行最佳化，執行時，就不需要做函式呼叫，也不會在 function stack 上多配置空間。一般使用在短小的函式上會有好處，在巨大的函式上使用不一定會有好處。然而過多的 inline function 反而可能造成過多的指令快取的消耗，造成反效果。</p><p>在 Julia 中，編譯器會自動偵測哪些函式可以被展開，會自動做 inline expansion。一般短小的函式會自動被編譯器判定要 inline，不過也可以由程式設計師自己指定哪些巨大函式可以 inline，可以參考[文件]](<a href="https://docs.julialang.org/en/v1.2/base/base/#Base.@inline" target="_blank" rel="noopener">https://docs.julialang.org/en/v1.2/base/base/#Base.@inline</a>)。</p><p>除了 <code>@inline</code> 以外，還有 <code>@noinline</code>。為了避免過多的 inline 反而傷害效能，也可以標記一些短小的函式不要 inline。</p><p>範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@inline function bigfunc(x)</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>相關技術：<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">Inline caching</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;剛好看到一些跟編譯器相關的議題，所以來紀錄一下。&lt;/p&gt;
&lt;p&gt;在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。&lt;/p&gt;
&lt;p&gt;最知名應該是 C 跟 C++ 的 &lt;code&gt;inline&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Inl
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>一次開源專案貢獻經驗</title>
    <link href="https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/"/>
    <id>https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/</id>
    <published>2019-07-08T14:08:04.000Z</published>
    <updated>2019-09-06T03:19:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。</p><p>我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。</p><a id="more"></a><p>起初，我只想用最簡單、直接的方式可以相容於原本的 API，並且達到我想要的功能。</p><p>後來專案的審查者希望我將較為底層的功能一起做調整，在不是很情願的情形下，我提出了我認為比較好的修改方案。畢竟動下去等於是整個架構要重新改掉了。</p><p>幾次的來回討論以及確認目標後，我確實需要把這部份的功能全部打掉重做。</p><p>其中包含審查者注意到 Julia 是個 column-major 的語言，原本的 row-major 的計算方式要改掉，以讓效能最大化。要如何處理 API 的更動，無非是加入 deprecation warning，然後還得考慮預設值的問題，在這邊審查者一直無法決定預設值該是什麼。</p><p>再來是，由 API 將資料收進來之後，該如何有效率而優雅地處理資料是個問題。有效率代表程式碼不能有多餘的動作，包含多餘的記憶體耗用、轉置與否。優雅代表 API 底下設計的函式之間的轉換跟呼叫也需要保持簡潔跟可讀性，如函數式程式設計般簡潔，如物件導向般可讀性，不能有重複的程式碼（Don’t repeat yourself, DRY）。像是在 API 下層還要繼續設計 API 一般，直到最底層演算法都要保持這樣的原則，你不會有機會做骯髒的手腳。</p><p>來來回回在 PR 上的討論，一則都會有十行以上的文字。想必工程師最討厭的就是需要不斷地跟別人溝通想法，會不斷有想法拋出去，也不斷地被否決，理由通常都是這麼做不夠簡潔、不夠有可讀性、不夠有效率。</p><p>不過我想我們的目標是一致的，希望貢獻開源專案，無非是將好的東西貢獻到專案上。種種的批評跟新想法都是促進彼此的成長，有時候是我的方法不夠有效率，有時候是審查者的想法無法通過自動測試，這時候他會為他的想法道歉。我也曾經誤解了他的英文，讓他需要再重新解釋一遍。</p><p>很多時候會遇到一些挫折，像是我覺得他這樣做超級蠢，或是我辛辛苦苦改完一個版本上傳，但是對方卻隔了一個禮拜沒有來看。我想除了技術以外，如何跟別人溝通就在這裡展現出重要性。我講講我自己的心法：</p><ol><li><p>開源專案是大家一起討論出來的結果，沒有辦法說是誰的 idea，除非你真的貢獻超級多或是是專案的擁有者。</p></li><li><p>溝通的時候先溝通目的，將目的說明清楚，別讓別人摸不著頭緒或是不斷猜測浪費時間。</p></li><li><p>溝通時請儘量客觀而表達明確，有必要的話，直接寫一個小的例子。</p></li><li><p>不斷來回的議題通常會產生一些負面情緒，請耐著性子跟對方解釋清楚。在做的好的地方不吝給個稱讚或是表情符號。</p></li><li><p>你認為是對的事情就該明確講出來，將事情說明清楚就好，不需要過於強烈的用字。</p></li></ol><p>到目前為止，PR 都還沒 merge，卻已經歷時了兩個月，累積了 93 次的對話，產生了 15 次的 commit。增加了 339 行程式碼，刪除了 112 程式碼，diff 100%，意味著所有程式碼都被我修改過了。不過我想這不會是最後一次，不過會是一次蠻特別的經驗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。&lt;/p&gt;
&lt;p&gt;我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
    
  </entry>
  
  <entry>
    <title>運算 Julia 參數型別上的值</title>
    <link href="https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/</id>
    <published>2019-05-06T05:56:52.000Z</published>
    <updated>2019-09-06T03:19:59.125Z</updated>
    
    <content type="html"><![CDATA[<p>之前介紹過將值放在參數型別上。</p><p>今天來介紹一下如何可以做到類似運算的效果。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a1 = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">a2 = A&#123;<span class="number">3</span>&#125;()</span><br></pre></td></tr></table></figure><p>在一些應用場景上會希望將參數欄位上的值做運算，例如加總。</p><p>這時候我們可以這樣做：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Base:+</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> +(::A&#123;T&#125;, ::A&#123;S&#125;) <span class="keyword">where</span> &#123;T, S&#125;</span><br><span class="line">x = T + S</span><br><span class="line"><span class="keyword">return</span> A&#123;x&#125;()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以簡單搞定囉！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(a1 + a2)</span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">8</span>&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前介紹過將值放在參數型別上。&lt;/p&gt;
&lt;p&gt;今天來介紹一下如何可以做到類似運算的效果。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>彰化行</title>
    <link href="https://yuehhua.github.io/2019/03/11/changhua-with-ning/"/>
    <id>https://yuehhua.github.io/2019/03/11/changhua-with-ning/</id>
    <published>2019-03-10T17:19:06.000Z</published>
    <updated>2019-09-11T12:50:34.574Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Enter password to read the article</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="3815e404e28251f2aa216d376639685ed9a8f54150c59eba8f8390c7ce4d096c">999302eb3da7ba0830f0d4430dd24ff4e338e2068524d9e60b85b93fd82eb6496ac5b6e68e9e454804fe0df94e0eec66f38528b520d44e36d91ae62b8c8517268ba45789e4a5831ab98cbd2c8bab4eb3772a0d4f59d8888e75380e3d1a667ba69eb22f0f7c4c328da923eea82afe8cdba2f114a8d409b6d8d709fb555d8fed0b74129534d47165114470049deeaf37ad377430daf9514f69ddb5102a535953b7bff718c5a3a516aa32b10354df91745a234bb6a0b227f13dd085e115f42c735a0dd4773aeabe28c4d2878cc1d8ea89af548368e7723b95eb1ad15ace513cd28a63748c2e4d0bc6d368069ecdbe38ddadb500d0010a1012bdfa174d1b18f103827c8d75a87b8d2004f9c5df1776ecf2efbdfa7d77e9a4ae2ee825f917026ae9bfb185e593e62d7ae895d93e5cf16422499532ddcd28436bc91551d6e5a6779cfb7ef6ad202dccd3b13ddf30e5cece6597e5157646b9b7ae44520d426285fa9d2ae0112d31c4af83dcbfeaf86da38bde7376e9d3a0421913db00a526c1872b7a51a1162b40698189e5af252984244b0ae0a49ba566787c4c29f7a7f8dc3d9e4aca4234ee1abae5fdc0fe51e59f17ba2cf44952fd35537b22bb1bd7e6480ff781672c2f5a53cd515c7e8caac3dfae67f78840ee6961a174519d854a3ab2ea61d1fb4a9986d46f2d7ca8902a2cd5e2b78a70c86973fdcdbc07b99fc7728ecc6780c34b400f4231a3342add16f7ef6453d2fca047f1caffd13b66df4417892f8fa8385c6ac8de32c2028f4fb84ba5cff3dfe46a5f6defe2fe48e832af84d3ae5b0d914c1e0ef3f32e1e0fc1d58f28abbdc00df6b72c7effc376ac9a9fb6eb81d91070f77d7b961a13f125f08c7f2bf671f44660d40cd7784e2e54bf9d1500b0f88c46be209b1c3d774c3e02451092dc3b67be05664cd45ae271fa6f4124074a18a51da797428fca161213e8fe5be6879574b3c7117d318d08ea1845cb600857b61a59727b76b63a114e845e507a929440fa222c27c1f95fd0acac5171a642d2571d044102e4f4c597e8965163e4a13670816b1244686d936521aae807020f6074a4d01893c9441f168e7a8030ff8b232329a28c7cddf3597425832b333cd362829407c8259ab7e09a93a517b45256cdd5a90fdeba31ec8b0b5ece3ead908784a14384170b25fb93e86eabc0b241d5db33282fd1ec1afe3b5c15f83813bb0f3ea1a3338e24fcf28a784c3b71798761ee7ace4fcb4b58fdf918c87c2ff6fe88f1a497a9676229735c88b864b875d5566b5457ec50891630e16af3ad2a6d124dd08b0fa721147a495a52cb57728bfcba558ef7ca3fa1a8e31005a561eddbc607f1adb05826575996a205b2363b0c9307f66e7805acdfdb07937212824b5d3314b370e8e878bf024efe01e1b18a9435ae61dcf756ff7d41683a9c20e0ebec26f051e3a9f7a90315c60d3043211520eeae02036a86eef2d52f50c23db32015fd276f6147686362b08756f02752f2de9d807d053a00aa795509272e20b67642704d1d67904967ed8561e7eaf63bdd07ff4bdddd49e24933b9626509e8b4a676d5452e461a1bef1aa06a190eeb8c3c1a8041140c98ff1227e89d53095774ecabe752c93b194a3be93db8a2695abbc57a5687d3fa4bd90275bf3146667fb248287cbd8297077015b9ba6ddbdb7ec1cbeabc04e8c983fc5a39e5659b45537558a088691ef24d404fe498aeb7d80aeb7495df582527d62a3757658515c05dccf5485ed8f8e0136f5bccd02419a012a4605918ed13efb1976c3bb502eb8ce8e06c4755cad0c358517612cd8c00486cc88d8d57b983151e379859570ee6d86bdec1bcc3ec580d97b4f1ebcaeb1d78ed51913e1a88f242aea91144d02f4b4b58c2d3dca37cf767474a21cb133605eb9366b3c2787aea01afacd8c7d099cf0f46dc39be5b38bc64cff9ef520e33ee0edbd1274b912b3773720848a08aa0f095b6b84d6c5f7c79339ab1395704f7a3d82e376a24f99435eb32d178da743a1fab1bf62fc03843b415c64b8c876dea4fabfbddf13618ce934705af2e58d0e94749c62ce5dfb52c5a7a94a6117638ecee53fbbd5fcf68ea400565966826b60330857ecceeeba4a7e7b86705b572acc1f76764a5fcef4bbf4e7c3bda3e04726cbfccaa268ecfb12ea497fc04a8588bd17d857ef6486890ff20cb4f0e911546aa6b9d1c2ed1bfd31459a53e967e400bc723088a67181c8584fe703700dfeaf08e7c8f07a08096f8ef3fbf26f855a0035744fe7c71ca18b6cb82c79cbc1f5870d132a8fc3631e0716c20e615d512b6f10b5ea44eae5c7c0e1daba48a8d778492dfa25d0122a96865999ec0df3c98a3af82d7b7ae942b6da80a158d74500f1981648e6f921de3d771aa83bb8ac9ff173b007bd6285b1460e41e061b5ecc3ae388a1855459498cc1e80606993904e85f165d4e67382b6b968cb65f6d45d0371c3211791902475c5d4aba5dae375a56b9766d2e0b669f08436fdbe4e4d21810bf9df82add67fd1e6538e912026cbe3308c2853b425ee41fe9e3952d4fdcb99013ac4232273735eec0faa8cdee9f4a330302aee85332ee687df4a05bd0f6f0b1fd903336b7e48b3d3c125e65ff8caa128d57cc54f8a12dc7364b75078ba9348f5a8fefccfa8d9502ae67aaa8ce3cd3537b9450a4016e702b71289f72076141317597dd665a6cd27c898543bd23bac8b860b1f1eff4f8a88c9e006aa521904915557de61b3247e898156eeb5c477ba97db23e3e6f3e3e46c0fc7370a54a006ed3c014d3b26c2d4dd78feb12c1703901874f8c84f2dc148e797e1e0faf2d4a727ad5d477cd7d96a68c5bc861be829352841780a7386e8d50cf424b8f9d3b170bcbc6db98b7da66a041c54b98949a21f746e6bd7016899b55e0977941d49d49969acdc00f7f5240094eb05d2d3f190d05d5f1713d3c6b83951508eb4de23c02d856a66c64ccc71c4d23b348102650c86c66908f20d690d4ccf5a9f9f17689993e11243bb8d1e85427cfa2b7dc7d8c4d7e7509b6c92cacf604994974bdf587d1a3356414196742050cc9c79a983094336b6e3b20e7ed74bf769699416b459eca57d6c069868b1c61c70035a1009ed80c0917f4484c4e0f72ee16af24302e13230665e571366e1aca3b5cc57a997d5951eb3bebefaa971f1fe878aab143ead2329a1bfd65d2f2332864dfebfed2b778311667b527df6497ebd0cf261b08cc8090076d4a758a536d6d3ba2c68b89b77c61d300fd5f7bd22b3b6f7a3f8c1b87c7db796957804cf0ba805cf7b1aac1ddde96c194b76e51bd3e4e77f5589e3b0c9a0229f17f64f914f3219d8c822f72f018205f62222c489d045a5e6c7c0c7cd5fd9821a129a5a0025742ba9c965c1fbbeaedf4d346a671cf259af8debd94e6dd309b4a22bec1b4a4e54b1c71a343d6643b531ff1930d7b52183488aea4ba81bd118435d4f8a02f8cd416877ec662d0973421c9f533d8e265f0c045edc5cfd0c94aa8426370b88ff028058c18bfff30d23f46ee272d4a53da19c20a0ec78fd2aeb7f7e1eb5e01f10b01d1a87b3d70f7dc57029d0844b116f6fc77009bbd8b1ff7b124e0d870f2037acb0f87cdc00f15aa1cc671814bcec30dbbe93aa82401718804772b2e0fab79511c92c26826fc2fca2d96afaf5a31ec8138e9798e3633dff8e802e528d432eb562ad3ea01646c878932b02da36a177854e68d86c8d6ae482248ac55ced934c799278b8561429b9e457901e4fa52eb97fe85180ac386c533bab26dddd5b148cab522dfce77e5c85b21dfbc56b446563671aa7602c1e200e84eceaeb58b9982c20eb8b4d6f5bc8f4ab754a9135bfc55959c6d9ad77f7fadd10e2eb5fc7327074dc891dda751d05dd58f4c5da3fb2c0024400ad5929a4eda88e5e498cebcee9872d8efd01c6f1f95ffa2d69d68d3cbf09ab741652df9559b8ff66774efb16de887470b31947ab18ee20524555fc34e663756766d71aa3d31f45970406fa40ce86e57c86c6504384597334dd3a4fe097cdcf3b6f51cfd7fe043af898361980e7e89e4802ac281eed5c9e13e4b18f2246708c5832d40845cb00d95d830a6d743adffec2248b28fd646c2bffb28f0f1a1c91339d8b8238503a88a65583ed8e2b8f608e85779a5277600a496ae130395d6a6d5e964af1e5c8ebee0daae2e3c7c29be9f368e95e0f8457cd9df85e94056881ccd2d8bcd9ff7e8fd576a8ed14f3d7a42a1f76f5bcc57c426905b8fcce12034edb6f486115b156584dcc004484bf9e2e9dbea3edfae955163a95c1cafbe0a664d760fd5f67804386ed5031278b3b96414ae2240f7b44df5e59537725c97c214997d3c842b781e14cbe16f2fda55b1acb2834b2fd15be5a446f9f211ee039aeaf53591d95a9e7459970dde5f74b2b920b514981ba5ae56213bfb39234a2ebf0baf74693d88bf6dea699bbd44e41a58d36fafde72e46f628b1b34034432053cedbf5c50208618b02ca449312493e4e0866e4c18c21f2495b80cdad58545ca12073d45880369022738eb01cf59db539e48be9554e3596718362b0e8df8296c4fc83a8866e2ea2f4d4f6f0aa530da0bbc1cb2668bcf1d1d598692df869e12f7a354cea568096fe732e5ed6361c62ebc1cb578ad1c31a67d95235596012e68f94f22a6b17b0fd2b11940d5f980351bbe7d4c44971a46ab0066d50d734ffdf5ee6bd6c99cd7e95129dfe3414c32787bb46d3e20b2dcf2b16b1388afe4127da3a11d46d908fb976269c1efda70dddefe9c014da408535fed7efb9f0cfed3386daac91d5f9851391caa6efbc35da868ef1efe304e18f86a3c5bcfe5ff14e5a752b00fdd749c5f4f495d8e987fcb1ead3aa6c0d69dd106eef8439353f6faa0e2af7e295a96fb9b57404f3ef87984411a2a717688a7bd58b657115c3b758f42498eda37601329c974ce537f1b027003b0c54bc43016322ba19bf08c5d661d5e74a57b4f93a7a8e00bcc3bf3ffb4af9b037e009650a56adc87cabeef4f7f809eb00888e091ac65725117a4d83b7cb4a586db62846e47c3b5f188aac65d773090c59f8ebc70242df738c1cdd858606346d7bfa77df0a01b41d01aea497396cda6e5468ef8632db399a31b7b52e730dad45178ef1c7946d4faee311a5a11383490120c58553df4c6a6ff7601aabdcd5a28346ef83fcf7d24b38bd640b521628e9d0483b03f295ee1e0c110db8298c76bf1563f84c3756b80aa212cb3e74b2840e802b790eb20ec571e22e57d480b67df443fbfbe449b2cacbf598b2cc1567229497a329c82fd88dbe4b3fb53127ff227e1167ae8b696daf6f58f99d8ae6b38ff3d23efd6ebc478724cd4896cecad71607d6936641388abe802852eaa32da359becff255d9623b1e176a97ac500a9e1571cef23e9</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Private post
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Friends" scheme="https://yuehhua.github.io/categories/My-Style/Friends/"/>
    
    
  </entry>
  
  <entry>
    <title>金錢是最廉價的表達</title>
    <link href="https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/"/>
    <id>https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/</id>
    <published>2019-03-01T04:20:45.000Z</published>
    <updated>2019-05-06T05:59:11.172Z</updated>
    
    <content type="html"><![CDATA[<p>人們常常對自己的親人朋友表達情感。</p><p>很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。</p><a id="more"></a><p>我認為利用金錢來表達這些情感非常的廉價。</p><p>金錢並不包含一個人想表達的情感跟意志。</p><p>除了金錢以外，還有什麼是更珍貴更值得付出，更能表達誠意的。</p><p>是時間，你花時間寫的文字比罐頭簡訊或是七彩的卡片溫暖，花時間做的料理或是點心更能彰顯你對另一半的關愛。</p><p>那些以金錢買來的禮品、請客，比不上更真誠的陪伴跟暢談。</p><p>對我而言，我不會讓摯友跟親人以金錢取代真摯的情感。而那些會接受以金錢表達的，多半是泛泛之交。</p><p>相較起時間的付出，金錢真的非常廉價。我始終不認為金錢可以買到友誼、愛情或是親情。如果有人買到了，那一定無比虛假。不過或許可以用金錢買到專業跟努力。</p><p>現代人生活節奏很快，時間更是珍貴，所以願意付出時間的人才是重視對方的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人們常常對自己的親人朋友表達情感。&lt;/p&gt;
&lt;p&gt;很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。&lt;/p&gt;
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>神經微分方程（Neural Ordinary Differential Equations）</title>
    <link href="https://yuehhua.github.io/2019/02/24/neural-ode/"/>
    <id>https://yuehhua.github.io/2019/02/24/neural-ode/</id>
    <published>2019-02-24T07:47:10.000Z</published>
    <updated>2019-02-25T16:18:15.950Z</updated>
    
    <content type="html"><![CDATA[<p>這篇被選為 NeurIPS 2018 最佳論文，他將連續的概念帶入了神經網路架構中，並且善用以往解微分方程的方法來做逼近，可以做到跟原方法（倒傳遞）一樣好的程度，而參數使用複雜度卻是常數，更短的訓練時間。</p><h2 id="核心觀念">核心觀念</h2><p>概念上來說，就是將神經網路<strong>離散的層</strong>觀念打破，將他貫通成為<strong>連續的層</strong>的網路架構。</p><p>連續和離散的差別來自於倒傳遞的過程：</p><p>$$<br>\mathbb{y}_{t+1} = \mathbb{y}_t - \eta \nabla \mathcal{L}<br>$$</p><p>其中 $\nabla \mathcal{L}$ 就是梯度的部份，是向量的，然而我們把他簡化成純量來看的話，他不過就是</p><p>$$<br>\frac{d \mathcal{L}}{dt}<br>$$</p><p>廣義上來說，一個函數的微分，如果是離散的版本就會是</p><p>$$<br>\frac{dy}{dt} = \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>如此一來，所形成的方程式就會是差分方程，然而連續的版本就是</p><p>$$<br>\frac{dy}{dt} = \lim_{\Delta \rightarrow 0} \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>這個所形成的會是微分方程。</p><h2 id="從離散到連續">從離散到連續</h2><p>我們可以從離散的版本</p><p>$$<br>\frac{dy}{dt} = \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>把他轉成以下的樣貌</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt}<br>$$</p><p>要將他貫通的話，我們就得由從神經網路的基礎開始，如果是一般的前回饋網路（feed-forward network）當中的隱藏層是像下列這個樣子：</p><p>$$<br>h_{t+1} = f(h_t, \theta)<br>$$</p><p>我們可以發現像是 ResNet 這類的網路有 skip connection 的設置，所以跟一般的前回饋網路不同</p><p>$$<br>h_{t+1} = h_t + f(h_t, \theta)<br>$$</p><p>而 RNN 等等有序列概念的模型也有類似的結構，就是會是前一層的結果加上通過 $f$ 運算後的結果，成為下一層的結果。</p><p>這樣的形式跟我們前面提到的形式不謀而合</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt}<br>$$</p><p>只要我們把 $\Delta = 1$ 代入，就成了</p><p>$$<br>y(t+1) = y(t) + \frac{dy}{dt}<br>$$</p><p>以下給大家比對一下</p><p>$$<br>h_{t+1} = h_t + f(h_t, \theta) \\<br>y(t+1) = y(t) + \frac{dy}{dt}<br>$$</p><p>也就是，我們可以讓</p><p>$$<br>\frac{dy}{dt} = f(h_t, \theta)<br>$$</p><p>神奇的事情就發生了！神經網路 $f$ 就可以被我們拿來計算微分 $\frac{dy}{dt}$！</p><p>比較精確的說法是，把神經網路的層 $f$ 拿來逼近微分項，或是說梯度。這樣我們後面就可以用數值方法來逼近解。</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt} \\<br>\downarrow \\<br>y(t + \Delta) = y(t) + \Delta f(t, h(t), \theta_t)<br>$$</p><p>要拉成連續的還有一個重要的手段，就是將不同的層 $t$ 從離散的變成連續的，所以作者將 $t$ 做了參數化，將他變成 $f$ 的參數之一，如此一來，就可以在任意的層中放入資料做運算。</p><p>最重要的概念導出了這樣的式子</p><p>$$<br>h(t) \rightarrow \frac{dy(t)}{dt} = f(h(t), t, \theta) \rightarrow y(t)<br>$$</p><h2 id="神經網路作為一個系統的微分形式">神經網路作為一個系統的微分形式</h2><p>在傳統科學或是工程領域，我們會以微分式來表達以及建構一個系統。</p><p>$$<br>\nu = \frac{dx}{dt} = t + 1<br>$$</p><p>其實在這邊是一樣的道理，整體來說，我們是換成用神經網路去描述一個微分式，其實本質上就是這樣。</p><p>原本的層的概念就是用數學函數來建立的，而層與層之間傳遞著計算的結果。</p><p>$$<br>\mathbb{h_1} = \sigma(W_1 \mathbb{x} + \mathbb{b_1}) \\<br>\mathbb{y} = \sigma(W_2 \mathbb{h_1} + \mathbb{b_2})<br>$$</p><p>然而變成連續之後，我們等於是用神經網路中的層去建立跟描繪微分形式。</p><p>$$<br>\frac{d h(t)}{dt} = \sigma(W(t) \mathbb{x}(t) + \mathbb{b(t)}) \\<br>\frac{d y(t)}{dt} = \sigma(W(t) \mathbb{h}(t) + \mathbb{b(t)})<br>$$</p><p>是不是跟如出一轍呢？</p><p>$$<br>\frac{dy(t)}{dt} = f(h(t), t, \theta)<br>$$</p><h2 id="向前傳遞解微分式">向前傳遞解微分式</h2><p>我們可以來計算看看隱藏層是長什麼樣子的。在隱藏層的微分式中，也是利用隱藏層去計算出來的。</p><p>$$<br>\frac{dh(t)}{dt} = f(h(t), t, \theta)<br>$$</p><p>基本上，我們只要對上式做積分就可以了。</p><p>$$<br>h(t) = \int f(h(t), t, \theta) dt<br>$$</p><p>這是一個怎樣的概念呢？我們可以來看看下圖。</p><p><img src="/images/hidden-state1.svg" alt=""></p><p>我們做積分這件事其實是用 $h(t_0)$ 來推斷 $h(t_1)$ 的，這跟神經網路的向前傳遞是一樣的行為。</p><p>$$<br>h(t_1) = F(h(t), t, \theta) \bigg|_{t=t_0}<br>$$</p><p>這樣的積分動作，我們可以用 $t_0$ 時間點的資訊來解 $h(t_1)$。</p><p>這樣的解法在程式上就會交由 ODE Solver 去處理。</p><p>$$<br>h(t_1) = ODESolve(h(t_0), t_0, t_1, \theta, f)<br>$$</p><h2 id="反向傳遞解函數">反向傳遞解函數</h2><p>$$<br>\mathcal{L}(t_0, t, \theta) = \mathcal{L}(ODESolve(\cdot))<br>$$</p><p>$$<br>\frac{\partial \mathcal{L}}{\partial h(t)} = -a(t)<br>$$</p><p>adjoint state</p><p>$$<br>a(t) = \int -a(t)^T \frac{\partial f}{\partial h} dt = - \frac{\partial \mathcal{L}}{\partial h(t)}<br>$$</p><p>$$<br>a(t) = \int_{t_1}^{t_0} -a(t)^T \frac{\partial f(h(t), t, \theta)}{\partial h(t)} dt<br>$$</p><p><img src="/images/adjoint-state.svg" alt=""></p><h2 id="擴充狀態（augmented-state）">擴充狀態（augmented state）</h2><p>$\frac{d \theta}{dt} = 0$</p><p>$\frac{dt}{dt} = 1$</p><p>let $\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}$ be a augmented state</p><p>augmented state function:</p><p>$$<br>f_{aug}(\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}) =<br>\begin{bmatrix}<br>f(h(t), t, \theta) \\<br>0 \\<br>1<br>\end{bmatrix}<br>$$</p><p>augmented state dynamics:</p><h1>$$<br>\frac{d}{dt}<br>\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}</h1><p>f_{aug}(<br>\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix})<br>$$</p><p>augmented adjoint state:</p><p>$$<br>\begin{bmatrix}<br>a \\<br>a_{\theta} \\<br>a_t<br>\end{bmatrix}<br>$$</p><p>$a = \frac{\partial \mathcal{L}}{\partial h}$</p><p>$a_{\theta} = \frac{\partial \mathcal{L}}{\partial \theta}$</p><p>$a_t = \frac{\partial \mathcal{L}}{\partial t}$</p><p>$$<br>\frac{d a_{aug}}{dt} = -<br>\begin{bmatrix}<br>a \frac{\partial f}{\partial h} \\<br>a \frac{\partial f}{\partial \theta} \\<br>a \frac{\partial f}{\partial t}<br>\end{bmatrix}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇被選為 NeurIPS 2018 最佳論文，他將連續的概念帶入了神經網路架構中，並且善用以往解微分方程的方法來做逼近，可以做到跟原方法（倒傳遞）一樣好的程度，而參數使用複雜度卻是常數，更短的訓練時間。&lt;/p&gt;
&lt;h2 id=&quot;核心觀念&quot;&gt;核心觀念&lt;/h2&gt;
&lt;p&gt;概念上
      
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://yuehhua.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>筆記 - 從向量空間到函數空間</title>
    <link href="https://yuehhua.github.io/2019/02/24/note-of-vector-space-to-function-space/"/>
    <id>https://yuehhua.github.io/2019/02/24/note-of-vector-space-to-function-space/</id>
    <published>2019-02-24T04:54:02.000Z</published>
    <updated>2019-02-24T04:54:02.908Z</updated>
    
    <content type="html"><![CDATA[<p>參考<a href="https://ccjou.wordpress.com/2009/08/18/%E5%BE%9E%E5%B9%BE%E4%BD%95%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93%E5%88%B0%E5%87%BD%E6%95%B8%E7%A9%BA%E9%96%93/" target="_blank" rel="noopener">從幾何向量空間到函數空間| 線代啟示錄</a>。</p><ol><li>由 $\mathbb{R}^n$ 拓展到 $\mathbb{R}^{\infty}$ 所需俱備的條件是什麼？</li></ol><p>由於一個向量 $\mathbb{v} \in \mathbb{R}^{\infty}$，在無限維度下我們需要考慮一個問題，就是 norm。</p><p>如果這個空間有定義 norm 的話，我們就要考慮他有沒有收斂，也就是 $||\mathbb{v}||^2$ 要存在。</p><p>所以條件就是</p><p>$$<br>||\mathbb{v}||^2 = \sum_{i=1}^{\infty} v_i^2<br>$$</p><p>要收斂。</p><ol start="2"><li>從 $\mathbb{R}^{\infty}$ 無限維度的向量空間再拓展到 $C^{\omega}$ 函數空間，所需要俱備的條件是什麼？</li></ol><p>一個無限維度的向量是一個離散的版本，由剛剛的式子可以看的出來</p><p>$$<br>||\mathbb{v}||^2 = \sum_{i=1}^{\infty} v_i^2<br>$$</p><p>而一個（解析）函數則是連續的</p><p>$$<br>||f||^2 = \int f^2(x) dx<br>$$</p><p>除了以上的 norm 要收斂外，從離散到連續應該有些假設或是條件才是。</p><ol start="3"><li>函數的基底</li></ol><p>Fourier series</p><p>$$<br>f(x) = a_0 + a_1 \cos x + b_1 \sin x + a_2 \cos 2x + b_2 \sin 2x + \cdots<br>$$</p><p>所以基底就是</p><p>$$<br>&lt;\beta&gt; = &lt;1, \cos x, \sin x, \cos 2x, \sin 2x, \cdots&gt;<br>$$</p><ol start="4"><li>非週期性函數基底</li></ol><p>Legendre polynomial</p><ol start="5"><li>Least square problem</li></ol><p>$$<br>(A^TA)\hat{y} = A^Tb<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;參考&lt;a href=&quot;https://ccjou.wordpress.com/2009/08/18/%E5%BE%9E%E5%B9%BE%E4%BD%95%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93%E5%88%B0%E5%87%BD%E6%95
      
    
    </summary>
    
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>在參數化型別中使用值的效能分析</title>
    <link href="https://yuehhua.github.io/2019/02/22/performance-analysis-of-value-in-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/02/22/performance-analysis-of-value-in-parametric-type/</id>
    <published>2019-02-22T04:24:37.000Z</published>
    <updated>2019-09-06T03:20:20.510Z</updated>
    
    <content type="html"><![CDATA[<p>我在使用的時候有注意到<em>在參數化型別中使用值</em>的方式與<em>傳統封裝</em>的方式有效能上的差異。</p><p>所以我就做了一些測試。</p><p>在參數化型別中使用值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>傳統型別封裝：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> B</span><br><span class="line">    x::<span class="built_in">Int64</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>全文出現的程式碼為實際測試程式碼</em></p><p>因為 Julia 有提供好用的 <code>@code_llvm</code> 及 <code>@code_native</code> 來觀察一行程式碼實際被轉換成 LLVM 或是組合語言的時候會產生多少行的程式碼，藉此我們可以用低階程式碼來評估是否有效率。程式碼的行數愈少是越有效率的。</p><h2 id="建立">建立</h2><p>我們來測試一個物件被建立需要多少行的程式碼。</p><h3 id="A-LLVM">A - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[1]:3 within `Type'</span></span><br><span class="line"><span class="comment">define nonnull %jl_value_t addrspace(10)* @japi1_Type_12238(%jl_value_t addrspace(10)*, %jl_value_t addrspace(10)**, i32) #0 &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  %3 = alloca %jl_value_t addrspace(10)**, align 8</span></span><br><span class="line"><span class="comment">  store volatile %jl_value_t addrspace(10)** %1, %jl_value_t addrspace(10)*** %3, align 8</span></span><br><span class="line"><span class="comment">  ret %jl_value_t addrspace(10)* addrspacecast (%jl_value_t* inttoptr (i64 140407726014496 to %jl_value_t*) to %jl_value_t addrspace(10)*)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="B-LLVM">B - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[1]:2 within `Type'</span></span><br><span class="line"><span class="comment">define &#123; i64 &#125; @julia_Type_12221(%jl_value_t addrspace(10)*, i64) &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  %.fca.0.insert = insertvalue &#123; i64 &#125; undef, i64 %1, 0</span></span><br><span class="line"><span class="comment">  ret &#123; i64 &#125; %.fca.0.insert</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="A-Assembly">A - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[1]:3 within &#96;Type&#39;</span><br><span class="line">movq%rsi, -8(%rsp)</span><br><span class="line">movabsq$140407726014496, %rax  # imm &#x3D; 0x7FB338A20020</span><br><span class="line">retq</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h3 id="B-Assembly">B - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[1]:2 within &#96;Type&#39;</span><br><span class="line">movq%rsi, %rax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h2 id="取值">取值</h2><p>接著測試從物件當中取值出來的效能。</p><p>定義取值的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_value(::A&#123;T&#125;) <span class="keyword">where</span> &#123;T&#125; = T</span><br><span class="line">get_value(b::B) = b.x</span><br></pre></td></tr></table></figure><p>事先建立好物件：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">b = B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="A-LLVM-2">A - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> get_value(a)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[8]:1 within `get_value'</span></span><br><span class="line"><span class="comment">define i64 @julia_get_value_12274() &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  ret i64 5</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="B-LLVM-2">B - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> get_value(b)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[5]:1 within `get_value'</span></span><br><span class="line"><span class="comment">define i64 @julia_get_value_12630(&#123; i64 &#125; addrspace(11)* nocapture nonnull readonly dereferenceable(8)) &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">; ┌ @ sysimg.jl:18 within `getproperty'</span></span><br><span class="line"><span class="comment">   %1 = getelementptr inbounds &#123; i64 &#125;, &#123; i64 &#125; addrspace(11)* %0, i64 0, i32 0</span></span><br><span class="line"><span class="comment">; └</span></span><br><span class="line"><span class="comment">  %2 = load i64, i64 addrspace(11)* %1, align 8</span></span><br><span class="line"><span class="comment">  ret i64 %2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="A-Assembly-2">A - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> get_value(a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[8]:1 within &#96;get_value&#39;</span><br><span class="line">movl$5, %eax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h3 id="B-Assembly-2">B - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> get_value(b)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[5]:1 within &#96;get_value&#39;</span><br><span class="line">movq(%rdi), %rax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><p>給大家參考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在使用的時候有注意到&lt;em&gt;在參數化型別中使用值&lt;/em&gt;的方式與&lt;em&gt;傳統封裝&lt;/em&gt;的方式有效能上的差異。&lt;/p&gt;
&lt;p&gt;所以我就做了一些測試。&lt;/p&gt;
&lt;p&gt;在參數化型別中使用值：&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;tab
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在參數化型別中定義值</title>
    <link href="https://yuehhua.github.io/2019/02/22/define-values-in-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/02/22/define-values-in-parametric-type/</id>
    <published>2019-02-21T17:22:42.000Z</published>
    <updated>2019-09-06T03:21:46.486Z</updated>
    
    <content type="html"><![CDATA[<p>應該不少人看到這個標題會摸不著頭緒到底要做什麼，但是看完 Julia 中常見的程式碼你就會了解了。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">Any</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>有沒有曾經納悶過那個數字 2 到底是怎麼進到參數的位置上的呢？</p><p>參數的位置不是只能放型別（type）嗎？</p><p>這同時也是我困惑已久的問題，就搜尋了一下，果不其然被我找到了方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><p>原來這麼簡單就可以完成了！語法上並沒有限定一定要是<em>型別</em>，要放型別以外的東西似乎是可以的。</p><p>我目前測試了可以的有：Int64、Float64、Complex、Char、Bool、Symbol，所以估計數字應該都是可以的。</p><p>不行的有：String、Array，估計物件或是陣列都是不行的。</p><h2 id="定義範圍">定義範圍</h2><p>不過使用上並沒有任何限制會有點危險，所以還是定義一下範圍會比較好，像是：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;<span class="literal">I</span>&#125;</span><br><span class="line">    <span class="keyword">function</span> A&#123;<span class="literal">I</span>&#125;() <span class="keyword">where</span> &#123;<span class="literal">I</span>&#125;</span><br><span class="line">        <span class="keyword">isa</span>(<span class="literal">I</span>,<span class="built_in">Integer</span>) || error(<span class="string">"bad parameter"</span>)</span><br><span class="line">        new()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這樣就可以限制參數要是整數的範圍。</p><h2 id="從參數取值">從參數取值</h2><p>那我們能不能從型別的參數當中取值呢？</p><p>可以。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_value(::A&#123;<span class="literal">I</span>&#125;) <span class="keyword">where</span> A&#123;<span class="literal">I</span>&#125; = <span class="literal">I</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以從型別中拿到值了。</p><h2 id="好處？">好處？</h2><p>這麼做有什麼好處？</p><p>當你把值的資訊放到型別當中，型別就多了一些資訊可以提供編譯器處理，這對於要自己設計型別階層可是非常好用的。</p><p>例如像是你可以將陣列的長度資訊儲存到型別上，這樣編譯器就可以處理陣列的長度資訊了。</p><p>這樣的程式風格會跟 dependent type language 有些相似了。</p><p>大家可以玩玩看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;應該不少人看到這個標題會摸不著頭緒到底要做什麼，但是看完 Julia 中常見的程式碼你就會了解了。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
</feed>
