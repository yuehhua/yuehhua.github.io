<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dream Maker</title>
  
  <subtitle>Love Math, Science, Biology, Computer science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuehhua.github.io/"/>
  <updated>2019-09-06T03:17:13.549Z</updated>
  <id>https://yuehhua.github.io/</id>
  
  <author>
    <name>Yueh-Hua Tu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Julia 的 inbounds</title>
    <link href="https://yuehhua.github.io/2019/09/06/inbounds-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inbounds-in-julia/</id>
    <published>2019-09-06T03:17:13.000Z</published>
    <updated>2019-09-06T03:17:13.549Z</updated>
    
    <content type="html"><![CDATA[<p>有在做套件開發的開發者們應該不陌生 <code>@inbounds</code> 這個 macro，在很多現代程式語言中也有。</p><p>在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。</p><p>邊界檢查會檢查所存取的索引值是否在陣列的範圍內，但是這樣的檢查會有些微的效能損耗，尤其在迴圈內的情況更有可能被累積而放大，關於 Julia 的 邊界檢查可以參考官方文件 <a href="https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html" target="_blank" rel="noopener">Bounds checking</a>。</p><p>如果可以確定所存取的索引值一定在範圍內，我們就可以把邊界檢查給移除，以加速陣列的存取。如以下範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = rand(3, 4)</span><br><span class="line">@inbounds for i = 1:size(A, 1)</span><br><span class="line">    println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>或是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = rand(3, 4)</span><br><span class="line">for i = 1:size(A, 1)</span><br><span class="line">    @inbounds println(A[i, :])</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><code>@inbounds</code> 會將程式碼區塊中的邊界檢查給移除，可以參考 <code>@inbounds</code> 的<a href="https://docs.julialang.org/en/latest/base/base/#Base.@inbounds" target="_blank" rel="noopener">官方文件</a>。使用時必須注意存取的索引值，否則小則存取的值錯誤，大則可能導致程式崩潰。</p><p>先養成好的索引習慣，再考慮將效能提升，加入 <code>@inbounds</code>。相關的資訊也紀錄在官方的<a href="https://docs.julialang.org/en/latest/manual/performance-tips/#man-performance-annotations-1" target="_blank" rel="noopener">效能建議</a>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有在做套件開發的開發者們應該不陌生 &lt;code&gt;@inbounds&lt;/code&gt; 這個 macro，在很多現代程式語言中也有。&lt;/p&gt;
&lt;p&gt;在存取陣列時，為了安全性與正確性的考量，避免存取到陣列範圍以外的記憶體位置，很多語言都設置了邊界檢查（bounds check）。&lt;
      
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>Julia 中的行內函式（inline functions）</title>
    <link href="https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/"/>
    <id>https://yuehhua.github.io/2019/09/06/inline-functions-in-julia/</id>
    <published>2019-09-06T02:34:58.000Z</published>
    <updated>2019-09-06T03:16:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>剛好看到一些跟編譯器相關的議題，所以來紀錄一下。</p><p>在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。</p><p>最知名應該是 C 跟 C++ 的 <code>inline</code>。</p><p>Inline function 會在編譯時期直接將函式內容展開到程式碼中，不過展開與否是由編譯器決定的，<code>inline</code> 的標記只是告訴編譯器這個函式可以成為 inline function。</p><p><a href="https://en.wikipedia.org/wiki/Inline_expansion" target="_blank" rel="noopener">Inline expansion</a> 就是編譯時期會由編譯器執行的一個動作，看起來與 macro expansion 相似，但不同的是 macro expansion 是在前處理（preprocessing）時期做的，會直接展開在原始碼裡頭，而 inline expansion 則是在編譯時期做的，會在呼叫位點（call site）直接展開。</p><p>展開後編譯器便可以進行最佳化，執行時，就不需要做函式呼叫，也不會在 function stack 上多配置空間。一般使用在短小的函式上會有好處，在巨大的函式上使用不一定會有好處。然而過多的 inline function 反而可能造成過多的指令快取的消耗，造成反效果。</p><p>在 Julia 中，編譯器會自動偵測哪些函式可以被展開，會自動做 inline expansion。一般短小的函式會自動被編譯器判定要 inline，不過也可以由程式設計師自己指定哪些巨大函式可以 inline，可以參考<a href="https://docs.julialang.org/en/v1.2/base/base/#Base.@inline" target="_blank" rel="noopener">文件]</a>。</p><p>除了 <code>@inline</code> 以外，還有 <code>@noinline</code>。為了避免過多的 inline 反而傷害效能，也可以標記一些短小的函式不要 inline。</p><p>範例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@inline function bigfunc(x)</span><br><span class="line">    ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>相關技術：<a href="https://en.wikipedia.org/wiki/Inline_caching" target="_blank" rel="noopener">Inline caching</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;剛好看到一些跟編譯器相關的議題，所以來紀錄一下。&lt;/p&gt;
&lt;p&gt;在一些語言中會有行內函式（inline function）的設計，使用的話一般會讓程式的效能變好。&lt;/p&gt;
&lt;p&gt;最知名應該是 C 跟 C++ 的 &lt;code&gt;inline&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Inl
      
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
      <category term="optimization" scheme="https://yuehhua.github.io/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>一次開源專案貢獻經驗</title>
    <link href="https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/"/>
    <id>https://yuehhua.github.io/2019/07/08/opensource-contribution-experience/</id>
    <published>2019-07-08T14:08:04.000Z</published>
    <updated>2019-09-06T03:19:49.032Z</updated>
    
    <content type="html"><![CDATA[<p>來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。</p><p>我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。</p><a id="more"></a><p>起初，我只想用最簡單、直接的方式可以相容於原本的 API，並且達到我想要的功能。</p><p>後來專案的審查者希望我將較為底層的功能一起做調整，在不是很情願的情形下，我提出了我認為比較好的修改方案。畢竟動下去等於是整個架構要重新改掉了。</p><p>幾次的來回討論以及確認目標後，我確實需要把這部份的功能全部打掉重做。</p><p>其中包含審查者注意到 Julia 是個 column-major 的語言，原本的 row-major 的計算方式要改掉，以讓效能最大化。要如何處理 API 的更動，無非是加入 deprecation warning，然後還得考慮預設值的問題，在這邊審查者一直無法決定預設值該是什麼。</p><p>再來是，由 API 將資料收進來之後，該如何有效率而優雅地處理資料是個問題。有效率代表程式碼不能有多餘的動作，包含多餘的記憶體耗用、轉置與否。優雅代表 API 底下設計的函式之間的轉換跟呼叫也需要保持簡潔跟可讀性，如函數式程式設計般簡潔，如物件導向般可讀性，不能有重複的程式碼（Don’t repeat yourself, DRY）。像是在 API 下層還要繼續設計 API 一般，直到最底層演算法都要保持這樣的原則，你不會有機會做骯髒的手腳。</p><p>來來回回在 PR 上的討論，一則都會有十行以上的文字。想必工程師最討厭的就是需要不斷地跟別人溝通想法，會不斷有想法拋出去，也不斷地被否決，理由通常都是這麼做不夠簡潔、不夠有可讀性、不夠有效率。</p><p>不過我想我們的目標是一致的，希望貢獻開源專案，無非是將好的東西貢獻到專案上。種種的批評跟新想法都是促進彼此的成長，有時候是我的方法不夠有效率，有時候是審查者的想法無法通過自動測試，這時候他會為他的想法道歉。我也曾經誤解了他的英文，讓他需要再重新解釋一遍。</p><p>很多時候會遇到一些挫折，像是我覺得他這樣做超級蠢，或是我辛辛苦苦改完一個版本上傳，但是對方卻隔了一個禮拜沒有來看。我想除了技術以外，如何跟別人溝通就在這裡展現出重要性。我講講我自己的心法：</p><ol><li><p>開源專案是大家一起討論出來的結果，沒有辦法說是誰的 idea，除非你真的貢獻超級多或是是專案的擁有者。</p></li><li><p>溝通的時候先溝通目的，將目的說明清楚，別讓別人摸不著頭緒或是不斷猜測浪費時間。</p></li><li><p>溝通時請儘量客觀而表達明確，有必要的話，直接寫一個小的例子。</p></li><li><p>不斷來回的議題通常會產生一些負面情緒，請耐著性子跟對方解釋清楚。在做的好的地方不吝給個稱讚或是表情符號。</p></li><li><p>你認為是對的事情就該明確講出來，將事情說明清楚就好，不需要過於強烈的用字。</p></li></ol><p>到目前為止，PR 都還沒 merge，卻已經歷時了兩個月，累積了 93 次的對話，產生了 15 次的 commit。增加了 339 行程式碼，刪除了 112 程式碼，diff 100%，意味著所有程式碼都被我修改過了。不過我想這不會是最後一次，不過會是一次蠻特別的經驗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;來分享一下最近貢獻開源專案的小心得，雖然我自己貢獻開源專案的次數跟時間不是很多，不過一個 PR 可以產生不少文字跟討論算是值得紀錄一下的。&lt;/p&gt;
&lt;p&gt;我自己在 Julia 的一個統計相關的專案上發了一個 PR，希望補齊在標準化上的一些功能，並且可以支援一維的陣列標準化。&lt;/p&gt;
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
    
  </entry>
  
  <entry>
    <title>運算 Julia 參數型別上的值</title>
    <link href="https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/05/06/operate-value-in-julia-parametric-type/</id>
    <published>2019-05-06T05:56:52.000Z</published>
    <updated>2019-09-06T03:19:59.125Z</updated>
    
    <content type="html"><![CDATA[<p>之前介紹過將值放在參數型別上。</p><p>今天來介紹一下如何可以做到類似運算的效果。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a1 = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">a2 = A&#123;<span class="number">3</span>&#125;()</span><br></pre></td></tr></table></figure><p>在一些應用場景上會希望將參數欄位上的值做運算，例如加總。</p><p>這時候我們可以這樣做：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Base:+</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> +(::A&#123;T&#125;, ::A&#123;S&#125;) <span class="keyword">where</span> &#123;T, S&#125;</span><br><span class="line">x = T + S</span><br><span class="line"><span class="keyword">return</span> A&#123;x&#125;()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如此一來，就可以簡單搞定囉！</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(a1 + a2)</span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">8</span>&#125;()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前介紹過將值放在參數型別上。&lt;/p&gt;
&lt;p&gt;今天來介紹一下如何可以做到類似運算的效果。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>彰化行</title>
    <link href="https://yuehhua.github.io/2019/03/11/changhua-with-ning/"/>
    <id>https://yuehhua.github.io/2019/03/11/changhua-with-ning/</id>
    <published>2019-03-10T17:19:06.000Z</published>
    <updated>2019-05-06T05:58:10.535Z</updated>
    
    <content type="html"><![CDATA[<p>非常開心再次跟敬宇一起出遊。</p><p>面對連日的陣雨，邊下邊停，溼得一踏糊塗。本來不期待今天會有好天氣，但今天卻被陽光給照醒了。</p><p>約定好的十點半，前往彰化的早午餐店。一路上太陽露臉，氣溫比較溫暖。</p><a id="more"></a><p>車上放著 Celine Dion 的演唱會曲目，間斷的閒聊與空白，恰如其分。</p><p>話題一直圍繞在資訊的部份，像是 git 的使用、recurrence 在資訊領域的重要性。</p><p>在早午餐店，打量了周遭的擺設，不協調的壁畫及擺飾，有著微微嗆鼻的酸味，潮溼的空氣，混雜著人們的嘈雜。</p><p>跟敬宇說，這似乎不是那麼的細緻，不過卻得到這已經是彰化相對好的餐廳的回應。</p><p>前往彰師大，讓我看看物理系館跟實驗室，邊聊著量子資訊理論的發展、一些相對論，跟他自己的工作。</p><p>我也談起一些公司希望找生物資訊相關人才的一些難處，關乎薪資、生技產業的整體環境，以及台灣人才的出路。</p><p>打量著彰師的建物，對比成大的建物及人文，跟我的生活經驗，一切不是那麼的優雅且美麗。</p><p>帶我從彰師的小徑上了山，差點步入沒有路的樹林，順利繞進了八卦山。</p><p>上八卦山邊聊著宗教、鬼神、儒道墨法、戰後文學跟水壩的工程，不料被說跟我一起的話題都頗哲學。</p><p>雨來了，撐起了傘，一起漫步。</p><p>經過了賴和詩牆，變去敲了幾下，測試看看是否有共振頻率。</p><p>從另一頭的出口出來，敬宇帶我去吃彰化有名的肉圓。</p><p>有趣的是，肉圓當中有香菇，而當中的肉有當歸的味道，外皮相當柔軟，醬料也極搭。讓我感受到熟悉的味道。</p><p>在一手私藏買了好喝的紅茶之後，一路散步回學校。在白沙湖停留，聊著最新的腸內正常菌相可能影響免疫、精神疾病，甚至是大腦判斷。</p><p>回到了台中，在草悟道散步，小雨。</p><p>還記得在車上才講說誠品太文青，不適合宅宅。剛走進誠品要去廁所，不料又講說：這不就是下雨天該來的地方嗎？</p><p>也不知道是誰才在喊走路走太久，想找個地方坐坐。進誠品又說要出去外頭走走，沒過多久又喊腿痠了。</p><p>他終於意識到我先前說他講話反反覆覆是怎麼回事。</p><p>又一次走到了科博館，不知道是什麼巧合，每到此就會聊到之後的人生規劃。</p><p>雖然我一直認為敬宇去業界賺錢有點可惜，不過仍是個人選擇。剩下的就是要拿碩士學位或是博士學位了。</p><p>最近他正思考著是否該拿博士學位，但始終拿不定個主意，就碩班再多看看吧！</p><p>也是受我的影響，漸漸會將時間空下來，而不是被工作塞滿。去培養額外的資訊能力，以及更多的思考時間。</p><p>也將工作提前處理，可以跟我出去走走。</p><p>晚上討論著要去哪裡晚餐，不過似乎不是那麼餓，或許找個可以坐著聊聊的地方。</p><p>原本要去卡菲娜坐坐，不料繞了半天找不到停車位，剛好看到旁邊的 ikea 就直接進去了。</p><p>點完餐點，並沒有直接開動，反而講解起 graph 了。</p><p>說明 graph 的定義跟 GNN 可以怎樣用來模擬物理系統，敬宇越看越興奮，用手機找起論文來了。</p><p>兩個人就邊吃邊用餐巾紙討論著物理系統跟 graph 還有論文。</p><p>到了 ikea 餐廳收拾的時間才離去，繞過了展場，抵達收銀櫃台，為了免停車費，多買了一塊巧克力。</p><p>很滿足地回到了家裡，度過了悠閒、豐足的一天。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常開心再次跟敬宇一起出遊。&lt;/p&gt;
&lt;p&gt;面對連日的陣雨，邊下邊停，溼得一踏糊塗。本來不期待今天會有好天氣，但今天卻被陽光給照醒了。&lt;/p&gt;
&lt;p&gt;約定好的十點半，前往彰化的早午餐店。一路上太陽露臉，氣溫比較溫暖。&lt;/p&gt;
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Friends" scheme="https://yuehhua.github.io/categories/My-Style/Friends/"/>
    
    
  </entry>
  
  <entry>
    <title>金錢是最廉價的表達</title>
    <link href="https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/"/>
    <id>https://yuehhua.github.io/2019/03/01/money-is-the-cheapest-expression/</id>
    <published>2019-03-01T04:20:45.000Z</published>
    <updated>2019-05-06T05:59:11.172Z</updated>
    
    <content type="html"><![CDATA[<p>人們常常對自己的親人朋友表達情感。</p><p>很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。</p><a id="more"></a><p>我認為利用金錢來表達這些情感非常的廉價。</p><p>金錢並不包含一個人想表達的情感跟意志。</p><p>除了金錢以外，還有什麼是更珍貴更值得付出，更能表達誠意的。</p><p>是時間，你花時間寫的文字比罐頭簡訊或是七彩的卡片溫暖，花時間做的料理或是點心更能彰顯你對另一半的關愛。</p><p>那些以金錢買來的禮品、請客，比不上更真誠的陪伴跟暢談。</p><p>對我而言，我不會讓摯友跟親人以金錢取代真摯的情感。而那些會接受以金錢表達的，多半是泛泛之交。</p><p>相較起時間的付出，金錢真的非常廉價。我始終不認為金錢可以買到友誼、愛情或是親情。如果有人買到了，那一定無比虛假。不過或許可以用金錢買到專業跟努力。</p><p>現代人生活節奏很快，時間更是珍貴，所以願意付出時間的人才是重視對方的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人們常常對自己的親人朋友表達情感。&lt;/p&gt;
&lt;p&gt;很多時候是感謝，有時候是愛慕，有時候是崇敬，表達的方式可以有很多種。&lt;/p&gt;
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Believe。Think。Soul" scheme="https://yuehhua.github.io/categories/My-Style/Believe%E3%80%82Think%E3%80%82Soul/"/>
    
    
  </entry>
  
  <entry>
    <title>神經微分方程（Neural Ordinary Differential Equations）</title>
    <link href="https://yuehhua.github.io/2019/02/24/neural-ode/"/>
    <id>https://yuehhua.github.io/2019/02/24/neural-ode/</id>
    <published>2019-02-24T07:47:10.000Z</published>
    <updated>2019-02-25T16:18:15.950Z</updated>
    
    <content type="html"><![CDATA[<p>這篇被選為 NeurIPS 2018 最佳論文，他將連續的概念帶入了神經網路架構中，並且善用以往解微分方程的方法來做逼近，可以做到跟原方法（倒傳遞）一樣好的程度，而參數使用複雜度卻是常數，更短的訓練時間。</p><h2 id="核心觀念"><a href="#核心觀念" class="headerlink" title="核心觀念"></a>核心觀念</h2><p>概念上來說，就是將神經網路<strong>離散的層</strong>觀念打破，將他貫通成為<strong>連續的層</strong>的網路架構。</p><p>連續和離散的差別來自於倒傳遞的過程：</p><p>$$<br>\mathbb{y}_{t+1} = \mathbb{y}_t - \eta \nabla \mathcal{L}<br>$$</p><p>其中 $\nabla \mathcal{L}$ 就是梯度的部份，是向量的，然而我們把他簡化成純量來看的話，他不過就是</p><p>$$<br>\frac{d \mathcal{L}}{dt}<br>$$</p><p>廣義上來說，一個函數的微分，如果是離散的版本就會是</p><p>$$<br>\frac{dy}{dt} = \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>如此一來，所形成的方程式就會是差分方程，然而連續的版本就是</p><p>$$<br>\frac{dy}{dt} = \lim_{\Delta \rightarrow 0} \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>這個所形成的會是微分方程。</p><h2 id="從離散到連續"><a href="#從離散到連續" class="headerlink" title="從離散到連續"></a>從離散到連續</h2><p>我們可以從離散的版本</p><p>$$<br>\frac{dy}{dt} = \frac{y(t + \Delta) - y(t)}{\Delta}<br>$$</p><p>把他轉成以下的樣貌</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt}<br>$$</p><p>要將他貫通的話，我們就得由從神經網路的基礎開始，如果是一般的前回饋網路（feed-forward network）當中的隱藏層是像下列這個樣子：</p><p>$$<br>h_{t+1} = f(h_t, \theta)<br>$$</p><p>我們可以發現像是 ResNet 這類的網路有 skip connection 的設置，所以跟一般的前回饋網路不同</p><p>$$<br>h_{t+1} = h_t + f(h_t, \theta)<br>$$</p><p>而 RNN 等等有序列概念的模型也有類似的結構，就是會是前一層的結果加上通過 $f$ 運算後的結果，成為下一層的結果。</p><p>這樣的形式跟我們前面提到的形式不謀而合</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt}<br>$$</p><p>只要我們把 $\Delta = 1$ 代入，就成了</p><p>$$<br>y(t+1) = y(t) + \frac{dy}{dt}<br>$$</p><p>以下給大家比對一下</p><p>$$<br>h_{t+1} = h_t + f(h_t, \theta) \\<br>y(t+1) = y(t) + \frac{dy}{dt}<br>$$</p><p>也就是，我們可以讓</p><p>$$<br>\frac{dy}{dt} = f(h_t, \theta)<br>$$</p><p>神奇的事情就發生了！神經網路 $f$ 就可以被我們拿來計算微分 $\frac{dy}{dt}$！</p><p>比較精確的說法是，把神經網路的層 $f$ 拿來逼近微分項，或是說梯度。這樣我們後面就可以用數值方法來逼近解。</p><p>$$<br>y(t + \Delta) = y(t) + \Delta \frac{dy}{dt} \\<br>\downarrow \\<br>y(t + \Delta) = y(t) + \Delta f(t, h(t), \theta_t)<br>$$</p><p>要拉成連續的還有一個重要的手段，就是將不同的層 $t$ 從離散的變成連續的，所以作者將 $t$ 做了參數化，將他變成 $f$ 的參數之一，如此一來，就可以在任意的層中放入資料做運算。</p><p>最重要的概念導出了這樣的式子</p><p>$$<br>h(t) \rightarrow \frac{dy(t)}{dt} = f(h(t), t, \theta) \rightarrow y(t)<br>$$</p><h2 id="神經網路作為一個系統的微分形式"><a href="#神經網路作為一個系統的微分形式" class="headerlink" title="神經網路作為一個系統的微分形式"></a>神經網路作為一個系統的微分形式</h2><p>在傳統科學或是工程領域，我們會以微分式來表達以及建構一個系統。</p><p>$$<br>\nu = \frac{dx}{dt} = t + 1<br>$$</p><p>其實在這邊是一樣的道理，整體來說，我們是換成用神經網路去描述一個微分式，其實本質上就是這樣。</p><p>原本的層的概念就是用數學函數來建立的，而層與層之間傳遞著計算的結果。</p><p>$$<br>\mathbb{h_1} = \sigma(W_1 \mathbb{x} + \mathbb{b_1}) \\<br>\mathbb{y} = \sigma(W_2 \mathbb{h_1} + \mathbb{b_2})<br>$$</p><p>然而變成連續之後，我們等於是用神經網路中的層去建立跟描繪微分形式。</p><p>$$<br>\frac{d h(t)}{dt} = \sigma(W(t) \mathbb{x}(t) + \mathbb{b(t)}) \\<br>\frac{d y(t)}{dt} = \sigma(W(t) \mathbb{h}(t) + \mathbb{b(t)})<br>$$</p><p>是不是跟如出一轍呢？</p><p>$$<br>\frac{dy(t)}{dt} = f(h(t), t, \theta)<br>$$</p><h2 id="向前傳遞解微分式"><a href="#向前傳遞解微分式" class="headerlink" title="向前傳遞解微分式"></a>向前傳遞解微分式</h2><p>我們可以來計算看看隱藏層是長什麼樣子的。在隱藏層的微分式中，也是利用隱藏層去計算出來的。</p><p>$$<br>\frac{dh(t)}{dt} = f(h(t), t, \theta)<br>$$</p><p>基本上，我們只要對上式做積分就可以了。</p><p>$$<br>h(t) = \int f(h(t), t, \theta) dt<br>$$</p><p>這是一個怎樣的概念呢？我們可以來看看下圖。</p><p><img src="/images/hidden-state1.svg" alt=""></p><p>我們做積分這件事其實是用 $h(t_0)$ 來推斷 $h(t_1)$ 的，這跟神經網路的向前傳遞是一樣的行為。</p><p>$$<br>h(t_1) = F(h(t), t, \theta) \bigg|_{t=t_0}<br>$$</p><p>這樣的積分動作，我們可以用 $t_0$ 時間點的資訊來解 $h(t_1)$。</p><p>這樣的解法在程式上就會交由 ODE Solver 去處理。</p><p>$$<br>h(t_1) = ODESolve(h(t_0), t_0, t_1, \theta, f)<br>$$</p><h2 id="反向傳遞解函數"><a href="#反向傳遞解函數" class="headerlink" title="反向傳遞解函數"></a>反向傳遞解函數</h2><p>$$<br>\mathcal{L}(t_0, t, \theta) = \mathcal{L}(ODESolve(\cdot))<br>$$</p><p>$$<br>\frac{\partial \mathcal{L}}{\partial h(t)} = -a(t)<br>$$</p><p>adjoint state</p><p>$$<br>a(t) = \int -a(t)^T \frac{\partial f}{\partial h} dt = - \frac{\partial \mathcal{L}}{\partial h(t)}<br>$$</p><p>$$<br>a(t) = \int_{t_1}^{t_0} -a(t)^T \frac{\partial f(h(t), t, \theta)}{\partial h(t)} dt<br>$$</p><p><img src="/images/adjoint-state.svg" alt=""></p><h2 id="擴充狀態（augmented-state）"><a href="#擴充狀態（augmented-state）" class="headerlink" title="擴充狀態（augmented state）"></a>擴充狀態（augmented state）</h2><p>$\frac{d \theta}{dt} = 0$</p><p>$\frac{dt}{dt} = 1$</p><p>let $\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}$ be a augmented state</p><p>augmented state function:</p><p>$$<br>f_{aug}(\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}) =<br>\begin{bmatrix}<br>f(h(t), t, \theta) \\<br>0 \\<br>1<br>\end{bmatrix}<br>$$</p><p>augmented state dynamics:</p><p>$$<br>\frac{d}{dt}<br>\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix}<br>=<br>f_{aug}(<br>\begin{bmatrix}<br>h \\<br>\theta \\<br>t<br>\end{bmatrix})<br>$$</p><p>augmented adjoint state:</p><p>$$<br>\begin{bmatrix}<br>a \\<br>a_{\theta} \\<br>a_t<br>\end{bmatrix}<br>$$</p><p>$a = \frac{\partial \mathcal{L}}{\partial h}$</p><p>$a_{\theta} = \frac{\partial \mathcal{L}}{\partial \theta}$</p><p>$a_t = \frac{\partial \mathcal{L}}{\partial t}$</p><p>$$<br>\frac{d a_{aug}}{dt} = -<br>\begin{bmatrix}<br>a \frac{\partial f}{\partial h} \\<br>a \frac{\partial f}{\partial \theta} \\<br>a \frac{\partial f}{\partial t}<br>\end{bmatrix}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這篇被選為 NeurIPS 2018 最佳論文，他將連續的概念帶入了神經網路架構中，並且善用以往解微分方程的方法來做逼近，可以做到跟原方法（倒傳遞）一樣好的程度，而參數使用複雜度卻是常數，更短的訓練時間。&lt;/p&gt;
&lt;h2 id=&quot;核心觀念&quot;&gt;&lt;a href=&quot;#核心觀念&quot; 
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yuehhua.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>筆記 - 從向量空間到函數空間</title>
    <link href="https://yuehhua.github.io/2019/02/24/note-of-vector-space-to-function-space/"/>
    <id>https://yuehhua.github.io/2019/02/24/note-of-vector-space-to-function-space/</id>
    <published>2019-02-24T04:54:02.000Z</published>
    <updated>2019-02-24T04:54:02.908Z</updated>
    
    <content type="html"><![CDATA[<p>參考<a href="https://ccjou.wordpress.com/2009/08/18/%E5%BE%9E%E5%B9%BE%E4%BD%95%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93%E5%88%B0%E5%87%BD%E6%95%B8%E7%A9%BA%E9%96%93/" target="_blank" rel="noopener">從幾何向量空間到函數空間| 線代啟示錄</a>。</p><ol><li>由 $\mathbb{R}^n$ 拓展到 $\mathbb{R}^{\infty}$ 所需俱備的條件是什麼？</li></ol><p>由於一個向量 $\mathbb{v} \in \mathbb{R}^{\infty}$，在無限維度下我們需要考慮一個問題，就是 norm。</p><p>如果這個空間有定義 norm 的話，我們就要考慮他有沒有收斂，也就是 $||\mathbb{v}||^2$ 要存在。</p><p>所以條件就是</p><p>$$<br>||\mathbb{v}||^2 = \sum_{i=1}^{\infty} v_i^2<br>$$</p><p>要收斂。</p><ol start="2"><li>從 $\mathbb{R}^{\infty}$ 無限維度的向量空間再拓展到 $C^{\omega}$ 函數空間，所需要俱備的條件是什麼？</li></ol><p>一個無限維度的向量是一個離散的版本，由剛剛的式子可以看的出來</p><p>$$<br>||\mathbb{v}||^2 = \sum_{i=1}^{\infty} v_i^2<br>$$</p><p>而一個（解析）函數則是連續的</p><p>$$<br>||f||^2 = \int f^2(x) dx<br>$$</p><p>除了以上的 norm 要收斂外，從離散到連續應該有些假設或是條件才是。</p><ol start="3"><li>函數的基底</li></ol><p>Fourier series</p><p>$$<br>f(x) = a_0 + a_1 \cos x + b_1 \sin x + a_2 \cos 2x + b_2 \sin 2x + \cdots<br>$$</p><p>所以基底就是</p><p>$$<br>&lt;\beta&gt; = &lt;1, \cos x, \sin x, \cos 2x, \sin 2x, \cdots&gt;<br>$$</p><ol start="4"><li>非週期性函數基底</li></ol><p>Legendre polynomial</p><ol start="5"><li>Least square problem</li></ol><p>$$<br>(A^TA)\hat{y} = A^Tb<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;參考&lt;a href=&quot;https://ccjou.wordpress.com/2009/08/18/%E5%BE%9E%E5%B9%BE%E4%BD%95%E5%90%91%E9%87%8F%E7%A9%BA%E9%96%93%E5%88%B0%E5%87%BD%E6%95
      
    
    </summary>
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>在參數化型別中使用值的效能分析</title>
    <link href="https://yuehhua.github.io/2019/02/22/performance-analysis-of-value-in-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/02/22/performance-analysis-of-value-in-parametric-type/</id>
    <published>2019-02-22T04:24:37.000Z</published>
    <updated>2019-09-06T03:20:20.510Z</updated>
    
    <content type="html"><![CDATA[<p>我在使用的時候有注意到<em>在參數化型別中使用值</em>的方式與<em>傳統封裝</em>的方式有效能上的差異。</p><p>所以我就做了一些測試。</p><p>在參數化型別中使用值：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>傳統型別封裝：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> B</span><br><span class="line">    x::<span class="built_in">Int64</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>全文出現的程式碼為實際測試程式碼</em></p><p>因為 Julia 有提供好用的 <code>@code_llvm</code> 及 <code>@code_native</code> 來觀察一行程式碼實際被轉換成 LLVM 或是組合語言的時候會產生多少行的程式碼，藉此我們可以用低階程式碼來評估是否有效率。程式碼的行數愈少是越有效率的。</p><h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>我們來測試一個物件被建立需要多少行的程式碼。</p><h3 id="A-LLVM"><a href="#A-LLVM" class="headerlink" title="A - LLVM"></a>A - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[1]:3 within `Type'</span></span><br><span class="line"><span class="comment">define nonnull %jl_value_t addrspace(10)* @japi1_Type_12238(%jl_value_t addrspace(10)*, %jl_value_t addrspace(10)**, i32) #0 &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  %3 = alloca %jl_value_t addrspace(10)**, align 8</span></span><br><span class="line"><span class="comment">  store volatile %jl_value_t addrspace(10)** %1, %jl_value_t addrspace(10)*** %3, align 8</span></span><br><span class="line"><span class="comment">  ret %jl_value_t addrspace(10)* addrspacecast (%jl_value_t* inttoptr (i64 140407726014496 to %jl_value_t*) to %jl_value_t addrspace(10)*)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="B-LLVM"><a href="#B-LLVM" class="headerlink" title="B - LLVM"></a>B - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[1]:2 within `Type'</span></span><br><span class="line"><span class="comment">define &#123; i64 &#125; @julia_Type_12221(%jl_value_t addrspace(10)*, i64) &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  %.fca.0.insert = insertvalue &#123; i64 &#125; undef, i64 %1, 0</span></span><br><span class="line"><span class="comment">  ret &#123; i64 &#125; %.fca.0.insert</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="A-Assembly"><a href="#A-Assembly" class="headerlink" title="A - Assembly"></a>A - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[1]:3 within `Type&apos;</span><br><span class="line">movq%rsi, -8(%rsp)</span><br><span class="line">movabsq$140407726014496, %rax  # imm = 0x7FB338A20020</span><br><span class="line">retq</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h3 id="B-Assembly"><a href="#B-Assembly" class="headerlink" title="B - Assembly"></a>B - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[1]:2 within `Type&apos;</span><br><span class="line">movq%rsi, %rax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>接著測試從物件當中取值出來的效能。</p><p>定義取值的方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_value(::A&#123;T&#125;) <span class="keyword">where</span> &#123;T&#125; = T</span><br><span class="line">get_value(b::B) = b.x</span><br></pre></td></tr></table></figure><p>事先建立好物件：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = A&#123;<span class="number">5</span>&#125;()</span><br><span class="line">b = B(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="A-LLVM-1"><a href="#A-LLVM-1" class="headerlink" title="A - LLVM"></a>A - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> get_value(a)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[8]:1 within `get_value'</span></span><br><span class="line"><span class="comment">define i64 @julia_get_value_12274() &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">  ret i64 5</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="B-LLVM-1"><a href="#B-LLVM-1" class="headerlink" title="B - LLVM"></a>B - LLVM</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_llvm</span> get_value(b)</span><br></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;  @ REPL[5]:1 within `get_value'</span></span><br><span class="line"><span class="comment">define i64 @julia_get_value_12630(&#123; i64 &#125; addrspace(11)* nocapture nonnull readonly dereferenceable(8)) &#123;</span></span><br><span class="line"><span class="comment">top:</span></span><br><span class="line"><span class="comment">; ┌ @ sysimg.jl:18 within `getproperty'</span></span><br><span class="line"><span class="comment">   %1 = getelementptr inbounds &#123; i64 &#125;, &#123; i64 &#125; addrspace(11)* %0, i64 0, i32 0</span></span><br><span class="line"><span class="comment">; └</span></span><br><span class="line"><span class="comment">  %2 = load i64, i64 addrspace(11)* %1, align 8</span></span><br><span class="line"><span class="comment">  ret i64 %2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="A-Assembly-1"><a href="#A-Assembly-1" class="headerlink" title="A - Assembly"></a>A - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> get_value(a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[8]:1 within `get_value&apos;</span><br><span class="line">movl$5, %eax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><h3 id="B-Assembly-1"><a href="#B-Assembly-1" class="headerlink" title="B - Assembly"></a>B - Assembly</h3><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@code_native</span> get_value(b)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; ┌ @ REPL[5]:1 within `get_value&apos;</span><br><span class="line">movq(%rdi), %rax</span><br><span class="line">retq</span><br><span class="line">nopw%cs:(%rax,%rax)</span><br><span class="line">; └</span><br></pre></td></tr></table></figure><p>給大家參考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我在使用的時候有注意到&lt;em&gt;在參數化型別中使用值&lt;/em&gt;的方式與&lt;em&gt;傳統封裝&lt;/em&gt;的方式有效能上的差異。&lt;/p&gt;
&lt;p&gt;所以我就做了一些測試。&lt;/p&gt;
&lt;p&gt;在參數化型別中使用值：&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>在參數化型別中定義值</title>
    <link href="https://yuehhua.github.io/2019/02/22/define-values-in-parametric-type/"/>
    <id>https://yuehhua.github.io/2019/02/22/define-values-in-parametric-type/</id>
    <published>2019-02-21T17:22:42.000Z</published>
    <updated>2019-09-06T03:21:46.486Z</updated>
    
    <content type="html"><![CDATA[<p>應該不少人看到這個標題會摸不著頭緒到底要做什麼，但是看完 Julia 中常見的程式碼你就會了解了。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>&#123;<span class="built_in">Any</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>有沒有曾經納悶過那個數字 2 到底是怎麼進到參數的位置上的呢？</p><p>參數的位置不是只能放型別（type）嗎？</p><p>這同時也是我困惑已久的問題，就搜尋了一下，果不其然被我找到了方法：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;T&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&#123;<span class="number">5</span>&#125;()</span><br></pre></td></tr></table></figure><p>原來這麼簡單就可以完成了！語法上並沒有限定一定要是<em>型別</em>，要放型別以外的東西似乎是可以的。</p><p>我目前測試了可以的有：Int64、Float64、Complex、Char、Bool、Symbol，所以估計數字應該都是可以的。</p><p>不行的有：String、Array，估計物件或是陣列都是不行的。</p><h2 id="定義範圍"><a href="#定義範圍" class="headerlink" title="定義範圍"></a>定義範圍</h2><p>不過使用上並沒有任何限制會有點危險，所以還是定義一下範圍會比較好，像是：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;<span class="literal">I</span>&#125;</span><br><span class="line">    <span class="keyword">function</span> A&#123;<span class="literal">I</span>&#125;() <span class="keyword">where</span> &#123;<span class="literal">I</span>&#125;</span><br><span class="line">        <span class="keyword">isa</span>(<span class="literal">I</span>,<span class="built_in">Integer</span>) || error(<span class="string">"bad parameter"</span>)</span><br><span class="line">        new()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>這樣就可以限制參數要是整數的範圍。</p><h2 id="從參數取值"><a href="#從參數取值" class="headerlink" title="從參數取值"></a>從參數取值</h2><p>那我們能不能從型別的參數當中取值呢？</p><p>可以。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_value(::A&#123;<span class="literal">I</span>&#125;) <span class="keyword">where</span> A&#123;<span class="literal">I</span>&#125; = <span class="literal">I</span></span><br></pre></td></tr></table></figure><p>如此一來，我們就可以從型別中拿到值了。</p><h2 id="好處？"><a href="#好處？" class="headerlink" title="好處？"></a>好處？</h2><p>這麼做有什麼好處？</p><p>當你把值的資訊放到型別當中，型別就多了一些資訊可以提供編譯器處理，這對於要自己設計型別階層可是非常好用的。</p><p>例如像是你可以將陣列的長度資訊儲存到型別上，這樣編譯器就可以處理陣列的長度資訊了。</p><p>這樣的程式風格會跟 dependent type language 有些相似了。</p><p>大家可以玩玩看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;應該不少人看到這個標題會摸不著頭緒到底要做什麼，但是看完 Julia 中常見的程式碼你就會了解了。&lt;/p&gt;
&lt;figure class=&quot;highlight julia&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Computer Science" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/"/>
    
      <category term="Julialang" scheme="https://yuehhua.github.io/categories/My-Style/Computer-Science/Julialang/"/>
    
    
  </entry>
  
  <entry>
    <title>Note - Mathematical objects</title>
    <link href="https://yuehhua.github.io/2019/02/06/mathematical-objects/"/>
    <id>https://yuehhua.github.io/2019/02/06/mathematical-objects/</id>
    <published>2019-02-05T16:02:53.000Z</published>
    <updated>2019-02-05T16:02:53.088Z</updated>
    
    <content type="html"><![CDATA[<p>20th century Cantor:</p><blockquote><p>All mathematical objects can be defined as sets.</p></blockquote><p>Fundamentals:</p><ul><li>numbers</li><li>permutations</li><li>partitions</li><li>matrices</li><li>sets</li><li>functions</li><li>relations</li></ul><p>Geometry:</p><ul><li>hexagons</li><li>points</li><li>lines</li><li>triangles</li><li>circles</li><li>spheres</li><li>polyhedra</li><li>topological space</li><li>manifolds</li></ul><p>Algebra:</p><ul><li>groups</li><li>rings</li><li>fields</li><li>lattices</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;20th century Cantor:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;All mathematical objects can be defined as sets.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Fundamentals:&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>生物資訊的初衷</title>
    <link href="https://yuehhua.github.io/2019/02/01/original-intention-to-bioinformatics/"/>
    <id>https://yuehhua.github.io/2019/02/01/original-intention-to-bioinformatics/</id>
    <published>2019-01-31T16:25:47.000Z</published>
    <updated>2019-01-31T16:25:47.679Z</updated>
    
    <content type="html"><![CDATA[<p>受到其他文章的啟發，我也來寫一篇為什麼我踏入生物資訊領域好了。</p><p>受到啟發應該算是從高中的時候說起，高中的時候喜歡數學、物理跟生物。對於數學，喜歡他的抽象及純粹，而物理可以解釋這個世界的法則，對於生物則是一直以來隱隱約約有些感覺的。小時候對於生命現象一直很好奇，對於生物的多樣性感到驚奇，但到了高中卻成了考卷上的考題，我不認為那是我要的。</p><p>還記得高中生物上到下視丘的時候會講到很多不同種的激素調控，我突然覺得這一切的背後似乎有著什麼，我對「調控」產生了興趣。接著到了高中快結束，終於上到近代的生物技術以及 DNA 分子的轉錄轉譯，雖然對當時的我來說有點複雜，但是我喜歡挑戰理解這種複雜的事物，我將他轉化成比較好理解的「設計圖」解釋。DNA 就像是一台車子的整體設計圖，RNA 就是將設計圖的一部份零件複製一份出來，並且製造出蛋白質，也就是真實的零件。理解了這些讓我非常開心。</p><p>大學念了醫學檢驗生物技術，但卻不是我的第一志願，不過我確定我對生物技術是有興趣的，我也非常認真對待我的選擇。在傳統的生物醫學研究都是花了十幾年的時間在研究一個蛋白或是一個基因的功能或是交互作用。</p><p>我大三的某天在逛維基百科（你沒看錯，我會去逛維基百科）被我發現了系統生物學這個領域，看到頁面的當下非常震驚，可以以一個系統的觀點切入生物的議題，那麼就可以不用那麼辛苦的一個基因一個基因研究了。而且系統的概念直接串起了在生化中學到的調控，他不只是 pathway，而是一個複雜的網路，可以藉由網路的調控或是反應機制，讓生物體做出特定的行為。生物體就是個巨大的機械，但是複雜度卻遠高於機械，也不像機構那樣那麼容易理解，很多事情是人類目前還不知道的。</p><p>因為這樣的未知，這樣的複雜，這樣的調控系統，讓我決心研究所要往這個方向走。</p><p>大四的時候有進階生物技術，接觸到定序技術、生物資訊、序列處理的議題。同時雙主修資訊工程，我更享受在資工系的課程當中，雖然他講的是程式、作業系統等等，但是對於（建造）系統的概念始終是保留的。我最有興趣的大概是離散數學、演算法跟訊號與系統了，離散數學中的圖論可以說是非常神妙，而圖論的用途也超級廣，可以拿來 model 很多不同的事物。演算法則是去證明一件事情可以被如何的完成是最快的，這些魔法都來自於數學。訊號與系統講述了如何去探知或是解析一個系統，我們怎麼從一個系統的行為當中去反推這個系統的架構。</p><p>到研究所真正接觸了生物資訊與我的認知相去不遠，不過還是少了點什麼，看了看課程發現了機器學習的課程，也詢問了學長關於這個領域，聽說還蠻推薦的，但是受限於開課時間，就乾脆自己去找了 coursera 上林軒田老師的機器學習課程看，大概一個月左右就把他看完了。看的當下非常開心，學到了跟演算法非常相似的技術，而當時大數據剛開始紅，所以就以這個技術為主軸開始了我的研究。</p><p>殊不知，後來的深度學習的崛起，AI 的爆紅，讓機器學習變得異常的熱門。不過我還是希望繼續做系統生物學，應該說是計算生物學。來把這迷樣的生物系統 model 出來吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;受到其他文章的啟發，我也來寫一篇為什麼我踏入生物資訊領域好了。&lt;/p&gt;
&lt;p&gt;受到啟發應該算是從高中的時候說起，高中的時候喜歡數學、物理跟生物。對於數學，喜歡他的抽象及純粹，而物理可以解釋這個世界的法則，對於生物則是一直以來隱隱約約有些感覺的。小時候對於生命現象一直很好奇，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>溫柔而強大</title>
    <link href="https://yuehhua.github.io/2019/01/19/kindness-and-powerful/"/>
    <id>https://yuehhua.github.io/2019/01/19/kindness-and-powerful/</id>
    <published>2019-01-19T15:07:41.000Z</published>
    <updated>2019-01-19T16:10:25.149Z</updated>
    
    <content type="html"><![CDATA[<p>已經好一段時間沒有用文章紀錄下自己的心情跟想法了。</p><p>這段期間都在專注寫技術文章。</p><a id="more"></a><p>在 2018 年 5 月剛好興趣參與了 Pytorch Taichung 的社群聚會，當時其實只是想去看看 Deep learning 技術發展到什麼階段了，自己當時也讀了一些進階的論文，像是 Attention model。</p><p>第一場是我給的開場演講，介紹了機器學習的概論。記得當時的主持人是生澀的副社長敬宇，以國際演討會的規格介紹整個流程，看來不是怎麼熟練，卻很有精神。</p><p>在經營社群來說，我也在群眾前演講一段時間了。一般社群小聚互動其實沒有那麼拘謹，我也就輕鬆開始我的演講。</p><p>記得演講結束之後，大家不太發言，是由副社問了 dropout 機制的問題，展開了一系列的討論。</p><p>往後一直到我出了我第一本書，這本書成為一個契機。敬宇跟我敲碗很久了，也就剛好拿到書的那個禮拜就有機會拿給他，就一起吃了午餐。</p><p>兩個人聊的很開心，也不顧時間到了，依依不捨。記得他下午還要趕去做實驗呢。</p><p>以往社群的人很欣賞我論文的報告，不流於形式，好理解，敬宇更是成為了迷弟。</p><p>後來就成為了很要好的朋友，無所不聊，從數學物理電腦到經濟哲學價值觀。</p><p>慢慢了解到敬宇的一些事情，發現他是需要幫助的孩子。</p><p>表面上沈默，私底下非常努力的孩子，慢熟而堅強。</p><p>身為好友應該可以給一些支援，雖然他很少主動開口。</p><p>對我而言，有能力幫助別人也是一種成功，成為一個 Giver。</p><p>一個溫柔而強大的 Giver。</p><p>大概是我這一年目標想做的的事情吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已經好一段時間沒有用文章紀錄下自己的心情跟想法了。&lt;/p&gt;
&lt;p&gt;這段期間都在專注寫技術文章。&lt;/p&gt;
    
    </summary>
    
      <category term="My Style" scheme="https://yuehhua.github.io/categories/My-Style/"/>
    
      <category term="Friends" scheme="https://yuehhua.github.io/categories/My-Style/Friends/"/>
    
    
  </entry>
  
  <entry>
    <title>The Deterministic Information Bottleneck</title>
    <link href="https://yuehhua.github.io/2019/01/18/deterministic-information-bottleneck/"/>
    <id>https://yuehhua.github.io/2019/01/18/deterministic-information-bottleneck/</id>
    <published>2019-01-18T03:39:06.000Z</published>
    <updated>2019-01-19T16:10:31.676Z</updated>
    
    <content type="html"><![CDATA[<p>在 Information Bottleneck 之後出現了不少驚豔的呼喊，也出現了指出這個方法的缺點及詮釋錯誤。</p><p>在這之後有人專注在確定性這件事上。</p><a id="more"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/-D5b_zCJxrs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><pre class="mermaid">graph LR    X -->|"p(x, y)"|Y    X -->|"q(t|x)"|T    T --- Y    X((X))    Y((Y))    T((T))</pre><p>$T$:</p><ul><li>soft sufficient statistics (for statistics)</li><li>lossy compression (for signal)</li><li>maximally informative clustering (for machine learning)</li></ul><h2 id="IB"><a href="#IB" class="headerlink" title="IB"></a>IB</h2><p>$$<br>min\ \mathcal{L} [q(t|x)] = I(T; X) - \beta I(T; Y), \beta &gt; 0<br>$$</p><p>$I(T; X)$: compression<br>$I(T; Y)$: relevance</p><p>Markov constraint: $T \leftarrow X \leftrightarrow Y$</p><p>$$<br>q(t|x) = \frac{q(t)}{Z(x, \beta)} exp(- \beta D_{KL} [p(y|x) || q(y|t)])) \\<br>q(t) = \sum_x p(x)q(t|x) \\<br>q(y|t) = \frac{1}{q(t)} \sum_x p(y|x)q(t|x)p(x)<br>$$</p><p>$I(T; X)$ from channel coding, rate distortion theory</p><h2 id="DIB"><a href="#DIB" class="headerlink" title="DIB"></a>DIB</h2><p>$$<br>min\ \mathcal{L} [q(t|x)] = H(T) - \beta I(T; Y)<br>$$</p><p>$H(T)$: penalize coding itself<br>$I(T; Y)$: lead to deterministic $\mathcal{L}_{IB}$</p><p>$$<br>\mathcal{L} _{IB} - \mathcal{L} _{DIB} = I(T; X) - H(T) = -H(T|X)<br>$$</p><p>$\mathcal{L}_{IB}$: implicit encourage of stochastic</p><h2 id="Generalized-IB"><a href="#Generalized-IB" class="headerlink" title="Generalized IB"></a>Generalized IB</h2><p>$$<br>\mathcal{L}_{\alpha} = H(T) - \alpha H(T|X) - \beta I(Y; T)<br>$$</p><p>$\alpha = 1 \Rightarrow \mathcal{L} _{IB}$: stochastic $\rightarrow$ soft clustering<br>$\alpha = 0 \Rightarrow \mathcal{L} _{DIB}$: deterministic $\rightarrow$ hard clustering</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Information Bottleneck 之後出現了不少驚豔的呼喊，也出現了指出這個方法的缺點及詮釋錯誤。&lt;/p&gt;
&lt;p&gt;在這之後有人專注在確定性這件事上。&lt;/p&gt;
    
    </summary>
    
      <category term="Deep Learning" scheme="https://yuehhua.github.io/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>共形映射</title>
    <link href="https://yuehhua.github.io/2019/01/16/conformal-map/"/>
    <id>https://yuehhua.github.io/2019/01/16/conformal-map/</id>
    <published>2019-01-16T06:22:27.000Z</published>
    <updated>2019-01-16T06:41:37.404Z</updated>
    
    <content type="html"><![CDATA[<p>$<br>\Omega \subset \mathbb{R}^2, f: \Omega \rightarrow \mathbb{R}^2<br>$</p><p>$$<br>f(x, y) = (u(x, y), v(x, y))<br>$$</p><p>$$<br>J(x, y) =<br>\begin{bmatrix}<br>\frac{\partial u}{\partial x}&amp; \frac{\partial u}{\partial y} \\<br>\frac{\partial v}{\partial x}&amp; \frac{\partial v}{\partial y}<br>\end{bmatrix}<br>$$</p><p>$<br>(x, y) \in \Omega, J(x, y) = s(x, y)R(x, y)<br>$</p><p>$s$ is a non-zero scalar.</p><p>$R$ is a $2 \times 2$ rotation matrix.</p><h5 id="mathcal-prop"><a href="#mathcal-prop" class="headerlink" title="$\mathcal{prop.}$"></a>$\mathcal{prop.}$</h5><ol><li>$f: \Omega \rightarrow \mathbb{R}^2 \text{ and } g: f(\Omega) \rightarrow \mathbb{R}^2$ are conformal map, then $g \circ f$ is conformal map</li><li>$f: \Omega \rightarrow \mathbb{R}^2$ is conformal map, $f^{-1}$ is conformal map</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$&lt;br&gt;\Omega \subset \mathbb{R}^2, f: \Omega \rightarrow \mathbb{R}^2&lt;br&gt;$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;f(x, y) = (u(x, y), v(x, y))&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;J(
      
    
    </summary>
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>保角映射</title>
    <link href="https://yuehhua.github.io/2019/01/16/angle-preserving-map/"/>
    <id>https://yuehhua.github.io/2019/01/16/angle-preserving-map/</id>
    <published>2019-01-16T03:47:36.000Z</published>
    <updated>2019-01-16T06:33:29.124Z</updated>
    
    <content type="html"><![CDATA[<h5 id="mathcal-Def"><a href="#mathcal-Def" class="headerlink" title="$\mathcal{Def.}$"></a>$\mathcal{Def.}$</h5><p>$A$ 為保角映射（angle-preserving map）</p><p>$$<br>\frac{(Ax)^T(Ay)}{||Ax|| \cdot ||Ay||} = \frac{x^Ty}{||x|| \cdot ||y||} \\<br>(\Rightarrow A\text{ is invertible})<br>$$</p><p>$$<br>\Rightarrow A = sQ, Q^TQ = I, s \ne 0<br>$$</p><p>$s$ 代表伸縮量</p><p>$det Q = 1$: 伸縮 + 旋轉<br>$det Q = -1$: 伸縮 + 鏡射</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;mathcal-Def&quot;&gt;&lt;a href=&quot;#mathcal-Def&quot; class=&quot;headerlink&quot; title=&quot;$\mathcal{Def.}$&quot;&gt;&lt;/a&gt;$\mathcal{Def.}$&lt;/h5&gt;&lt;p&gt;$A$ 為保角映射（angle-preservi
      
    
    </summary>
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>等距同構</title>
    <link href="https://yuehhua.github.io/2019/01/16/isometry/"/>
    <id>https://yuehhua.github.io/2019/01/16/isometry/</id>
    <published>2019-01-16T03:47:19.000Z</published>
    <updated>2019-01-16T06:07:41.143Z</updated>
    
    <content type="html"><![CDATA[<p>let $A \in \mathbb{R}^{n \times n}, f(x) = Ax$</p><p>$A$ 為保長映射（length-preserving map）或等距同構（isometry），以下為等價定義方式：</p><h5 id="mathcal-Def"><a href="#mathcal-Def" class="headerlink" title="$\mathcal{Def}$."></a>$\mathcal{Def}$.</h5><ol><li>$A$ is orthogonal matrix</li><li>$||Ax|| = ||x||$</li><li>$||Ax - Ay|| = ||x - y||$</li><li>$(Ax)^T(Ay) = x^Ty$</li></ol><p>$\Rightarrow$ 旋轉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;let $A \in \mathbb{R}^{n \times n}, f(x) = Ax$&lt;/p&gt;
&lt;p&gt;$A$ 為保長映射（length-preserving map）或等距同構（isometry），以下為等價定義方式：&lt;/p&gt;
&lt;h5 id=&quot;mathcal-Def&quot;
      
    
    </summary>
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>Functional</title>
    <link href="https://yuehhua.github.io/2019/01/15/functional/"/>
    <id>https://yuehhua.github.io/2019/01/15/functional/</id>
    <published>2019-01-15T12:34:54.000Z</published>
    <updated>2019-09-06T03:22:22.301Z</updated>
    
    <content type="html"><![CDATA[<p>一般我們數學上稱 $f: \mathbb{R} \rightarrow \mathbb{R}$ 為函數 function。</p><p>然而，如果一個函數可以接受另一個函數作為他的輸入變數，而輸出是一個純量，$F: S \rightarrow \mathbb{R}$ 泛函 functional，其中 $S$ 是一個向量空間，函數是一種廣義的向量。</p><p>在最佳化理論或是機器學習當中最常遇到的就是損失函數 $\mathcal{L}$，他其實是一個泛函。</p><p>$$<br>\mathcal{L}[f] = \frac{1}{N} \sum_{i=1}^{N} (y_i - f(x_i))^2<br>$$</p><p>當我們有不同的資料，需要計算這些資料的 mean square error 的時候就會寫成像上面這個樣子。</p><p>$$<br>\mathcal{L}[f] = \lim_{n \rightarrow \infty} \int_b^a |f(x) - \sum_{i=1}^N a_i f_i(x)|^2 dx<br>$$</p><p>如果我們處理的不是資料，而是一段連續的空間，那我們就可以用以上這個連續的版本。</p><blockquote><p>ex.</p></blockquote><p>consider $X, Y \in V$</p><ol><li>$g: X \rightarrow \mathbb{R}$ is functional</li><li>$g: X \rightarrow \mathbb{R}^n$ is functional</li><li>$g: X \rightarrow Y$ is operator</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般我們數學上稱 $f: \mathbb{R} \rightarrow \mathbb{R}$ 為函數 function。&lt;/p&gt;
&lt;p&gt;然而，如果一個函數可以接受另一個函數作為他的輸入變數，而輸出是一個純量，$F: S \rightarrow \mathbb{R}$ 泛函
      
    
    </summary>
    
      <category term="Math" scheme="https://yuehhua.github.io/categories/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>Compare Clustering and Embedding</title>
    <link href="https://yuehhua.github.io/2019/01/15/compare-clustering-and-embedding/"/>
    <id>https://yuehhua.github.io/2019/01/15/compare-clustering-and-embedding/</id>
    <published>2019-01-15T01:10:33.000Z</published>
    <updated>2019-01-15T01:22:16.348Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th>Clustering</th><th>Embedding</th></tr></thead><tbody><tr><td>Target space</td><td>discrete</td><td>continuous</td></tr><tr><td>Target dimension</td><td>$d$</td><td>$\mathbb{R}^d$</td></tr><tr><td>Transformed result can be</td><td>composable</td><td>correlated</td></tr><tr><td>Assumption</td><td>globally static context (dataset)</td><td>globally dynamic context (dataset)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Clustering&lt;/th&gt;
&lt;th&gt;Embedding&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Target space&lt;/td&gt;
&lt;td&gt;discrete&lt;/td&gt;
&lt;t
      
    
    </summary>
    
      <category term="Machine Learning" scheme="https://yuehhua.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>方均根、標準差、馬克士威-波茲曼分佈</title>
    <link href="https://yuehhua.github.io/2018/12/20/rms-and-variance/"/>
    <id>https://yuehhua.github.io/2018/12/20/rms-and-variance/</id>
    <published>2018-12-19T16:19:39.000Z</published>
    <updated>2019-01-01T13:24:51.817Z</updated>
    
    <content type="html"><![CDATA[<p>不久前跟好朋友聊天聊到 random walk 的問題，一個醉漢會在一維的空間上隨機往前或往後走一步。</p><p>這樣的話，他最後會走到哪裡去呢？</p><a id="more"></a><p>基本上如果有看過隨機過程的話，會知道當 $n \rightarrow \infty$ 的時候會收斂到原點。</p><h2 id="平均位移"><a href="#平均位移" class="headerlink" title="平均位移"></a>平均位移</h2><p>如果我們考慮走了 $N$ 步之後的位移 $S$</p><p>$$<br>S = \sum_{i=1}^{N} x_i<br>$$</p><p>那麼平均位移說起來就是</p><p>$$<br>\mathbb{E}[S] = \mathbb{E}[\sum_{i=1}^{N} x_i] = \sum_{i=1}^{N} \mathbb{E}[x_i]<br>$$</p><p>當中的 $\mathbb{E}[x_i]$，由於每次要不是往前走一步或是往後退一步，而且兩者發生的機率一樣，所以每步的位移平均是 0，所以整體平均位移也是 0。</p><p>$$<br>\mathbb{E}[S] = 0<br>$$</p><p>如果你真的用電腦跑模擬，去紀錄多次走 5000 步（或是更多）最終的位移會是多少。</p><p>如此一來，你會得到一個以 0 為平均的常態分佈曲線。</p><h2 id="有沒有更有意義的資訊？"><a href="#有沒有更有意義的資訊？" class="headerlink" title="有沒有更有意義的資訊？"></a>有沒有更有意義的資訊？</h2><p>我們除了可以看平均以外還可以看什麼？</p><p>我們或許可以看位移平方後的平均</p><p>$$<br>\mathbb{E}[S^2] = \mathbb{E}[(\sum_{i=1}^{N} x_i)^2] \\<br>= \mathbb{E}[(x_1 + x_2 + \dots + x_N)^2] \\<br>= \mathbb{E}[(x_1^2 + x_2^2 + \dots + x_N^2) + 2(x_1x_2 + x_1x_3 + \dots + x_{N-1}x_N)] \\<br>= \mathbb{E}[x_1^2] + \mathbb{E}[x_2^2] + \dots + \mathbb{E}[x_N^2] + 2(\mathbb{E}[x_1x_2] + \mathbb{E}[x_1x_3] + \dots + \mathbb{E}[x_{N-1}x_N)]) \\<br>$$</p><p>如同前面的假設，如果我們將位移給平方了，那我們會得到每一項都是 1。至於相乘項的部份，可以自己動手試試看計算比較小的組合，不過理論上會是 0。</p><p>$$<br>= 1 + 1 + \dots + 1 + 2(0 + 0 + \dots + 0) \\<br>= N<br>$$</p><p>我們得到了位移平方後的平均是 $N$！</p><h2 id="方均根"><a href="#方均根" class="headerlink" title="方均根"></a>方均根</h2><p>大家可能在高中物理中聽到方均根（root-mean-square）這個計算方式，我們也可以求得方均根位移。</p><p>只要再開個根號就可以了，$\sqrt{\mathbb{E}[S^2]} = \sqrt{N}$。</p><p>這東西是不是看起來跟統計上的標準差很像呢？</p><p>$$<br>\sigma = \sqrt{Var[X]} = \sqrt{\frac{1}{N} \sum_{i=1}^{N} (x - \mu)^2}<br>$$</p><p>大概差別只會在於裏面有沒有把 $\mu$ 給減掉而已，不過也可以藉由將 $\mu$ 設定成 0 來達到同樣的效果。</p><p>意思也就是說，當醉漢走了 $N$ 步之後，會呈現一個常態分佈，而平均值是 0，標準差則是 $\sqrt{N}$。</p><p>也就是當醉漢走愈多步，終究會回歸原點，但是也會有機率距離原點一段距離，而這段距離會隨著步數的增加而變長。</p><p>在隨機過程中，這是個很經典的問題。</p><p>既然談到了方均根，就不難聯想到高中物理中講到的方均根速度。</p><h2 id="氣體動力論"><a href="#氣體動力論" class="headerlink" title="氣體動力論"></a>氣體動力論</h2><p>在氣體動力論當中，我們可以去計算一個空間中的氣體分子運動速度，以方均根的形式表示</p><p>$$<br>v_{rms} = \sqrt{\frac{3kT}{m}}<br>$$</p><p>而這個氣體速度會呈現一個分佈情形，稱為馬克士威-波茲曼速率分佈。</p><h2 id="馬克士威-波茲曼速率分佈"><a href="#馬克士威-波茲曼速率分佈" class="headerlink" title="馬克士威-波茲曼速率分佈"></a>馬克士威-波茲曼速率分佈</h2><p>我們可以從維基百科上找到以下的速度分佈。</p><blockquote><p>Maxwell–Boltzmann velocity distribution</p></blockquote><p>$$<br>f(\nu_x, \nu_y, \nu_z) = (\frac{m}{2 \pi kT})^{3/2} exp \big[ - \frac{m(\nu_x^2 + \nu_y^2 + \nu_z^2)}{2kT} \big]<br>$$</p><p>他描述了一個氣體分子在三維空間上有 $\nu_x, \nu_y, \nu_z$ 三種不同的速度分量，可以利用這些分量來計算出整體的速度分佈情形。</p><p>不覺得上式跟常態分佈有點相似嗎？</p><p>來呼叫一下常態分佈。</p><p>$$<br>f(x; \mu, \sigma) = \frac{1}{\sqrt{2 \pi} \sigma} exp \big[ - \frac{(x - \mu)^2}{2 \sigma^2} \big]<br>$$</p><p>那我們來動動手，做點簡單的驗證吧！</p><p>$$<br>f(\nu_x, \nu_y, \nu_z) = (\frac{m}{2 \pi kT})^{3/2} exp \big[ - \frac{m(\nu_x^2 + \nu_y^2 + \nu_z^2)}{2kT} \big] \\<br>= (\frac{1}{\sqrt{2 \pi} \sqrt{\frac{kT}{m}} })^3 exp \big[ - \frac{(\nu_x^2 + \nu_y^2 + \nu_z^2)}{2 (\sqrt{\frac{kT}{m}})^2 } \big]<br>$$</p><p>我們做點簡單的整理，然後將標準差抓出來。</p><p>let $\sigma = \sqrt{\frac{kT}{m}}$</p><p>代入之後就會成為</p><p>$$<br>= (\frac{1}{\sqrt{2 \pi} \sigma })^3 exp \big[ - \frac{(\nu_x^2 + \nu_y^2 + \nu_z^2)}{2 \sigma^2 } \big]<br>$$</p><p>是不是變得更像了呢？那麼指數項中的速度平方和怎麼處理？</p><p>當然是把指數拆開囉！</p><p>$$<br>= \big ( \frac{1}{\sqrt{2 \pi} \sigma } exp [ - \frac{\nu_x^2}{2 \sigma^2 } ] \big)<br>\big ( \frac{1}{\sqrt{2 \pi} \sigma } exp [ - \frac{\nu_y^2}{2 \sigma^2 } ] \big)<br>\big ( \frac{1}{\sqrt{2 \pi} \sigma } exp [ - \frac{\nu_z^2}{2 \sigma^2 } ] \big)<br>$$</p><p>我們會發現馬克士威-波茲曼速率分佈其實是三個常態分佈的乘積，或是多元常態分佈（Multivariate normal distribution）！</p><p>$$<br>= f_x \cdot f_y \cdot f_z<br>$$</p><p>三個常態分佈各是對映三維空間中的三個速度分量，也就是不同速度分量之間是各自獨立，不互相影響的。</p><p>跟真正的常態分佈的差異仍舊是有沒有將平均值減掉。</p><p>$$<br>\nu_x = v_x - \mu_x<br>$$</p><p>$\nu_x$：相對速度</p><p>$v_x$：絕對速度</p><p>或許我們可以這樣解釋，在這整個空間中，整個氣體是靜止不動的，所以他的整體平均速度是 0，而氣體的微觀速度 $\nu_x$ 就是他真正的速度。如果整體氣體是有一個速度在移動的，那麼你可以透過相對速度及平均速度來推得氣體的絕對速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不久前跟好朋友聊天聊到 random walk 的問題，一個醉漢會在一維的空間上隨機往前或往後走一步。&lt;/p&gt;
&lt;p&gt;這樣的話，他最後會走到哪裡去呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Physics" scheme="https://yuehhua.github.io/categories/Physics/"/>
    
    
  </entry>
  
</feed>
